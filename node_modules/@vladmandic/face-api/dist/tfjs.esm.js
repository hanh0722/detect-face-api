/*
  Face-API
  homepage: <https://github.com/vladmandic/face-api>
  author: <https://github.com/vladmandic>'
*/

var mU=Object.create;var AC=Object.defineProperty;var fU=Object.getOwnPropertyDescriptor;var dU=Object.getOwnPropertyNames;var hU=Object.getPrototypeOf,gU=Object.prototype.hasOwnProperty;var Oe=(r,t)=>()=>(t||r((t={exports:{}}).exports,t),t.exports),Yt=(r,t)=>{for(var e in t)AC(r,e,{get:t[e],enumerable:!0})},xU=(r,t,e,n)=>{if(t&&typeof t=="object"||typeof t=="function")for(let o of dU(t))!gU.call(r,o)&&o!==e&&AC(r,o,{get:()=>t[o],enumerable:!(n=fU(t,o))||n.enumerable});return r};var Du=(r,t,e)=>(e=r!=null?mU(hU(r)):{},xU(t||!r||!r.__esModule?AC(e,"default",{value:r,enumerable:!0}):e,r));var R1=Oe(($at,D1)=>{D1.exports=Xe;var co=null;try{co=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(r){}function Xe(r,t,e){this.low=r|0,this.high=t|0,this.unsigned=!!e}Xe.prototype.__isLong__;Object.defineProperty(Xe.prototype,"__isLong__",{value:!0});function Ln(r){return(r&&r.__isLong__)===!0}Xe.isLong=Ln;var I1={},S1={};function zu(r,t){var e,n,o;return t?(r>>>=0,(o=0<=r&&r<256)&&(n=S1[r],n)?n:(e=Ye(r,(r|0)<0?-1:0,!0),o&&(S1[r]=e),e)):(r|=0,(o=-128<=r&&r<128)&&(n=I1[r],n)?n:(e=Ye(r,r<0?-1:0,!1),o&&(I1[r]=e),e))}Xe.fromInt=zu;function po(r,t){if(isNaN(r))return t?Lu:mo;if(t){if(r<0)return Lu;if(r>=_1)return $1}else{if(r<=-N1)return Pn;if(r+1>=N1)return A1}return r<0?po(-r,t).neg():Ye(r%sm|0,r/sm|0,t)}Xe.fromNumber=po;function Ye(r,t,e){return new Xe(r,t,e)}Xe.fromBits=Ye;var gx=Math.pow;function WC(r,t,e){if(r.length===0)throw Error("empty string");if(r==="NaN"||r==="Infinity"||r==="+Infinity"||r==="-Infinity")return mo;if(typeof t=="number"?(e=t,t=!1):t=!!t,e=e||10,e<2||36<e)throw RangeError("radix");var n;if((n=r.indexOf("-"))>0)throw Error("interior hyphen");if(n===0)return WC(r.substring(1),t,e).neg();for(var o=po(gx(e,8)),s=mo,i=0;i<r.length;i+=8){var a=Math.min(8,r.length-i),u=parseInt(r.substring(i,i+a),e);if(a<8){var l=po(gx(e,a));s=s.mul(l).add(po(u))}else s=s.mul(o),s=s.add(po(u))}return s.unsigned=t,s}Xe.fromString=WC;function Hs(r,t){return typeof r=="number"?po(r,t):typeof r=="string"?WC(r,t):Ye(r.low,r.high,typeof t=="boolean"?t:r.unsigned)}Xe.fromValue=Hs;var k1=1<<16,zU=1<<24,sm=k1*k1,_1=sm*sm,N1=_1/2,T1=zu(zU),mo=zu(0);Xe.ZERO=mo;var Lu=zu(0,!0);Xe.UZERO=Lu;var om=zu(1);Xe.ONE=om;var E1=zu(1,!0);Xe.UONE=E1;var GC=zu(-1);Xe.NEG_ONE=GC;var A1=Ye(-1,2147483647,!1);Xe.MAX_VALUE=A1;var $1=Ye(-1,-1,!0);Xe.MAX_UNSIGNED_VALUE=$1;var Pn=Ye(0,-2147483648,!1);Xe.MIN_VALUE=Pn;var yt=Xe.prototype;yt.toInt=function(){return this.unsigned?this.low>>>0:this.low};yt.toNumber=function(){return this.unsigned?(this.high>>>0)*sm+(this.low>>>0):this.high*sm+(this.low>>>0)};yt.toString=function(t){if(t=t||10,t<2||36<t)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(Pn)){var e=po(t),n=this.div(e),o=n.mul(e).sub(this);return n.toString(t)+o.toInt().toString(t)}else return"-"+this.neg().toString(t);for(var s=po(gx(t,6),this.unsigned),i=this,a="";;){var u=i.div(s),l=i.sub(u.mul(s)).toInt()>>>0,c=l.toString(t);if(i=u,i.isZero())return c+a;for(;c.length<6;)c="0"+c;a=""+c+a}};yt.getHighBits=function(){return this.high};yt.getHighBitsUnsigned=function(){return this.high>>>0};yt.getLowBits=function(){return this.low};yt.getLowBitsUnsigned=function(){return this.low>>>0};yt.getNumBitsAbs=function(){if(this.isNegative())return this.eq(Pn)?64:this.neg().getNumBitsAbs();for(var t=this.high!=0?this.high:this.low,e=31;e>0&&(t&1<<e)==0;e--);return this.high!=0?e+33:e+1};yt.isZero=function(){return this.high===0&&this.low===0};yt.eqz=yt.isZero;yt.isNegative=function(){return!this.unsigned&&this.high<0};yt.isPositive=function(){return this.unsigned||this.high>=0};yt.isOdd=function(){return(this.low&1)===1};yt.isEven=function(){return(this.low&1)===0};yt.equals=function(t){return Ln(t)||(t=Hs(t)),this.unsigned!==t.unsigned&&this.high>>>31===1&&t.high>>>31===1?!1:this.high===t.high&&this.low===t.low};yt.eq=yt.equals;yt.notEquals=function(t){return!this.eq(t)};yt.neq=yt.notEquals;yt.ne=yt.notEquals;yt.lessThan=function(t){return this.comp(t)<0};yt.lt=yt.lessThan;yt.lessThanOrEqual=function(t){return this.comp(t)<=0};yt.lte=yt.lessThanOrEqual;yt.le=yt.lessThanOrEqual;yt.greaterThan=function(t){return this.comp(t)>0};yt.gt=yt.greaterThan;yt.greaterThanOrEqual=function(t){return this.comp(t)>=0};yt.gte=yt.greaterThanOrEqual;yt.ge=yt.greaterThanOrEqual;yt.compare=function(t){if(Ln(t)||(t=Hs(t)),this.eq(t))return 0;var e=this.isNegative(),n=t.isNegative();return e&&!n?-1:!e&&n?1:this.unsigned?t.high>>>0>this.high>>>0||t.high===this.high&&t.low>>>0>this.low>>>0?-1:1:this.sub(t).isNegative()?-1:1};yt.comp=yt.compare;yt.negate=function(){return!this.unsigned&&this.eq(Pn)?Pn:this.not().add(om)};yt.neg=yt.negate;yt.add=function(t){Ln(t)||(t=Hs(t));var e=this.high>>>16,n=this.high&65535,o=this.low>>>16,s=this.low&65535,i=t.high>>>16,a=t.high&65535,u=t.low>>>16,l=t.low&65535,c=0,p=0,m=0,f=0;return f+=s+l,m+=f>>>16,f&=65535,m+=o+u,p+=m>>>16,m&=65535,p+=n+a,c+=p>>>16,p&=65535,c+=e+i,c&=65535,Ye(m<<16|f,c<<16|p,this.unsigned)};yt.subtract=function(t){return Ln(t)||(t=Hs(t)),this.add(t.neg())};yt.sub=yt.subtract;yt.multiply=function(t){if(this.isZero())return mo;if(Ln(t)||(t=Hs(t)),co){var e=co.mul(this.low,this.high,t.low,t.high);return Ye(e,co.get_high(),this.unsigned)}if(t.isZero())return mo;if(this.eq(Pn))return t.isOdd()?Pn:mo;if(t.eq(Pn))return this.isOdd()?Pn:mo;if(this.isNegative())return t.isNegative()?this.neg().mul(t.neg()):this.neg().mul(t).neg();if(t.isNegative())return this.mul(t.neg()).neg();if(this.lt(T1)&&t.lt(T1))return po(this.toNumber()*t.toNumber(),this.unsigned);var n=this.high>>>16,o=this.high&65535,s=this.low>>>16,i=this.low&65535,a=t.high>>>16,u=t.high&65535,l=t.low>>>16,c=t.low&65535,p=0,m=0,f=0,d=0;return d+=i*c,f+=d>>>16,d&=65535,f+=s*c,m+=f>>>16,f&=65535,f+=i*l,m+=f>>>16,f&=65535,m+=o*c,p+=m>>>16,m&=65535,m+=s*l,p+=m>>>16,m&=65535,m+=i*u,p+=m>>>16,m&=65535,p+=n*c+o*l+s*u+i*a,p&=65535,Ye(f<<16|d,p<<16|m,this.unsigned)};yt.mul=yt.multiply;yt.divide=function(t){if(Ln(t)||(t=Hs(t)),t.isZero())throw Error("division by zero");if(co){if(!this.unsigned&&this.high===-2147483648&&t.low===-1&&t.high===-1)return this;var e=(this.unsigned?co.div_u:co.div_s)(this.low,this.high,t.low,t.high);return Ye(e,co.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?Lu:mo;var n,o,s;if(this.unsigned){if(t.unsigned||(t=t.toUnsigned()),t.gt(this))return Lu;if(t.gt(this.shru(1)))return E1;s=Lu}else{if(this.eq(Pn)){if(t.eq(om)||t.eq(GC))return Pn;if(t.eq(Pn))return om;var i=this.shr(1);return n=i.div(t).shl(1),n.eq(mo)?t.isNegative()?om:GC:(o=this.sub(t.mul(n)),s=n.add(o.div(t)),s)}else if(t.eq(Pn))return this.unsigned?Lu:mo;if(this.isNegative())return t.isNegative()?this.neg().div(t.neg()):this.neg().div(t).neg();if(t.isNegative())return this.div(t.neg()).neg();s=mo}for(o=this;o.gte(t);){n=Math.max(1,Math.floor(o.toNumber()/t.toNumber()));for(var a=Math.ceil(Math.log(n)/Math.LN2),u=a<=48?1:gx(2,a-48),l=po(n),c=l.mul(t);c.isNegative()||c.gt(o);)n-=u,l=po(n,this.unsigned),c=l.mul(t);l.isZero()&&(l=om),s=s.add(l),o=o.sub(c)}return s};yt.div=yt.divide;yt.modulo=function(t){if(Ln(t)||(t=Hs(t)),co){var e=(this.unsigned?co.rem_u:co.rem_s)(this.low,this.high,t.low,t.high);return Ye(e,co.get_high(),this.unsigned)}return this.sub(this.div(t).mul(t))};yt.mod=yt.modulo;yt.rem=yt.modulo;yt.not=function(){return Ye(~this.low,~this.high,this.unsigned)};yt.and=function(t){return Ln(t)||(t=Hs(t)),Ye(this.low&t.low,this.high&t.high,this.unsigned)};yt.or=function(t){return Ln(t)||(t=Hs(t)),Ye(this.low|t.low,this.high|t.high,this.unsigned)};yt.xor=function(t){return Ln(t)||(t=Hs(t)),Ye(this.low^t.low,this.high^t.high,this.unsigned)};yt.shiftLeft=function(t){return Ln(t)&&(t=t.toInt()),(t&=63)===0?this:t<32?Ye(this.low<<t,this.high<<t|this.low>>>32-t,this.unsigned):Ye(0,this.low<<t-32,this.unsigned)};yt.shl=yt.shiftLeft;yt.shiftRight=function(t){return Ln(t)&&(t=t.toInt()),(t&=63)===0?this:t<32?Ye(this.low>>>t|this.high<<32-t,this.high>>t,this.unsigned):Ye(this.high>>t-32,this.high>=0?0:-1,this.unsigned)};yt.shr=yt.shiftRight;yt.shiftRightUnsigned=function(t){if(Ln(t)&&(t=t.toInt()),t&=63,t===0)return this;var e=this.high;if(t<32){var n=this.low;return Ye(n>>>t|e<<32-t,e>>>t,this.unsigned)}else return t===32?Ye(e,0,this.unsigned):Ye(e>>>t-32,0,this.unsigned)};yt.shru=yt.shiftRightUnsigned;yt.shr_u=yt.shiftRightUnsigned;yt.toSigned=function(){return this.unsigned?Ye(this.low,this.high,!1):this};yt.toUnsigned=function(){return this.unsigned?this:Ye(this.low,this.high,!0)};yt.toBytes=function(t){return t?this.toBytesLE():this.toBytesBE()};yt.toBytesLE=function(){var t=this.high,e=this.low;return[e&255,e>>>8&255,e>>>16&255,e>>>24,t&255,t>>>8&255,t>>>16&255,t>>>24]};yt.toBytesBE=function(){var t=this.high,e=this.low;return[t>>>24,t>>>16&255,t>>>8&255,t&255,e>>>24,e>>>16&255,e>>>8&255,e&255]};Xe.fromBytes=function(t,e,n){return n?Xe.fromBytesLE(t,e):Xe.fromBytesBE(t,e)};Xe.fromBytesLE=function(t,e){return new Xe(t[0]|t[1]<<8|t[2]<<16|t[3]<<24,t[4]|t[5]<<8|t[6]<<16|t[7]<<24,e)};Xe.fromBytesBE=function(t,e){return new Xe(t[4]<<24|t[5]<<16|t[6]<<8|t[7],t[0]<<24|t[1]<<16|t[2]<<8|t[3],e)}});var d_=Oe(()=>{});var h_=Oe(()=>{});var X_=Oe((j_,QI)=>{(function(r,t,e){function n(a){var u=this,l=i();u.next=function(){var c=2091639*u.s0+u.c*23283064365386963e-26;return u.s0=u.s1,u.s1=u.s2,u.s2=c-(u.c=c|0)},u.c=1,u.s0=l(" "),u.s1=l(" "),u.s2=l(" "),u.s0-=l(a),u.s0<0&&(u.s0+=1),u.s1-=l(a),u.s1<0&&(u.s1+=1),u.s2-=l(a),u.s2<0&&(u.s2+=1),l=null}function o(a,u){return u.c=a.c,u.s0=a.s0,u.s1=a.s1,u.s2=a.s2,u}function s(a,u){var l=new n(a),c=u&&u.state,p=l.next;return p.int32=function(){return l.next()*4294967296|0},p.double=function(){return p()+(p()*2097152|0)*11102230246251565e-32},p.quick=p,c&&(typeof c=="object"&&o(c,l),p.state=function(){return o(l,{})}),p}function i(){var a=4022871197,u=function(l){l=l.toString();for(var c=0;c<l.length;c++){a+=l.charCodeAt(c);var p=.02519603282416938*a;a=p>>>0,p-=a,p*=a,a=p>>>0,p-=a,a+=p*4294967296}return(a>>>0)*23283064365386963e-26};return u}t&&t.exports?t.exports=s:e&&e.amd?e(function(){return s}):this.alea=s})(j_,typeof QI=="object"&&QI,typeof define=="function"&&define)});var Z_=Oe((Y_,tS)=>{(function(r,t,e){function n(i){var a=this,u="";a.x=0,a.y=0,a.z=0,a.w=0,a.next=function(){var c=a.x^a.x<<11;return a.x=a.y,a.y=a.z,a.z=a.w,a.w^=a.w>>>19^c^c>>>8},i===(i|0)?a.x=i:u+=i;for(var l=0;l<u.length+64;l++)a.x^=u.charCodeAt(l)|0,a.next()}function o(i,a){return a.x=i.x,a.y=i.y,a.z=i.z,a.w=i.w,a}function s(i,a){var u=new n(i),l=a&&a.state,c=function(){return(u.next()>>>0)/4294967296};return c.double=function(){do var p=u.next()>>>11,m=(u.next()>>>0)/4294967296,f=(p+m)/(1<<21);while(f===0);return f},c.int32=u.next,c.quick=c,l&&(typeof l=="object"&&o(l,u),c.state=function(){return o(u,{})}),c}t&&t.exports?t.exports=s:e&&e.amd?e(function(){return s}):this.xor128=s})(Y_,typeof tS=="object"&&tS,typeof define=="function"&&define)});var Q_=Oe((J_,eS)=>{(function(r,t,e){function n(i){var a=this,u="";a.next=function(){var c=a.x^a.x>>>2;return a.x=a.y,a.y=a.z,a.z=a.w,a.w=a.v,(a.d=a.d+362437|0)+(a.v=a.v^a.v<<4^(c^c<<1))|0},a.x=0,a.y=0,a.z=0,a.w=0,a.v=0,i===(i|0)?a.x=i:u+=i;for(var l=0;l<u.length+64;l++)a.x^=u.charCodeAt(l)|0,l==u.length&&(a.d=a.x<<10^a.x>>>4),a.next()}function o(i,a){return a.x=i.x,a.y=i.y,a.z=i.z,a.w=i.w,a.v=i.v,a.d=i.d,a}function s(i,a){var u=new n(i),l=a&&a.state,c=function(){return(u.next()>>>0)/4294967296};return c.double=function(){do var p=u.next()>>>11,m=(u.next()>>>0)/4294967296,f=(p+m)/(1<<21);while(f===0);return f},c.int32=u.next,c.quick=c,l&&(typeof l=="object"&&o(l,u),c.state=function(){return o(u,{})}),c}t&&t.exports?t.exports=s:e&&e.amd?e(function(){return s}):this.xorwow=s})(J_,typeof eS=="object"&&eS,typeof define=="function"&&define)});var eE=Oe((tE,rS)=>{(function(r,t,e){function n(i){var a=this;a.next=function(){var l=a.x,c=a.i,p,m,f;return p=l[c],p^=p>>>7,m=p^p<<24,p=l[c+1&7],m^=p^p>>>10,p=l[c+3&7],m^=p^p>>>3,p=l[c+4&7],m^=p^p<<7,p=l[c+7&7],p=p^p<<13,m^=p^p<<9,l[c]=m,a.i=c+1&7,m};function u(l,c){var p,m,f=[];if(c===(c|0))m=f[0]=c;else for(c=""+c,p=0;p<c.length;++p)f[p&7]=f[p&7]<<15^c.charCodeAt(p)+f[p+1&7]<<13;for(;f.length<8;)f.push(0);for(p=0;p<8&&f[p]===0;++p);for(p==8?m=f[7]=-1:m=f[p],l.x=f,l.i=0,p=256;p>0;--p)l.next()}u(a,i)}function o(i,a){return a.x=i.x.slice(),a.i=i.i,a}function s(i,a){i==null&&(i=+new Date);var u=new n(i),l=a&&a.state,c=function(){return(u.next()>>>0)/4294967296};return c.double=function(){do var p=u.next()>>>11,m=(u.next()>>>0)/4294967296,f=(p+m)/(1<<21);while(f===0);return f},c.int32=u.next,c.quick=c,l&&(l.x&&o(l,u),c.state=function(){return o(u,{})}),c}t&&t.exports?t.exports=s:e&&e.amd?e(function(){return s}):this.xorshift7=s})(tE,typeof rS=="object"&&rS,typeof define=="function"&&define)});var nE=Oe((rE,nS)=>{(function(r,t,e){function n(i){var a=this;a.next=function(){var l=a.w,c=a.X,p=a.i,m,f;return a.w=l=l+1640531527|0,f=c[p+34&127],m=c[p=p+1&127],f^=f<<13,m^=m<<17,f^=f>>>15,m^=m>>>12,f=c[p]=f^m,a.i=p,f+(l^l>>>16)|0};function u(l,c){var p,m,f,d,h,g=[],y=128;for(c===(c|0)?(m=c,c=null):(c=c+"\0",m=0,y=Math.max(y,c.length)),f=0,d=-32;d<y;++d)c&&(m^=c.charCodeAt((d+32)%c.length)),d===0&&(h=m),m^=m<<10,m^=m>>>15,m^=m<<4,m^=m>>>13,d>=0&&(h=h+1640531527|0,p=g[d&127]^=m+h,f=p==0?f+1:0);for(f>=128&&(g[(c&&c.length||0)&127]=-1),f=127,d=4*128;d>0;--d)m=g[f+34&127],p=g[f=f+1&127],m^=m<<13,p^=p<<17,m^=m>>>15,p^=p>>>12,g[f]=m^p;l.w=h,l.X=g,l.i=f}u(a,i)}function o(i,a){return a.i=i.i,a.w=i.w,a.X=i.X.slice(),a}function s(i,a){i==null&&(i=+new Date);var u=new n(i),l=a&&a.state,c=function(){return(u.next()>>>0)/4294967296};return c.double=function(){do var p=u.next()>>>11,m=(u.next()>>>0)/4294967296,f=(p+m)/(1<<21);while(f===0);return f},c.int32=u.next,c.quick=c,l&&(l.X&&o(l,u),c.state=function(){return o(u,{})}),c}t&&t.exports?t.exports=s:e&&e.amd?e(function(){return s}):this.xor4096=s})(rE,typeof nS=="object"&&nS,typeof define=="function"&&define)});var sE=Oe((oE,oS)=>{(function(r,t,e){function n(i){var a=this,u="";a.next=function(){var c=a.b,p=a.c,m=a.d,f=a.a;return c=c<<25^c>>>7^p,p=p-m|0,m=m<<24^m>>>8^f,f=f-c|0,a.b=c=c<<20^c>>>12^p,a.c=p=p-m|0,a.d=m<<16^p>>>16^f,a.a=f-c|0},a.a=0,a.b=0,a.c=-1640531527,a.d=1367130551,i===Math.floor(i)?(a.a=i/4294967296|0,a.b=i|0):u+=i;for(var l=0;l<u.length+20;l++)a.b^=u.charCodeAt(l)|0,a.next()}function o(i,a){return a.a=i.a,a.b=i.b,a.c=i.c,a.d=i.d,a}function s(i,a){var u=new n(i),l=a&&a.state,c=function(){return(u.next()>>>0)/4294967296};return c.double=function(){do var p=u.next()>>>11,m=(u.next()>>>0)/4294967296,f=(p+m)/(1<<21);while(f===0);return f},c.int32=u.next,c.quick=c,l&&(typeof l=="object"&&o(l,u),c.state=function(){return o(u,{})}),c}t&&t.exports?t.exports=s:e&&e.amd?e(function(){return s}):this.tychei=s})(oE,typeof oS=="object"&&oS,typeof define=="function"&&define)});var sS=Oe(()=>{});var iE=Oe((pIt,Px)=>{(function(r,t){var e=this,n=256,o=6,s=52,i="random",a=t.pow(n,o),u=t.pow(2,s),l=u*2,c=n-1,p;function m(w,v,k){var E=[];v=v==!0?{entropy:!0}:v||{};var $=g(h(v.entropy?[w,b(r)]:w==null?y():w,3),E),D=new f(E),R=function(){for(var P=D.g(o),W=a,U=0;P<u;)P=(P+U)*n,W*=n,U=D.g(1);for(;P>=l;)P/=2,W/=2,U>>>=1;return(P+U)/W};return R.int32=function(){return D.g(4)|0},R.quick=function(){return D.g(4)/4294967296},R.double=R,g(b(D.S),r),(v.pass||k||function(P,W,U,q){return q&&(q.S&&d(q,D),P.state=function(){return d(D,{})}),U?(t[i]=P,W):P})(R,$,"global"in v?v.global:this==t,v.state)}t["seed"+i]=m;function f(w){var v,k=w.length,E=this,$=0,D=E.i=E.j=0,R=E.S=[];for(k||(w=[k++]);$<n;)R[$]=$++;for($=0;$<n;$++)R[$]=R[D=c&D+w[$%k]+(v=R[$])],R[D]=v;(E.g=function(P){for(var W,U=0,q=E.i,K=E.j,j=E.S;P--;)W=j[q=c&q+1],U=U*n+j[c&(j[q]=j[K=c&K+W])+(j[K]=W)];return E.i=q,E.j=K,U})(n)}function d(w,v){return v.i=w.i,v.j=w.j,v.S=w.S.slice(),v}function h(w,v){var k=[],E=typeof w,$;if(v&&E=="object")for($ in w)try{k.push(h(w[$],v-1))}catch(D){}return k.length?k:E=="string"?w:w+"\0"}function g(w,v){for(var k=w+"",E,$=0;$<k.length;)v[c&$]=c&(E^=v[c&$]*19)+k.charCodeAt($++);return b(v)}function y(){try{var w;return p&&(w=p.randomBytes)?w=w(n):(w=new Uint8Array(n),(e.crypto||e.msCrypto).getRandomValues(w)),b(w)}catch(E){var v=e.navigator,k=v&&v.plugins;return[+new Date,e,k,e.screen,b(r)]}}function b(w){return String.fromCharCode.apply(0,w)}if(g(t.random(),r),typeof Px=="object"&&Px.exports){Px.exports=m;try{p=sS()}catch(w){}}else typeof define=="function"&&define.amd&&define(function(){return m})})([],Math)});var iS=Oe((mIt,aE)=>{var GK=X_(),WK=Z_(),UK=Q_(),HK=eE(),qK=nE(),KK=sE(),sc=iE();sc.alea=GK;sc.xor128=WK;sc.xorwow=UK;sc.xorshift7=HK;sc.xor4096=qK;sc.tychei=KK;aE.exports=sc});var GD=Oe((VD,hk)=>{(function(r,t,e){function n(a){var u=this,l=i();u.next=function(){var c=2091639*u.s0+u.c*23283064365386963e-26;return u.s0=u.s1,u.s1=u.s2,u.s2=c-(u.c=c|0)},u.c=1,u.s0=l(" "),u.s1=l(" "),u.s2=l(" "),u.s0-=l(a),u.s0<0&&(u.s0+=1),u.s1-=l(a),u.s1<0&&(u.s1+=1),u.s2-=l(a),u.s2<0&&(u.s2+=1),l=null}function o(a,u){return u.c=a.c,u.s0=a.s0,u.s1=a.s1,u.s2=a.s2,u}function s(a,u){var l=new n(a),c=u&&u.state,p=l.next;return p.int32=function(){return l.next()*4294967296|0},p.double=function(){return p()+(p()*2097152|0)*11102230246251565e-32},p.quick=p,c&&(typeof c=="object"&&o(c,l),p.state=function(){return o(l,{})}),p}function i(){var a=4022871197,u=function(l){l=String(l);for(var c=0;c<l.length;c++){a+=l.charCodeAt(c);var p=.02519603282416938*a;a=p>>>0,p-=a,p*=a,a=p>>>0,p-=a,a+=p*4294967296}return(a>>>0)*23283064365386963e-26};return u}t&&t.exports?t.exports=s:e&&e.amd?e(function(){return s}):this.alea=s})(VD,typeof hk=="object"&&hk,typeof define=="function"&&define)});var UD=Oe((WD,gk)=>{(function(r,t,e){function n(i){var a=this,u="";a.x=0,a.y=0,a.z=0,a.w=0,a.next=function(){var c=a.x^a.x<<11;return a.x=a.y,a.y=a.z,a.z=a.w,a.w^=a.w>>>19^c^c>>>8},i===(i|0)?a.x=i:u+=i;for(var l=0;l<u.length+64;l++)a.x^=u.charCodeAt(l)|0,a.next()}function o(i,a){return a.x=i.x,a.y=i.y,a.z=i.z,a.w=i.w,a}function s(i,a){var u=new n(i),l=a&&a.state,c=function(){return(u.next()>>>0)/4294967296};return c.double=function(){do var p=u.next()>>>11,m=(u.next()>>>0)/4294967296,f=(p+m)/(1<<21);while(f===0);return f},c.int32=u.next,c.quick=c,l&&(typeof l=="object"&&o(l,u),c.state=function(){return o(u,{})}),c}t&&t.exports?t.exports=s:e&&e.amd?e(function(){return s}):this.xor128=s})(WD,typeof gk=="object"&&gk,typeof define=="function"&&define)});var qD=Oe((HD,xk)=>{(function(r,t,e){function n(i){var a=this,u="";a.next=function(){var c=a.x^a.x>>>2;return a.x=a.y,a.y=a.z,a.z=a.w,a.w=a.v,(a.d=a.d+362437|0)+(a.v=a.v^a.v<<4^(c^c<<1))|0},a.x=0,a.y=0,a.z=0,a.w=0,a.v=0,i===(i|0)?a.x=i:u+=i;for(var l=0;l<u.length+64;l++)a.x^=u.charCodeAt(l)|0,l==u.length&&(a.d=a.x<<10^a.x>>>4),a.next()}function o(i,a){return a.x=i.x,a.y=i.y,a.z=i.z,a.w=i.w,a.v=i.v,a.d=i.d,a}function s(i,a){var u=new n(i),l=a&&a.state,c=function(){return(u.next()>>>0)/4294967296};return c.double=function(){do var p=u.next()>>>11,m=(u.next()>>>0)/4294967296,f=(p+m)/(1<<21);while(f===0);return f},c.int32=u.next,c.quick=c,l&&(typeof l=="object"&&o(l,u),c.state=function(){return o(u,{})}),c}t&&t.exports?t.exports=s:e&&e.amd?e(function(){return s}):this.xorwow=s})(HD,typeof xk=="object"&&xk,typeof define=="function"&&define)});var jD=Oe((KD,yk)=>{(function(r,t,e){function n(i){var a=this;a.next=function(){var l=a.x,c=a.i,p,m,f;return p=l[c],p^=p>>>7,m=p^p<<24,p=l[c+1&7],m^=p^p>>>10,p=l[c+3&7],m^=p^p>>>3,p=l[c+4&7],m^=p^p<<7,p=l[c+7&7],p=p^p<<13,m^=p^p<<9,l[c]=m,a.i=c+1&7,m};function u(l,c){var p,m,f=[];if(c===(c|0))m=f[0]=c;else for(c=""+c,p=0;p<c.length;++p)f[p&7]=f[p&7]<<15^c.charCodeAt(p)+f[p+1&7]<<13;for(;f.length<8;)f.push(0);for(p=0;p<8&&f[p]===0;++p);for(p==8?m=f[7]=-1:m=f[p],l.x=f,l.i=0,p=256;p>0;--p)l.next()}u(a,i)}function o(i,a){return a.x=i.x.slice(),a.i=i.i,a}function s(i,a){i==null&&(i=+new Date);var u=new n(i),l=a&&a.state,c=function(){return(u.next()>>>0)/4294967296};return c.double=function(){do var p=u.next()>>>11,m=(u.next()>>>0)/4294967296,f=(p+m)/(1<<21);while(f===0);return f},c.int32=u.next,c.quick=c,l&&(l.x&&o(l,u),c.state=function(){return o(u,{})}),c}t&&t.exports?t.exports=s:e&&e.amd?e(function(){return s}):this.xorshift7=s})(KD,typeof yk=="object"&&yk,typeof define=="function"&&define)});var YD=Oe((XD,bk)=>{(function(r,t,e){function n(i){var a=this;a.next=function(){var l=a.w,c=a.X,p=a.i,m,f;return a.w=l=l+1640531527|0,f=c[p+34&127],m=c[p=p+1&127],f^=f<<13,m^=m<<17,f^=f>>>15,m^=m>>>12,f=c[p]=f^m,a.i=p,f+(l^l>>>16)|0};function u(l,c){var p,m,f,d,h,g=[],y=128;for(c===(c|0)?(m=c,c=null):(c=c+"\0",m=0,y=Math.max(y,c.length)),f=0,d=-32;d<y;++d)c&&(m^=c.charCodeAt((d+32)%c.length)),d===0&&(h=m),m^=m<<10,m^=m>>>15,m^=m<<4,m^=m>>>13,d>=0&&(h=h+1640531527|0,p=g[d&127]^=m+h,f=p==0?f+1:0);for(f>=128&&(g[(c&&c.length||0)&127]=-1),f=127,d=4*128;d>0;--d)m=g[f+34&127],p=g[f=f+1&127],m^=m<<13,p^=p<<17,m^=m>>>15,p^=p>>>12,g[f]=m^p;l.w=h,l.X=g,l.i=f}u(a,i)}function o(i,a){return a.i=i.i,a.w=i.w,a.X=i.X.slice(),a}function s(i,a){i==null&&(i=+new Date);var u=new n(i),l=a&&a.state,c=function(){return(u.next()>>>0)/4294967296};return c.double=function(){do var p=u.next()>>>11,m=(u.next()>>>0)/4294967296,f=(p+m)/(1<<21);while(f===0);return f},c.int32=u.next,c.quick=c,l&&(l.X&&o(l,u),c.state=function(){return o(u,{})}),c}t&&t.exports?t.exports=s:e&&e.amd?e(function(){return s}):this.xor4096=s})(XD,typeof bk=="object"&&bk,typeof define=="function"&&define)});var JD=Oe((ZD,wk)=>{(function(r,t,e){function n(i){var a=this,u="";a.next=function(){var c=a.b,p=a.c,m=a.d,f=a.a;return c=c<<25^c>>>7^p,p=p-m|0,m=m<<24^m>>>8^f,f=f-c|0,a.b=c=c<<20^c>>>12^p,a.c=p=p-m|0,a.d=m<<16^p>>>16^f,a.a=f-c|0},a.a=0,a.b=0,a.c=-1640531527,a.d=1367130551,i===Math.floor(i)?(a.a=i/4294967296|0,a.b=i|0):u+=i;for(var l=0;l<u.length+20;l++)a.b^=u.charCodeAt(l)|0,a.next()}function o(i,a){return a.a=i.a,a.b=i.b,a.c=i.c,a.d=i.d,a}function s(i,a){var u=new n(i),l=a&&a.state,c=function(){return(u.next()>>>0)/4294967296};return c.double=function(){do var p=u.next()>>>11,m=(u.next()>>>0)/4294967296,f=(p+m)/(1<<21);while(f===0);return f},c.int32=u.next,c.quick=c,l&&(typeof l=="object"&&o(l,u),c.state=function(){return o(u,{})}),c}t&&t.exports?t.exports=s:e&&e.amd?e(function(){return s}):this.tychei=s})(ZD,typeof wk=="object"&&wk,typeof define=="function"&&define)});var tR=Oe((QD,kb)=>{(function(r,t,e){var n=256,o=6,s=52,i="random",a=e.pow(n,o),u=e.pow(2,s),l=u*2,c=n-1,p;function m(w,v,k){var E=[];v=v==!0?{entropy:!0}:v||{};var $=g(h(v.entropy?[w,b(t)]:w==null?y():w,3),E),D=new f(E),R=function(){for(var P=D.g(o),W=a,U=0;P<u;)P=(P+U)*n,W*=n,U=D.g(1);for(;P>=l;)P/=2,W/=2,U>>>=1;return(P+U)/W};return R.int32=function(){return D.g(4)|0},R.quick=function(){return D.g(4)/4294967296},R.double=R,g(b(D.S),t),(v.pass||k||function(P,W,U,q){return q&&(q.S&&d(q,D),P.state=function(){return d(D,{})}),U?(e[i]=P,W):P})(R,$,"global"in v?v.global:this==e,v.state)}function f(w){var v,k=w.length,E=this,$=0,D=E.i=E.j=0,R=E.S=[];for(k||(w=[k++]);$<n;)R[$]=$++;for($=0;$<n;$++)R[$]=R[D=c&D+w[$%k]+(v=R[$])],R[D]=v;(E.g=function(P){for(var W,U=0,q=E.i,K=E.j,j=E.S;P--;)W=j[q=c&q+1],U=U*n+j[c&(j[q]=j[K=c&K+W])+(j[K]=W)];return E.i=q,E.j=K,U})(n)}function d(w,v){return v.i=w.i,v.j=w.j,v.S=w.S.slice(),v}function h(w,v){var k=[],E=typeof w,$;if(v&&E=="object")for($ in w)try{k.push(h(w[$],v-1))}catch(D){}return k.length?k:E=="string"?w:w+"\0"}function g(w,v){for(var k=w+"",E,$=0;$<k.length;)v[c&$]=c&(E^=v[c&$]*19)+k.charCodeAt($++);return b(v)}function y(){try{var w;return p&&(w=p.randomBytes)?w=w(n):(w=new Uint8Array(n),(r.crypto||r.msCrypto).getRandomValues(w)),b(w)}catch(E){var v=r.navigator,k=v&&v.plugins;return[+new Date,r,k,r.screen,b(t)]}}function b(w){return String.fromCharCode.apply(0,w)}if(g(e.random(),t),typeof kb=="object"&&kb.exports){kb.exports=m;try{p=sS()}catch(w){}}else typeof define=="function"&&define.amd?define(function(){return m}):e["seed"+i]=m})(typeof self!="undefined"?self:QD,[],Math)});var vk=Oe((Iie,eR)=>{var aZ=GD(),lZ=UD(),uZ=qD(),cZ=jD(),pZ=YD(),mZ=JD(),Vc=tR();Vc.alea=aZ;Vc.xor128=lZ;Vc.xorwow=uZ;Vc.xorshift7=cZ;Vc.xor4096=pZ;Vc.tychei=mZ;eR.exports=Vc});var Ck=Oe(()=>{});var Ob=Oe(()=>{});var Ag=Oe(()=>{});var uW=Oe(()=>{});var cW=Oe(()=>{});var pW=Oe(()=>{});var mW=Oe((Yv,BT)=>{var zT=(()=>{var r=typeof document!="undefined"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename!="undefined"&&(r=r||__filename),function(t){t=t||{};function e(){return Ot.buffer!=gr&&Go(Ot.buffer),lp}function n(){return Ot.buffer!=gr&&Go(Ot.buffer),up}function o(){return Ot.buffer!=gr&&Go(Ot.buffer),Nd}function s(){return Ot.buffer!=gr&&Go(Ot.buffer),Og}function i(){return Ot.buffer!=gr&&Go(Ot.buffer),Mg}function a(){return Ot.buffer!=gr&&Go(Ot.buffer),Pg}function u(){return Ot.buffer!=gr&&Go(Ot.buffer),Lg}var l=typeof t!="undefined"?t:{},c,p;l.ready=new Promise(function(T,F){c=T,p=F});var m;typeof process!="undefined"&&process.listeners&&(m={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var f=Object.assign({},l),d=[],h="./this.program",g=(T,F)=>{throw F},y=typeof window=="object",b=typeof importScripts=="function",w=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",v=l.ENVIRONMENT_IS_PTHREAD||!1,k="";function E(T){return l.locateFile?l.locateFile(T,k):k+T}var $,D,R,P;function W(T){if(T instanceof Md)return;X("exiting due to exception: "+T)}var U,q,K;if(w){b?k=Ag().dirname(k)+"/":k=__dirname+"/",K=()=>{q||(U=Ob(),q=Ag())},$=function(G,Y){return K(),G=q.normalize(G),U.readFileSync(G,Y?void 0:"utf8")},R=F=>{var G=$(F,!0);return G.buffer||(G=new Uint8Array(G)),G},D=(F,G,Y)=>{K(),F=q.normalize(F),U.readFile(F,function(ht,wt){ht?Y(ht):G(wt.buffer)})},process.argv.length>1&&(h=process.argv[1].replace(/\\/g,"/")),d=process.argv.slice(2),process.on("uncaughtException",function(F){if(!(F instanceof Md))throw F}),process.on("unhandledRejection",function(F){throw F}),g=(F,G)=>{if(Tu())throw process.exitCode=F,G;W(G),process.exit(F)},l.inspect=function(){return"[Emscripten Module object]"};let T;try{T=uW()}catch(F){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),F}global.Worker=T.Worker}else(y||b)&&(b?k=self.location.href:typeof document!="undefined"&&document.currentScript&&(k=document.currentScript.src),typeof r!="undefined"&&r&&(k=r),k.indexOf("blob:")!==0?k=k.substr(0,k.replace(/[?#].*/,"").lastIndexOf("/")+1):k="",w||($=T=>{var F=new XMLHttpRequest;return F.open("GET",T,!1),F.send(null),F.responseText},b&&(R=T=>{var F=new XMLHttpRequest;return F.open("GET",T,!1),F.responseType="arraybuffer",F.send(null),new Uint8Array(F.response)}),D=(T,F,G)=>{var Y=new XMLHttpRequest;Y.open("GET",T,!0),Y.responseType="arraybuffer",Y.onload=()=>{if(Y.status==200||Y.status==0&&Y.response){F(Y.response);return}G()},Y.onerror=G,Y.send(null)}),P=T=>document.title=T);w&&typeof performance=="undefined"&&(global.performance=cW().performance);var j=console.log.bind(console),Q=console.warn.bind(console);w&&(K(),j=T=>U.writeSync(1,T+`
`),Q=T=>U.writeSync(2,T+`
`));var rt=l.print||j,X=l.printErr||Q;Object.assign(l,f),f=null,l.arguments&&(d=l.arguments),l.thisProgram&&(h=l.thisProgram),l.quit&&(g=l.quit);var ot=4;function st(T){st.shown||(st.shown={}),st.shown[T]||(st.shown[T]=1,X(T))}function it(T,F){if(typeof WebAssembly.Function=="function"){for(var G={i:"i32",j:"i64",f:"f32",d:"f64"},Y={parameters:[],results:F[0]=="v"?[]:[G[F[0]]]},ht=1;ht<F.length;++ht)Y.parameters.push(G[F[ht]]);return new WebAssembly.Function(Y,T)}var wt=[1,0,1,96],Tt=F.slice(0,1),Gt=F.slice(1),sr={i:127,j:126,f:125,d:124};wt.push(Gt.length);for(var ht=0;ht<Gt.length;++ht)wt.push(sr[Gt[ht]]);Tt=="v"?wt.push(0):wt=wt.concat([1,sr[Tt]]),wt[1]=wt.length-2;var qo=new Uint8Array([0,97,115,109,1,0,0,0].concat(wt,[2,7,1,1,101,1,102,0,0,7,5,1,1,102,0,0])),Ko=new WebAssembly.Module(qo),mx=new WebAssembly.Instance(Ko,{e:{f:T}}),Pd=mx.exports.f;return Pd}var ft=[],at;function xt(){if(ft.length)return ft.pop();try{qn.grow(1)}catch(T){throw T instanceof RangeError?"Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.":T}return qn.length-1}function dt(T,F){for(var G=T;G<T+F;G++){var Y=dp(G);Y&&at.set(Y,G)}}var bt=0,kt=T=>{bt=T},At=Atomics.load,Dt=Atomics.store,qt=Atomics.compareExchange,Kt;l.wasmBinary&&(Kt=l.wasmBinary);var ce=l.noExitRuntime||!0;typeof WebAssembly!="object"&&pp("no native wasm support detected");var Ot,$e,Se=!1,ae;function je(T,F){T||pp(F)}function Fe(T){var F=l["_"+T];return F}function rn(T,F,G,Y,ht){var wt={string:function(On){var vp=0;if(On!=null&&On!==0){var m1=(On.length<<2)+1;vp=wp(m1),Fn(On,vp,m1)}return vp},array:function(On){var vp=wp(On.length);return Nl(On,vp),vp}};function Tt(On){return F==="string"?jr(On):F==="boolean"?Boolean(On):On}var Gt=Fe(T),sr=[],qo=0;if(Y)for(var Ko=0;Ko<Y.length;Ko++){var mx=wt[G[Ko]];mx?(qo===0&&(qo=_C()),sr[Ko]=mx(Y[Ko])):sr[Ko]=Y[Ko]}var Pd=Gt.apply(null,sr);function pU(On){return qo!==0&&lx(qo),Tt(On)}return Pd=pU(Pd),Pd}function ze(T,F,G,Y){G=G||[];var ht=G.every(function(Tt){return Tt==="number"}),wt=F!=="string";return wt&&ht&&!Y?Fe(T):function(){return rn(T,F,G,arguments,Y)}}var Bo=1;function Fr(T){var F=new TextDecoder(T);this.decode=G=>(G.buffer instanceof SharedArrayBuffer&&(G=new Uint8Array(G)),F.decode.call(F,G))}var nn=typeof TextDecoder!="undefined"?new Fr("utf8"):void 0;function on(T,F,G){for(var Y=F+G,ht=F;T[ht]&&!(ht>=Y);)++ht;if(ht-F>16&&T.subarray&&nn)return nn.decode(T.subarray(F,ht));for(var wt="";F<ht;){var Tt=T[F++];if(!(Tt&128)){wt+=String.fromCharCode(Tt);continue}var Gt=T[F++]&63;if((Tt&224)==192){wt+=String.fromCharCode((Tt&31)<<6|Gt);continue}var sr=T[F++]&63;if((Tt&240)==224?Tt=(Tt&15)<<12|Gt<<6|sr:Tt=(Tt&7)<<18|Gt<<12|sr<<6|T[F++]&63,Tt<65536)wt+=String.fromCharCode(Tt);else{var qo=Tt-65536;wt+=String.fromCharCode(55296|qo>>10,56320|qo&1023)}}return wt}function jr(T,F){return T?on(n(),T,F):""}function oo(T,F,G,Y){if(!(Y>0))return 0;for(var ht=G,wt=G+Y-1,Tt=0;Tt<T.length;++Tt){var Gt=T.charCodeAt(Tt);if(Gt>=55296&&Gt<=57343){var sr=T.charCodeAt(++Tt);Gt=65536+((Gt&1023)<<10)|sr&1023}if(Gt<=127){if(G>=wt)break;F[G++]=Gt}else if(Gt<=2047){if(G+1>=wt)break;F[G++]=192|Gt>>6,F[G++]=128|Gt&63}else if(Gt<=65535){if(G+2>=wt)break;F[G++]=224|Gt>>12,F[G++]=128|Gt>>6&63,F[G++]=128|Gt&63}else{if(G+3>=wt)break;F[G++]=240|Gt>>18,F[G++]=128|Gt>>12&63,F[G++]=128|Gt>>6&63,F[G++]=128|Gt&63}}return F[G]=0,G-ht}function Fn(T,F,G){return oo(T,n(),F,G)}function Vo(T){for(var F=0,G=0;G<T.length;++G){var Y=T.charCodeAt(G);Y>=55296&&Y<=57343&&(Y=65536+((Y&1023)<<10)|T.charCodeAt(++G)&1023),Y<=127?++F:Y<=2047?F+=2:Y<=65535?F+=3:F+=4}return F}var so=typeof TextDecoder!="undefined"?new Fr("utf-16le"):void 0;function Nl(T,F){e().set(T,F)}function ku(T,F,G){for(var Y=0;Y<T.length;++Y)e()[F++>>0]=T.charCodeAt(Y);G||(e()[F>>0]=0)}function ap(T,F){return T%F>0&&(T+=F-T%F),T}var gr,lp,up,Nd,Og,Mg,qT,Pg,Lg;v&&(gr=l.buffer);function Go(T){gr=T,l.HEAP8=lp=new Int8Array(T),l.HEAP16=Nd=new Int16Array(T),l.HEAP32=Mg=new Int32Array(T),l.HEAPU8=up=new Uint8Array(T),l.HEAPU16=Og=new Uint16Array(T),l.HEAPU32=qT=new Uint32Array(T),l.HEAPF32=Pg=new Float32Array(T),l.HEAPF64=Lg=new Float64Array(T)}var zg=l.INITIAL_MEMORY||16777216;if(v)Ot=l.wasmMemory,gr=l.buffer;else if(l.wasmMemory)Ot=l.wasmMemory;else if(Ot=new WebAssembly.Memory({initial:zg/65536,maximum:32768,shared:!0}),!(Ot.buffer instanceof SharedArrayBuffer))throw X("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),w&&console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)"),Error("bad memory");Ot&&(gr=Ot.buffer),zg=gr.byteLength,Go(gr);var qn,cp=[],Tl=[],Qv=[],Bg=[],Nu=!1,t0=!1,Vg=0;function Tu(){return ce||Vg>0}function sn(){if(l.preRun)for(typeof l.preRun=="function"&&(l.preRun=[l.preRun]);l.preRun.length;)KT(l.preRun.shift());Hg(cp)}function Td(){Nu=!0,!v&&Hg(Tl)}function e0(){v||(Ht.terminateAllThreads(),t0=!0)}function r0(){if(!v){if(l.postRun)for(typeof l.postRun=="function"&&(l.postRun=[l.postRun]);l.postRun.length;)_d(l.postRun.shift());Hg(Bg)}}function KT(T){cp.unshift(T)}function jT(T){Tl.unshift(T)}function _d(T){Bg.unshift(T)}var _l=0,Gg=null,Wo=null;function Ed(T){_l++,l.monitorRunDependencies&&l.monitorRunDependencies(_l)}function XT(T){if(_l--,l.monitorRunDependencies&&l.monitorRunDependencies(_l),_l==0&&(Gg!==null&&(clearInterval(Gg),Gg=null),Wo)){var F=Wo;Wo=null,F()}}l.preloadedImages={},l.preloadedAudios={};function pp(T){v?postMessage({cmd:"onAbort",arg:T}):l.onAbort&&l.onAbort(T),T="Aborted("+T+")",X(T),Se=!0,ae=1,T+=". Build with -s ASSERTIONS=1 for more info.";var F=new WebAssembly.RuntimeError(T);throw p(F),F}var n0="data:application/octet-stream;base64,";function Ad(T){return T.startsWith(n0)}function Wg(T){return T.startsWith("file://")}var an;an="tfjs-backend-wasm-threaded-simd.wasm",Ad(an)||(an=E(an));function Ug(T){try{if(T==an&&Kt)return new Uint8Array(Kt);if(R)return R(T);throw"both async and sync fetching of the wasm failed"}catch(F){pp(F)}}function mp(){if(!Kt&&(y||b)){if(typeof fetch=="function"&&!Wg(an))return fetch(an,{credentials:"same-origin"}).then(function(T){if(!T.ok)throw"failed to load wasm binary file at '"+an+"'";return T.arrayBuffer()}).catch(function(){return Ug(an)});if(D)return new Promise(function(T,F){D(an,function(G){T(new Uint8Array(G))},F)})}return Promise.resolve().then(function(){return Ug(an)})}function o0(){var T={env:nx,wasi_snapshot_preview1:nx};function F(Tt,Gt){var sr=Tt.exports;if(l.asm=sr,p0(l.asm.emscripten_tls_init),qn=l.asm.__indirect_function_table,jT(l.asm.__wasm_call_ctors),$e=Gt,!v){var qo=Ht.unusedWorkers.length;Ht.unusedWorkers.forEach(function(Ko){Ht.loadWasmModuleToWorker(Ko,function(){--qo||XT("wasm-instantiate")})})}}v||Ed("wasm-instantiate");function G(Tt){F(Tt.instance,Tt.module)}function Y(Tt){return mp().then(function(Gt){return WebAssembly.instantiate(Gt,T)}).then(function(Gt){return Gt}).then(Tt,function(Gt){X("failed to asynchronously prepare wasm: "+Gt),pp(Gt)})}function ht(){return!Kt&&typeof WebAssembly.instantiateStreaming=="function"&&!Ad(an)&&!Wg(an)&&typeof fetch=="function"?fetch(an,{credentials:"same-origin"}).then(function(Tt){var Gt=WebAssembly.instantiateStreaming(Tt,T);return Gt.then(G,function(sr){return X("wasm streaming compile failed: "+sr),X("falling back to ArrayBuffer instantiation"),Y(G)})}):Y(G)}if(l.instantiateWasm)try{var wt=l.instantiateWasm(T,F);return wt}catch(Tt){return X("Module.instantiateWasm callback failed with error: "+Tt),!1}return ht().catch(p),{}}var YT,ZT,s0={};function Hg(T){for(;T.length>0;){var F=T.shift();if(typeof F=="function"){F(l);continue}var G=F.func;typeof G=="number"?F.arg===void 0?dp(G)():dp(G)(F.arg):G(F.arg===void 0?null:F.arg)}}function fp(T){var F=_C(),G=T();return lx(F),G}function bW(T){return T}function JT(T){var F=/\b_Z[\w\d_]+/g;return T.replace(F,function(G){var Y=G;return G===Y?G:Y+" ["+G+"]"})}function i0(T){i()[T>>2]=0;var F=Ht.pthreads[T];delete Ht.pthreads[T],F.worker.terminate(),TC(T),Ht.runningWorkers.splice(Ht.runningWorkers.indexOf(F.worker),1),F.worker.pthread=void 0}function a0(T){var F=Ht.pthreads[T];F.worker.postMessage({cmd:"cancel"})}function qg(T){var F=Ht.pthreads[T];if(F){i()[T>>2]=0;var G=F.worker;Ht.returnWorkerToPool(G)}}function Kg(T){lU(T)}function l0(T){if(T instanceof Md||T=="unwind")return ae;g(1,T)}var Ht={unusedWorkers:[],runningWorkers:[],tlsInitFunctions:[],init:function(){v?Ht.initWorker():Ht.initMainThread()},initMainThread:function(){for(var T=8,F=0;F<T;++F)Ht.allocateUnusedWorker()},initWorker:function(){ce=!1},pthreads:{},setExitStatus:function(T){ae=T},terminateAllThreads:function(){for(var T in Ht.pthreads){var F=Ht.pthreads[T];F&&F.worker&&Ht.returnWorkerToPool(F.worker)}for(var G=0;G<Ht.unusedWorkers.length;++G){var Y=Ht.unusedWorkers[G];Y.terminate()}Ht.unusedWorkers=[]},returnWorkerToPool:function(T){Ht.runWithoutMainThreadQueuedCalls(function(){delete Ht.pthreads[T.pthread.threadInfoStruct],Ht.unusedWorkers.push(T),Ht.runningWorkers.splice(Ht.runningWorkers.indexOf(T),1),TC(T.pthread.threadInfoStruct),T.pthread=void 0})},runWithoutMainThreadQueuedCalls:function(T){i()[p1>>2]=0;try{T()}finally{i()[p1>>2]=1}},receiveObjectTransfer:function(T){},threadInit:function(){for(var T in Ht.tlsInitFunctions)Ht.tlsInitFunctions[T]()},loadWasmModuleToWorker:function(T,F){T.onmessage=G=>{var Y=G.data,ht=Y.cmd;if(T.pthread&&(Ht.currentProxiedOperationCallerThread=T.pthread.threadInfoStruct),Y.targetThread&&Y.targetThread!=ax()){var wt=Ht.pthreads[Y.targetThread];wt?wt.worker.postMessage(Y,Y.transferList):X('Internal error! Worker sent a message "'+ht+'" to target pthread '+Y.targetThread+", but that thread no longer exists!"),Ht.currentProxiedOperationCallerThread=void 0;return}ht==="processQueuedMainThreadWork"?i1():ht==="spawnThread"?Xg(Y):ht==="cleanupThread"?qg(Y.thread):ht==="killThread"?i0(Y.thread):ht==="cancelThread"?a0(Y.thread):ht==="loaded"?(T.loaded=!0,F&&F(T),T.runPthread&&(T.runPthread(),delete T.runPthread)):ht==="print"?rt("Thread "+Y.threadId+": "+Y.text):ht==="printErr"?X("Thread "+Y.threadId+": "+Y.text):ht==="alert"?alert("Thread "+Y.threadId+": "+Y.text):Y.target==="setimmediate"?T.postMessage(Y):ht==="onAbort"?l.onAbort&&l.onAbort(Y.arg):X("worker sent an unknown command "+ht),Ht.currentProxiedOperationCallerThread=void 0},T.onerror=G=>{var Y="worker sent an error!";throw X(Y+" "+G.filename+":"+G.lineno+": "+G.message),G},w&&(T.on("message",function(G){T.onmessage({data:G})}),T.on("error",function(G){T.onerror(G)}),T.on("detachedExit",function(){})),T.postMessage({cmd:"load",urlOrBlob:l.mainScriptUrlOrBlob||r,wasmMemory:Ot,wasmModule:$e})},allocateUnusedWorker:function(){var T=E("tfjs-backend-wasm-threaded-simd.worker.js");Ht.unusedWorkers.push(new Worker(T))},getNewWorker:function(){return Ht.unusedWorkers.length==0&&(Ht.allocateUnusedWorker(),Ht.loadWasmModuleToWorker(Ht.unusedWorkers[0])),Ht.unusedWorkers.pop()}};function u0(){var T=ax(),F=i()[T+44>>2],G=i()[T+48>>2],Y=F-G;c1(F,Y),lx(F)}l.establishStackSpace=u0;function jg(T){if(v)return Au(1,0,T);try{Kg(T)}catch(F){l0(F)}}var _u=[];function dp(T){var F=_u[T];return F||(T>=_u.length&&(_u.length=T+1),_u[T]=F=qn.get(T)),F}function c0(T,F){return dp(T)(F)}l.invokeEntryPoint=c0;function QT(){var T=new Error;if(!T.stack){try{throw new Error}catch(F){T=F}if(!T.stack)return"(no stack trace available)"}return T.stack.toString()}function p0(T,F,G){Ht.tlsInitFunctions.push(T)}function t1(T,F){qn.set(T,F),_u[T]=F}var Eu;w?Eu=()=>{var T=process.hrtime();return T[0]*1e3+T[1]/1e6}:v?Eu=()=>performance.now()-l.__performance_now_clock_drift:Eu=()=>performance.now();var m0=!0;function f0(T){return i()[s1()>>2]=T,T}function d0(T,F){var G;if(T===0)G=Date.now();else if((T===1||T===4)&&m0)G=Eu();else return f0(28),-1;return i()[F>>2]=G/1e3|0,i()[F+4>>2]=G%1e3*1e3*1e3|0,0}function h0(T,F){return d0(T,F)}function g0(T){a1(T,!b,1,!y),Ht.threadInit()}function x0(T){v?postMessage({cmd:"cleanupThread",thread:T}):qg(T)}function Xg(T){var F=Ht.getNewWorker();if(!F)return 6;Ht.runningWorkers.push(F);var G=Ht.pthreads[T.pthread_ptr]={worker:F,threadInfoStruct:T.pthread_ptr};F.pthread=G;var Y={cmd:"run",start_routine:T.startRoutine,arg:T.arg,threadInfoStruct:T.pthread_ptr};return F.runPthread=()=>{Y.time=performance.now(),F.postMessage(Y,T.transferList)},F.loaded&&(F.runPthread(),delete F.runPthread),0}function y0(T,F,G,Y){if(typeof SharedArrayBuffer=="undefined")return X("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var ht=[],wt=0;if(v&&(ht.length===0||wt))return l1(687865856,T,F,G,Y);if(wt)return wt;var Tt={startRoutine:G,pthread_ptr:T,arg:Y,transferList:ht};return v?(Tt.cmd="spawnThread",postMessage(Tt,ht),0):Xg(Tt)}function b0(){return 2097152}function w0(T,F){if(T==F)postMessage({cmd:"processQueuedMainThreadWork"});else if(v)postMessage({targetThread:T,cmd:"processThreadQueue"});else{var G=Ht.pthreads[T],Y=G&&G.worker;if(!Y)return;Y.postMessage({cmd:"processThreadQueue"})}return 1}function v0(){pp("")}function C0(){w||b||st("Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread")}function Yg(){return 2147483648}function I0(T,F,G){n().copyWithin(T,F,F+G)}function S0(){return w?pW().cpus().length:navigator.hardwareConcurrency}function Au(T,F){var G=arguments.length-2,Y=arguments;return fp(function(){for(var ht=G,wt=wp(ht*8),Tt=wt>>3,Gt=0;Gt<G;Gt++){var sr=Y[2+Gt];u()[Tt+Gt]=sr}return u1(T,ht,wt,F)})}var $d=[];function k0(T,F,G){$d.length=F;for(var Y=G>>3,ht=0;ht<F;ht++)$d[ht]=u()[Y+ht];var wt=T<0,Tt=wt?s0[-T-1]:U0[T];return Tt.apply(null,$d)}function N0(T){try{return Ot.grow(T-gr.byteLength+65535>>>16),Go(Ot.buffer),1}catch(F){}}function T0(T){var F=n().length;if(T=T>>>0,T<=F)return!1;var G=Yg();if(T>G)return!1;for(var Y=1;Y<=4;Y*=2){var ht=F*(1+.2/Y);ht=Math.min(ht,T+100663296);var wt=Math.min(G,ap(Math.max(T,ht),65536)),Tt=N0(wt);if(Tt)return!0}return!1}var ee={inEventHandler:0,removeAllEventListeners:function(){for(var T=ee.eventHandlers.length-1;T>=0;--T)ee._removeHandler(T);ee.eventHandlers=[],ee.deferredCalls=[]},registerRemoveEventListeners:function(){ee.removeEventListenersRegistered||(Qv.push(ee.removeAllEventListeners),ee.removeEventListenersRegistered=!0)},deferredCalls:[],deferCall:function(T,F,G){function Y(Tt,Gt){if(Tt.length!=Gt.length)return!1;for(var sr in Tt)if(Tt[sr]!=Gt[sr])return!1;return!0}for(var ht in ee.deferredCalls){var wt=ee.deferredCalls[ht];if(wt.targetFunction==T&&Y(wt.argsList,G))return}ee.deferredCalls.push({targetFunction:T,precedence:F,argsList:G}),ee.deferredCalls.sort(function(Tt,Gt){return Tt.precedence<Gt.precedence})},removeDeferredCalls:function(T){for(var F=0;F<ee.deferredCalls.length;++F)ee.deferredCalls[F].targetFunction==T&&(ee.deferredCalls.splice(F,1),--F)},canPerformEventHandlerRequests:function(){return ee.inEventHandler&&ee.currentEventHandler.allowsDeferredCalls},runDeferredCalls:function(){if(!!ee.canPerformEventHandlerRequests())for(var T=0;T<ee.deferredCalls.length;++T){var F=ee.deferredCalls[T];ee.deferredCalls.splice(T,1),--T,F.targetFunction.apply(null,F.argsList)}},eventHandlers:[],removeAllHandlersOnTarget:function(T,F){for(var G=0;G<ee.eventHandlers.length;++G)ee.eventHandlers[G].target==T&&(!F||F==ee.eventHandlers[G].eventTypeString)&&ee._removeHandler(G--)},_removeHandler:function(T){var F=ee.eventHandlers[T];F.target.removeEventListener(F.eventTypeString,F.eventListenerFunc,F.useCapture),ee.eventHandlers.splice(T,1)},registerOrRemoveHandler:function(T){var F=function(ht){++ee.inEventHandler,ee.currentEventHandler=T,ee.runDeferredCalls(),T.handlerFunc(ht),ee.runDeferredCalls(),--ee.inEventHandler};if(T.callbackfunc)T.eventListenerFunc=F,T.target.addEventListener(T.eventTypeString,F,T.useCapture),ee.eventHandlers.push(T),ee.registerRemoveEventListeners();else for(var G=0;G<ee.eventHandlers.length;++G)ee.eventHandlers[G].target==T.target&&ee.eventHandlers[G].eventTypeString==T.eventTypeString&&ee._removeHandler(G--)},queueEventHandlerOnThread_iiii:function(T,F,G,Y,ht){fp(function(){var wt=wp(12);i()[wt>>2]=G,i()[wt+4>>2]=Y,i()[wt+8>>2]=ht,NC(T,637534208,F,Y,wt)})},getTargetThreadForEventCallback:function(T){switch(T){case 1:return 0;case 2:return Ht.currentProxiedOperationCallerThread;default:return T}},getNodeNameForTarget:function(T){return T?T==window?"#window":T==screen?"#screen":T&&T.nodeName?T.nodeName:"":""},fullscreenEnabled:function(){return document.fullscreenEnabled||document.webkitFullscreenEnabled}};function _0(T){var F=Vo(T)+1,G=kC(F);return Fn(T,G,F),G}function E0(T,F,G,Y){fp(function(){var ht=wp(12),wt=0;F&&(wt=_0(F)),i()[ht>>2]=wt,i()[ht+4>>2]=G,i()[ht+8>>2]=Y,NC(T,657457152,0,wt,ht)})}function A0(T,F,G,Y){F=F?jr(F):"",E0(T,F,G,Y)}function $0(T){return T>2?jr(T):T}var D0=[0,typeof document!="undefined"?document:0,typeof window!="undefined"?window:0];function R0(T){T=$0(T);var F=D0[T]||(typeof document!="undefined"?document.querySelector(T):void 0);return F}function Dd(T){return R0(T)}function Zg(T,F,G){var Y=Dd(T);if(!Y)return-4;if(Y.canvasSharedPtr&&(i()[Y.canvasSharedPtr>>2]=F,i()[Y.canvasSharedPtr+4>>2]=G),Y.offscreenCanvas||!Y.controlTransferredOffscreen){Y.offscreenCanvas&&(Y=Y.offscreenCanvas);var ht=!1;if(Y.GLctxObject&&Y.GLctxObject.GLctx){var wt=Y.GLctxObject.GLctx.getParameter(2978);ht=wt[0]===0&&wt[1]===0&&wt[2]===Y.width&&wt[3]===Y.height}Y.width=F,Y.height=G,ht&&Y.GLctxObject.GLctx.viewport(0,0,F,G)}else if(Y.canvasSharedPtr){var Tt=i()[Y.canvasSharedPtr+8>>2];return A0(Tt,T,F,G),1}else return-4;return 0}function Jg(T,F,G){return v?Au(2,1,T,F,G):Zg(T,F,G)}function F0(T,F,G){var Y=Dd(T);return Y?Zg(T,F,G):Jg(T,F,G)}function O0(){throw"unwind"}function M0(T){var F=T.getExtension("ANGLE_instanced_arrays");if(F)return T.vertexAttribDivisor=function(G,Y){F.vertexAttribDivisorANGLE(G,Y)},T.drawArraysInstanced=function(G,Y,ht,wt){F.drawArraysInstancedANGLE(G,Y,ht,wt)},T.drawElementsInstanced=function(G,Y,ht,wt,Tt){F.drawElementsInstancedANGLE(G,Y,ht,wt,Tt)},1}function P0(T){var F=T.getExtension("OES_vertex_array_object");if(F)return T.createVertexArray=function(){return F.createVertexArrayOES()},T.deleteVertexArray=function(G){F.deleteVertexArrayOES(G)},T.bindVertexArray=function(G){F.bindVertexArrayOES(G)},T.isVertexArray=function(G){return F.isVertexArrayOES(G)},1}function L0(T){var F=T.getExtension("WEBGL_draw_buffers");if(F)return T.drawBuffers=function(G,Y){F.drawBuffersWEBGL(G,Y)},1}function z0(T){return!!(T.multiDrawWebgl=T.getExtension("WEBGL_multi_draw"))}var or={counter:1,buffers:[],programs:[],framebuffers:[],renderbuffers:[],textures:[],shaders:[],vaos:[],contexts:{},offscreenCanvases:{},queries:[],stringCache:{},unpackAlignment:4,recordError:function(F){or.lastError||(or.lastError=F)},getNewId:function(T){for(var F=or.counter++,G=T.length;G<F;G++)T[G]=null;return F},getSource:function(T,F,G,Y){for(var ht="",wt=0;wt<F;++wt){var Tt=Y?i()[Y+wt*4>>2]:-1;ht+=jr(i()[G+wt*4>>2],Tt<0?void 0:Tt)}return ht},createContext:function(T,F){T.getContextSafariWebGL2Fixed||(T.getContextSafariWebGL2Fixed=T.getContext,T.getContext=function(ht,wt){var Tt=T.getContextSafariWebGL2Fixed(ht,wt);return ht=="webgl"==Tt instanceof WebGLRenderingContext?Tt:null});var G=T.getContext("webgl",F);if(!G)return 0;var Y=or.registerContext(G,F);return Y},registerContext:function(T,F){var G=kC(8);i()[G+4>>2]=ax();var Y={handle:G,attributes:F,version:F.majorVersion,GLctx:T};return T.canvas&&(T.canvas.GLctxObject=Y),or.contexts[G]=Y,(typeof F.enableExtensionsByDefault=="undefined"||F.enableExtensionsByDefault)&&or.initExtensions(Y),G},makeContextCurrent:function(T){return or.currentContext=or.contexts[T],l.ctx=rx=or.currentContext&&or.currentContext.GLctx,!(T&&!rx)},getContext:function(T){return or.contexts[T]},deleteContext:function(T){or.currentContext===or.contexts[T]&&(or.currentContext=null),typeof ee=="object"&&ee.removeAllHandlersOnTarget(or.contexts[T].GLctx.canvas),or.contexts[T]&&or.contexts[T].GLctx.canvas&&(or.contexts[T].GLctx.canvas.GLctxObject=void 0),o1(or.contexts[T].handle),or.contexts[T]=null},initExtensions:function(T){if(T||(T=or.currentContext),!T.initExtensionsDone){T.initExtensionsDone=!0;var F=T.GLctx;M0(F),P0(F),L0(F),F.disjointTimerQueryExt=F.getExtension("EXT_disjoint_timer_query"),z0(F);var G=F.getSupportedExtensions()||[];G.forEach(function(Y){!Y.includes("lose_context")&&!Y.includes("debug")&&F.getExtension(Y)})}}},B0=["default","low-power","high-performance"];function V0(T,F){var G=F>>2,Y=i()[G+6],ht={alpha:!!i()[G+0],depth:!!i()[G+1],stencil:!!i()[G+2],antialias:!!i()[G+3],premultipliedAlpha:!!i()[G+4],preserveDrawingBuffer:!!i()[G+5],powerPreference:B0[Y],failIfMajorPerformanceCaveat:!!i()[G+7],majorVersion:i()[G+8],minorVersion:i()[G+9],enableExtensionsByDefault:i()[G+10],explicitSwapControl:i()[G+11],proxyContextToMainThread:i()[G+12],renderViaOffscreenBackBuffer:i()[G+13]},wt=Dd(T);if(!wt||ht.explicitSwapControl)return 0;var Tt=or.createContext(wt,ht);return Tt}function G0(T,F){return V0(T,F)}var hp={mappings:{},buffers:[null,[],[]],printChar:function(T,F){var G=hp.buffers[T];F===0||F===10?((T===1?rt:X)(on(G,0)),G.length=0):G.push(F)},varargs:void 0,get:function(){hp.varargs+=4;var T=i()[hp.varargs-4>>2];return T},getStr:function(T){var F=jr(T);return F},get64:function(T,F){return T}};function Qg(T){return v?Au(3,1,T):0}function tx(T,F,G,Y,ht){if(v)return Au(4,1,T,F,G,Y,ht)}function ex(T,F,G,Y){if(v)return Au(5,1,T,F,G,Y);for(var ht=0,wt=0;wt<G;wt++){var Tt=i()[F>>2],Gt=i()[F+4>>2];F+=8;for(var sr=0;sr<Gt;sr++)hp.printChar(T,n()[Tt+sr]);ht+=Gt}return i()[Y>>2]=ht,0}function W0(T){kt(T)}Ht.init();var rx,U0=[null,jg,Jg,Qg,tx,ex],e1=!1,nx={__clock_gettime:h0,__emscripten_init_main_thread_js:g0,__emscripten_thread_cleanup:x0,__pthread_create_js:y0,_emscripten_default_pthread_stack_size:b0,_emscripten_notify_thread_queue:w0,abort:v0,emscripten_check_blocking_allowed:C0,emscripten_get_heap_max:Yg,emscripten_get_now:Eu,emscripten_memcpy_big:I0,emscripten_num_logical_cores:S0,emscripten_receive_on_main_thread_js:k0,emscripten_resize_heap:T0,emscripten_set_canvas_element_size:F0,emscripten_unwind_to_js_event_loop:O0,emscripten_webgl_create_context:G0,exit:Kg,fd_close:Qg,fd_seek:tx,fd_write:ex,memory:Ot||l.wasmMemory,setTempRet0:W0},r1=o0(),H0=l.___wasm_call_ctors=function(){return(H0=l.___wasm_call_ctors=l.asm.__wasm_call_ctors).apply(null,arguments)},q0=l._init=function(){return(q0=l._init=l.asm.init).apply(null,arguments)},K0=l._init_with_threads_count=function(){return(K0=l._init_with_threads_count=l.asm.init_with_threads_count).apply(null,arguments)},j0=l._get_threads_count=function(){return(j0=l._get_threads_count=l.asm.get_threads_count).apply(null,arguments)},X0=l._register_tensor=function(){return(X0=l._register_tensor=l.asm.register_tensor).apply(null,arguments)},Y0=l._dispose_data=function(){return(Y0=l._dispose_data=l.asm.dispose_data).apply(null,arguments)},Z0=l._dispose=function(){return(Z0=l._dispose=l.asm.dispose).apply(null,arguments)},J0=l._Abs=function(){return(J0=l._Abs=l.asm.Abs).apply(null,arguments)},Q0=l._Add=function(){return(Q0=l._Add=l.asm.Add).apply(null,arguments)},tC=l._AddN=function(){return(tC=l._AddN=l.asm.AddN).apply(null,arguments)},eC=l._All=function(){return(eC=l._All=l.asm.All).apply(null,arguments)},rC=l._Any=function(){return(rC=l._Any=l.asm.Any).apply(null,arguments)},nC=l._ArgMax=function(){return(nC=l._ArgMax=l.asm.ArgMax).apply(null,arguments)},oC=l._AvgPool=function(){return(oC=l._AvgPool=l.asm.AvgPool).apply(null,arguments)},sC=l._BatchMatMul=function(){return(sC=l._BatchMatMul=l.asm.BatchMatMul).apply(null,arguments)},iC=l._Ceil=function(){return(iC=l._Ceil=l.asm.Ceil).apply(null,arguments)},aC=l._ClipByValue=function(){return(aC=l._ClipByValue=l.asm.ClipByValue).apply(null,arguments)},lC=l._Conv2D=function(){return(lC=l._Conv2D=l.asm.Conv2D).apply(null,arguments)},uC=l._Conv2DBackpropInput=function(){return(uC=l._Conv2DBackpropInput=l.asm.Conv2DBackpropInput).apply(null,arguments)},cC=l._Cos=function(){return(cC=l._Cos=l.asm.Cos).apply(null,arguments)},pC=l._Cosh=function(){return(pC=l._Cosh=l.asm.Cosh).apply(null,arguments)},mC=l._CropAndResize=function(){return(mC=l._CropAndResize=l.asm.CropAndResize).apply(null,arguments)},fC=l._Cumprod=function(){return(fC=l._Cumprod=l.asm.Cumprod).apply(null,arguments)},dC=l._Cumsum=function(){return(dC=l._Cumsum=l.asm.Cumsum).apply(null,arguments)},hC=l._DepthToSpace=function(){return(hC=l._DepthToSpace=l.asm.DepthToSpace).apply(null,arguments)},gC=l._DepthwiseConv2dNative=function(){return(gC=l._DepthwiseConv2dNative=l.asm.DepthwiseConv2dNative).apply(null,arguments)},xC=l._Elu=function(){return(xC=l._Elu=l.asm.Elu).apply(null,arguments)},yC=l._Equal=function(){return(yC=l._Equal=l.asm.Equal).apply(null,arguments)},bC=l._Exp=function(){return(bC=l._Exp=l.asm.Exp).apply(null,arguments)},wC=l._FlipLeftRight=function(){return(wC=l._FlipLeftRight=l.asm.FlipLeftRight).apply(null,arguments)},ox=l._Floor=function(){return(ox=l._Floor=l.asm.Floor).apply(null,arguments)},sx=l._FloorDiv=function(){return(sx=l._FloorDiv=l.asm.FloorDiv).apply(null,arguments)},Rd=l._FusedBatchNorm=function(){return(Rd=l._FusedBatchNorm=l.asm.FusedBatchNorm).apply(null,arguments)},vC=l._FusedConv2D=function(){return(vC=l._FusedConv2D=l.asm.FusedConv2D).apply(null,arguments)},CC=l._FusedDepthwiseConv2D=function(){return(CC=l._FusedDepthwiseConv2D=l.asm.FusedDepthwiseConv2D).apply(null,arguments)},gp=l._Gather=function(){return(gp=l._Gather=l.asm.Gather).apply(null,arguments)},Fd=l._GatherNd=function(){return(Fd=l._GatherNd=l.asm.GatherNd).apply(null,arguments)},Od=l._Greater=function(){return(Od=l._Greater=l.asm.Greater).apply(null,arguments)},n1=l._GreaterEqual=function(){return(n1=l._GreaterEqual=l.asm.GreaterEqual).apply(null,arguments)},xp=l._LeakyRelu=function(){return(xp=l._LeakyRelu=l.asm.LeakyRelu).apply(null,arguments)},yp=l._Less=function(){return(yp=l._Less=l.asm.Less).apply(null,arguments)},IC=l._LessEqual=function(){return(IC=l._LessEqual=l.asm.LessEqual).apply(null,arguments)},H=l._Log=function(){return(H=l._Log=l.asm.Log).apply(null,arguments)},tt=l._LogicalAnd=function(){return(tt=l._LogicalAnd=l.asm.LogicalAnd).apply(null,arguments)},gt=l._Max=function(){return(gt=l._Max=l.asm.Max).apply(null,arguments)},$t=l._MaxPool=function(){return($t=l._MaxPool=l.asm.MaxPool).apply(null,arguments)},fe=l._Maximum=function(){return(fe=l._Maximum=l.asm.Maximum).apply(null,arguments)},he=l._Mean=function(){return(he=l._Mean=l.asm.Mean).apply(null,arguments)},oe=l._Min=function(){return(oe=l._Min=l.asm.Min).apply(null,arguments)},Qt=l._Minimum=function(){return(Qt=l._Minimum=l.asm.Minimum).apply(null,arguments)},xr=l._MirrorPad=function(){return(xr=l._MirrorPad=l.asm.MirrorPad).apply(null,arguments)},Uo=l._Multiply=function(){return(Uo=l._Multiply=l.asm.Multiply).apply(null,arguments)},Ho=l._Neg=function(){return(Ho=l._Neg=l.asm.Neg).apply(null,arguments)},bp=l._NonMaxSuppressionV3=function(){return(bp=l._NonMaxSuppressionV3=l.asm.NonMaxSuppressionV3).apply(null,arguments)},$u=l._NonMaxSuppressionV4=function(){return($u=l._NonMaxSuppressionV4=l.asm.NonMaxSuppressionV4).apply(null,arguments)},SC=l._NonMaxSuppressionV5=function(){return(SC=l._NonMaxSuppressionV5=l.asm.NonMaxSuppressionV5).apply(null,arguments)},ln=l._NotEqual=function(){return(ln=l._NotEqual=l.asm.NotEqual).apply(null,arguments)},El=l._OneHot=function(){return(El=l._OneHot=l.asm.OneHot).apply(null,arguments)},ix=l._PadV2=function(){return(ix=l._PadV2=l.asm.PadV2).apply(null,arguments)},wW=l._Pow=function(){return(wW=l._Pow=l.asm.Pow).apply(null,arguments)},vW=l._Prelu=function(){return(vW=l._Prelu=l.asm.Prelu).apply(null,arguments)},CW=l._Prod=function(){return(CW=l._Prod=l.asm.Prod).apply(null,arguments)},IW=l._RealDiv=function(){return(IW=l._RealDiv=l.asm.RealDiv).apply(null,arguments)},SW=l._Relu=function(){return(SW=l._Relu=l.asm.Relu).apply(null,arguments)},kW=l._Relu6=function(){return(kW=l._Relu6=l.asm.Relu6).apply(null,arguments)},NW=l._ResizeBilinear=function(){return(NW=l._ResizeBilinear=l.asm.ResizeBilinear).apply(null,arguments)},TW=l._Reverse=function(){return(TW=l._Reverse=l.asm.Reverse).apply(null,arguments)},_W=l._RotateWithOffset=function(){return(_W=l._RotateWithOffset=l.asm.RotateWithOffset).apply(null,arguments)},EW=l._Round=function(){return(EW=l._Round=l.asm.Round).apply(null,arguments)},AW=l._Rsqrt=function(){return(AW=l._Rsqrt=l.asm.Rsqrt).apply(null,arguments)},$W=l._ScatterNd=function(){return($W=l._ScatterNd=l.asm.ScatterNd).apply(null,arguments)},DW=l._SelectV2=function(){return(DW=l._SelectV2=l.asm.SelectV2).apply(null,arguments)},RW=l._Sigmoid=function(){return(RW=l._Sigmoid=l.asm.Sigmoid).apply(null,arguments)},FW=l._Sin=function(){return(FW=l._Sin=l.asm.Sin).apply(null,arguments)},OW=l._Softmax=function(){return(OW=l._Softmax=l.asm.Softmax).apply(null,arguments)},MW=l._SparseFillEmptyRows=function(){return(MW=l._SparseFillEmptyRows=l.asm.SparseFillEmptyRows).apply(null,arguments)},PW=l._SparseReshape=function(){return(PW=l._SparseReshape=l.asm.SparseReshape).apply(null,arguments)},LW=l._SparseSegmentReduction=function(){return(LW=l._SparseSegmentReduction=l.asm.SparseSegmentReduction).apply(null,arguments)},zW=l._Sqrt=function(){return(zW=l._Sqrt=l.asm.Sqrt).apply(null,arguments)},BW=l._Square=function(){return(BW=l._Square=l.asm.Square).apply(null,arguments)},VW=l._SquaredDifference=function(){return(VW=l._SquaredDifference=l.asm.SquaredDifference).apply(null,arguments)},GW=l._Step=function(){return(GW=l._Step=l.asm.Step).apply(null,arguments)},WW=l._StridedSlice=function(){return(WW=l._StridedSlice=l.asm.StridedSlice).apply(null,arguments)},UW=l._Sub=function(){return(UW=l._Sub=l.asm.Sub).apply(null,arguments)},HW=l._Sum=function(){return(HW=l._Sum=l.asm.Sum).apply(null,arguments)},qW=l._Tan=function(){return(qW=l._Tan=l.asm.Tan).apply(null,arguments)},KW=l._Tanh=function(){return(KW=l._Tanh=l.asm.Tanh).apply(null,arguments)},jW=l._Tile=function(){return(jW=l._Tile=l.asm.Tile).apply(null,arguments)},XW=l._TopK=function(){return(XW=l._TopK=l.asm.TopK).apply(null,arguments)},YW=l._Transform=function(){return(YW=l._Transform=l.asm.Transform).apply(null,arguments)},ZW=l._Transpose=function(){return(ZW=l._Transpose=l.asm.Transpose).apply(null,arguments)},JW=l.__FusedMatMul=function(){return(JW=l.__FusedMatMul=l.asm._FusedMatMul).apply(null,arguments)},kC=l._malloc=function(){return(kC=l._malloc=l.asm.malloc).apply(null,arguments)},o1=l._free=function(){return(o1=l._free=l.asm.free).apply(null,arguments)},QW=l._emscripten_tls_init=function(){return(QW=l._emscripten_tls_init=l.asm.emscripten_tls_init).apply(null,arguments)},s1=l.___errno_location=function(){return(s1=l.___errno_location=l.asm.__errno_location).apply(null,arguments)},ax=l._pthread_self=function(){return(ax=l._pthread_self=l.asm.pthread_self).apply(null,arguments)},i1=l._emscripten_main_thread_process_queued_calls=function(){return(i1=l._emscripten_main_thread_process_queued_calls=l.asm.emscripten_main_thread_process_queued_calls).apply(null,arguments)},tU=l.__emscripten_thread_crashed=function(){return(tU=l.__emscripten_thread_crashed=l.asm._emscripten_thread_crashed).apply(null,arguments)},a1=l.__emscripten_thread_init=function(){return(a1=l.__emscripten_thread_init=l.asm._emscripten_thread_init).apply(null,arguments)},eU=l._emscripten_current_thread_process_queued_calls=function(){return(eU=l._emscripten_current_thread_process_queued_calls=l.asm.emscripten_current_thread_process_queued_calls).apply(null,arguments)},rU=l._emscripten_main_browser_thread_id=function(){return(rU=l._emscripten_main_browser_thread_id=l.asm.emscripten_main_browser_thread_id).apply(null,arguments)},nU=l._emscripten_sync_run_in_main_thread_2=function(){return(nU=l._emscripten_sync_run_in_main_thread_2=l.asm.emscripten_sync_run_in_main_thread_2).apply(null,arguments)},l1=l._emscripten_sync_run_in_main_thread_4=function(){return(l1=l._emscripten_sync_run_in_main_thread_4=l.asm.emscripten_sync_run_in_main_thread_4).apply(null,arguments)},u1=l._emscripten_run_in_main_runtime_thread_js=function(){return(u1=l._emscripten_run_in_main_runtime_thread_js=l.asm.emscripten_run_in_main_runtime_thread_js).apply(null,arguments)},NC=l._emscripten_dispatch_to_thread_=function(){return(NC=l._emscripten_dispatch_to_thread_=l.asm.emscripten_dispatch_to_thread_).apply(null,arguments)},TC=l.__emscripten_thread_free_data=function(){return(TC=l.__emscripten_thread_free_data=l.asm._emscripten_thread_free_data).apply(null,arguments)},oU=l.__emscripten_thread_exit=function(){return(oU=l.__emscripten_thread_exit=l.asm._emscripten_thread_exit).apply(null,arguments)},sU=l._memalign=function(){return(sU=l._memalign=l.asm.memalign).apply(null,arguments)},c1=l._emscripten_stack_set_limits=function(){return(c1=l._emscripten_stack_set_limits=l.asm.emscripten_stack_set_limits).apply(null,arguments)},_C=l.stackSave=function(){return(_C=l.stackSave=l.asm.stackSave).apply(null,arguments)},lx=l.stackRestore=function(){return(lx=l.stackRestore=l.asm.stackRestore).apply(null,arguments)},wp=l.stackAlloc=function(){return(wp=l.stackAlloc=l.asm.stackAlloc).apply(null,arguments)},iU=l.dynCall_iijjiiii=function(){return(iU=l.dynCall_iijjiiii=l.asm.dynCall_iijjiiii).apply(null,arguments)},aU=l.dynCall_jiji=function(){return(aU=l.dynCall_jiji=l.asm.dynCall_jiji).apply(null,arguments)},p1=l.__emscripten_allow_main_runtime_queued_calls=21464;l.cwrap=ze,l.keepRuntimeAlive=Tu,l.PThread=Ht,l.PThread=Ht,l.wasmMemory=Ot,l.ExitStatus=Md;var ux;function Md(T){this.name="ExitStatus",this.message="Program terminated with exit("+T+")",this.status=T}Wo=function T(){ux||EC(),ux||(Wo=T)};function EC(T){if(T=T||d,_l>0)return;if(v){c(l),Td(),postMessage({cmd:"loaded"});return}if(sn(),_l>0)return;function F(){ux||(ux=!0,l.calledRun=!0,!Se&&(Td(),c(l),l.onRuntimeInitialized&&l.onRuntimeInitialized(),r0()))}l.setStatus?(l.setStatus("Running..."),setTimeout(function(){setTimeout(function(){l.setStatus("")},1),F()},1)):F()}l.run=EC;function lU(T,F){if(ae=T,!F&&v)throw jg(T),"unwind";Tu()||e0(),uU(T)}function uU(T){ae=T,Tu()||(Ht.terminateAllThreads(),l.onExit&&l.onExit(T),Se=!0),g(T,new Md(T))}if(l.preInit)for(typeof l.preInit=="function"&&(l.preInit=[l.preInit]);l.preInit.length>0;)l.preInit.pop()();EC();var cx;m&&(cx={uncaughtException:process.listeners("uncaughtException").filter(function(T){return!m.uncaughtException.indexOf(T)>-1}),unhandledRejection:process.listeners("unhandledRejection").filter(function(T){return!m.unhandledRejection.indexOf(T)>-1})});var px;if(typeof WasmBackendModule!="undefined")px=WasmBackendModule;else if(typeof t!="undefined")px=t;else throw new Error("Could not find wasm module in post.js");if(cx){var cU=px._dispose;px._dispose=function(){cU(),cx.uncaughtException.forEach(function(T){process.removeListener("uncaughtException",T)}),cx.unhandledRejection.forEach(function(T){process.removeListener("unhandledRejection",T)})}}return t.ready}})();typeof Yv=="object"&&typeof BT=="object"?BT.exports=zT:typeof define=="function"&&define.amd?define([],function(){return zT}):typeof Yv=="object"&&(Yv.WasmBackendModuleThreadedSimd=zT)});var dW=Oe((Zv,GT)=>{var VT=(()=>{var r=typeof document!="undefined"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename!="undefined"&&(r=r||__filename),function(t){t=t||{};var e=typeof t!="undefined"?t:{},n,o;e.ready=new Promise(function(H,tt){n=H,o=tt});var s;typeof process!="undefined"&&process.listeners&&(s={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var i=Object.assign({},e),a=[],u="./this.program",l=(H,tt)=>{throw tt},c=typeof window=="object",p=typeof importScripts=="function",m=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",f="";function d(H){return e.locateFile?e.locateFile(H,f):f+H}var h,g,y,b;function w(H){if(H instanceof Fd)return;D("exiting due to exception: "+H)}var v,k,E;m?(p?f=Ag().dirname(f)+"/":f=__dirname+"/",E=()=>{k||(v=Ob(),k=Ag())},h=function(tt,gt){return E(),tt=k.normalize(tt),v.readFileSync(tt,gt?void 0:"utf8")},y=H=>{var tt=h(H,!0);return tt.buffer||(tt=new Uint8Array(tt)),tt},g=(H,tt,gt)=>{E(),H=k.normalize(H),v.readFile(H,function($t,fe){$t?gt($t):tt(fe.buffer)})},process.argv.length>1&&(u=process.argv[1].replace(/\\/g,"/")),a=process.argv.slice(2),process.on("uncaughtException",function(H){if(!(H instanceof Fd))throw H}),process.on("unhandledRejection",function(H){throw H}),l=(H,tt)=>{if(Nd())throw process.exitCode=H,tt;w(tt),process.exit(H)},e.inspect=function(){return"[Emscripten Module object]"}):(c||p)&&(p?f=self.location.href:typeof document!="undefined"&&document.currentScript&&(f=document.currentScript.src),r&&(f=r),f.indexOf("blob:")!==0?f=f.substr(0,f.replace(/[?#].*/,"").lastIndexOf("/")+1):f="",h=H=>{var tt=new XMLHttpRequest;return tt.open("GET",H,!1),tt.send(null),tt.responseText},p&&(y=H=>{var tt=new XMLHttpRequest;return tt.open("GET",H,!1),tt.responseType="arraybuffer",tt.send(null),new Uint8Array(tt.response)}),g=(H,tt,gt)=>{var $t=new XMLHttpRequest;$t.open("GET",H,!0),$t.responseType="arraybuffer",$t.onload=()=>{if($t.status==200||$t.status==0&&$t.response){tt($t.response);return}gt()},$t.onerror=gt,$t.send(null)},b=H=>document.title=H);var $=e.print||console.log.bind(console),D=e.printErr||console.warn.bind(console);Object.assign(e,i),i=null,e.arguments&&(a=e.arguments),e.thisProgram&&(u=e.thisProgram),e.quit&&(l=e.quit);var R=4;function P(H){P.shown||(P.shown={}),P.shown[H]||(P.shown[H]=1,D(H))}function W(H,tt){if(typeof WebAssembly.Function=="function"){for(var gt={i:"i32",j:"i64",f:"f32",d:"f64"},$t={parameters:[],results:tt[0]=="v"?[]:[gt[tt[0]]]},fe=1;fe<tt.length;++fe)$t.parameters.push(gt[tt[fe]]);return new WebAssembly.Function($t,H)}var he=[1,0,1,96],oe=tt.slice(0,1),Qt=tt.slice(1),xr={i:127,j:126,f:125,d:124};he.push(Qt.length);for(var fe=0;fe<Qt.length;++fe)he.push(xr[Qt[fe]]);oe=="v"?he.push(0):he=he.concat([1,xr[oe]]),he[1]=he.length-2;var Uo=new Uint8Array([0,97,115,109,1,0,0,0].concat(he,[2,7,1,1,101,1,102,0,0,7,5,1,1,102,0,0])),Ho=new WebAssembly.Module(Uo),bp=new WebAssembly.Instance(Ho,{e:{f:H}}),$u=bp.exports.f;return $u}var U=[],q;function K(){if(U.length)return U.pop();try{so.grow(1)}catch(H){throw H instanceof RangeError?"Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.":H}return so.length-1}function j(H,tt){for(var gt=H;gt<H+tt;gt++){var $t=Ed(gt);$t&&q.set($t,gt)}}var Q=0,rt=H=>{Q=H},X;e.wasmBinary&&(X=e.wasmBinary);var ot=e.noExitRuntime||!0;typeof WebAssembly!="object"&&Nu("no native wasm support detected");var st,it=!1,ft;function at(H,tt){H||Nu(tt)}function xt(H){var tt=e["_"+H];return tt}function dt(H,tt,gt,$t,fe){var he={string:function(ln){var El=0;if(ln!=null&&ln!==0){var ix=(ln.length<<2)+1;El=Rd(ix),ce(ln,El,ix)}return El},array:function(ln){var El=Rd(ln.length);return Se(ln,El),El}};function oe(ln){return tt==="string"?qt(ln):tt==="boolean"?Boolean(ln):ln}var Qt=xt(H),xr=[],Uo=0;if($t)for(var Ho=0;Ho<$t.length;Ho++){var bp=he[gt[Ho]];bp?(Uo===0&&(Uo=ox()),xr[Ho]=bp($t[Ho])):xr[Ho]=$t[Ho]}var $u=Qt.apply(null,xr);function SC(ln){return Uo!==0&&sx(Uo),oe(ln)}return $u=SC($u),$u}function bt(H,tt,gt,$t){gt=gt||[];var fe=gt.every(function(oe){return oe==="number"}),he=tt!=="string";return he&&fe&&!$t?xt(H):function(){return dt(H,tt,gt,arguments,$t)}}var kt=1,At=typeof TextDecoder!="undefined"?new TextDecoder("utf8"):void 0;function Dt(H,tt,gt){for(var $t=tt+gt,fe=tt;H[fe]&&!(fe>=$t);)++fe;if(fe-tt>16&&H.subarray&&At)return At.decode(H.subarray(tt,fe));for(var he="";tt<fe;){var oe=H[tt++];if(!(oe&128)){he+=String.fromCharCode(oe);continue}var Qt=H[tt++]&63;if((oe&224)==192){he+=String.fromCharCode((oe&31)<<6|Qt);continue}var xr=H[tt++]&63;if((oe&240)==224?oe=(oe&15)<<12|Qt<<6|xr:oe=(oe&7)<<18|Qt<<12|xr<<6|H[tt++]&63,oe<65536)he+=String.fromCharCode(oe);else{var Uo=oe-65536;he+=String.fromCharCode(55296|Uo>>10,56320|Uo&1023)}}return he}function qt(H,tt){return H?Dt(ze,H,tt):""}function Kt(H,tt,gt,$t){if(!($t>0))return 0;for(var fe=gt,he=gt+$t-1,oe=0;oe<H.length;++oe){var Qt=H.charCodeAt(oe);if(Qt>=55296&&Qt<=57343){var xr=H.charCodeAt(++oe);Qt=65536+((Qt&1023)<<10)|xr&1023}if(Qt<=127){if(gt>=he)break;tt[gt++]=Qt}else if(Qt<=2047){if(gt+1>=he)break;tt[gt++]=192|Qt>>6,tt[gt++]=128|Qt&63}else if(Qt<=65535){if(gt+2>=he)break;tt[gt++]=224|Qt>>12,tt[gt++]=128|Qt>>6&63,tt[gt++]=128|Qt&63}else{if(gt+3>=he)break;tt[gt++]=240|Qt>>18,tt[gt++]=128|Qt>>12&63,tt[gt++]=128|Qt>>6&63,tt[gt++]=128|Qt&63}}return tt[gt]=0,gt-fe}function ce(H,tt,gt){return Kt(H,ze,tt,gt)}function Ot(H){for(var tt=0,gt=0;gt<H.length;++gt){var $t=H.charCodeAt(gt);$t>=55296&&$t<=57343&&($t=65536+(($t&1023)<<10)|H.charCodeAt(++gt)&1023),$t<=127?++tt:$t<=2047?tt+=2:$t<=65535?tt+=3:tt+=4}return tt}var $e=typeof TextDecoder!="undefined"?new TextDecoder("utf-16le"):void 0;function Se(H,tt){rn.set(H,tt)}function ae(H,tt,gt){for(var $t=0;$t<H.length;++$t)rn[tt++>>0]=H.charCodeAt($t);gt||(rn[tt>>0]=0)}function je(H,tt){return H%tt>0&&(H+=tt-H%tt),H}var Fe,rn,ze,Bo,Fr,nn,on,jr,oo;function Fn(H){Fe=H,e.HEAP8=rn=new Int8Array(H),e.HEAP16=Bo=new Int16Array(H),e.HEAP32=nn=new Int32Array(H),e.HEAPU8=ze=new Uint8Array(H),e.HEAPU16=Fr=new Uint16Array(H),e.HEAPU32=on=new Uint32Array(H),e.HEAPF32=jr=new Float32Array(H),e.HEAPF64=oo=new Float64Array(H)}var Vo=e.INITIAL_MEMORY||16777216,so,Nl=[],ku=[],ap=[],gr=!1,lp=!1,up=0;function Nd(){return ot||up>0}function Og(){if(e.preRun)for(typeof e.preRun=="function"&&(e.preRun=[e.preRun]);e.preRun.length;)Lg(e.preRun.shift());_d(Nl)}function Mg(){gr=!0,_d(ku)}function qT(){lp=!0}function Pg(){if(e.postRun)for(typeof e.postRun=="function"&&(e.postRun=[e.postRun]);e.postRun.length;)zg(e.postRun.shift());_d(ap)}function Lg(H){Nl.unshift(H)}function Go(H){ku.unshift(H)}function zg(H){ap.unshift(H)}var qn=0,cp=null,Tl=null;function Qv(H){qn++,e.monitorRunDependencies&&e.monitorRunDependencies(qn)}function Bg(H){if(qn--,e.monitorRunDependencies&&e.monitorRunDependencies(qn),qn==0&&(cp!==null&&(clearInterval(cp),cp=null),Tl)){var tt=Tl;Tl=null,tt()}}e.preloadedImages={},e.preloadedAudios={};function Nu(H){e.onAbort&&e.onAbort(H),H="Aborted("+H+")",D(H),it=!0,ft=1,H+=". Build with -s ASSERTIONS=1 for more info.";var tt=new WebAssembly.RuntimeError(H);throw o(tt),tt}var t0="data:application/octet-stream;base64,";function Vg(H){return H.startsWith(t0)}function Tu(H){return H.startsWith("file://")}var sn;sn="tfjs-backend-wasm.wasm",Vg(sn)||(sn=d(sn));function Td(H){try{if(H==sn&&X)return new Uint8Array(X);if(y)return y(H);throw"both async and sync fetching of the wasm failed"}catch(tt){Nu(tt)}}function e0(){if(!X&&(c||p)){if(typeof fetch=="function"&&!Tu(sn))return fetch(sn,{credentials:"same-origin"}).then(function(H){if(!H.ok)throw"failed to load wasm binary file at '"+sn+"'";return H.arrayBuffer()}).catch(function(){return Td(sn)});if(g)return new Promise(function(H,tt){g(sn,function(gt){H(new Uint8Array(gt))},tt)})}return Promise.resolve().then(function(){return Td(sn)})}function r0(){var H={env:fp,wasi_snapshot_preview1:fp};function tt(oe,Qt){var xr=oe.exports;e.asm=xr,st=e.asm.memory,Fn(st.buffer),so=e.asm.__indirect_function_table,Go(e.asm.__wasm_call_ctors),Bg("wasm-instantiate")}Qv("wasm-instantiate");function gt(oe){tt(oe.instance)}function $t(oe){return e0().then(function(Qt){return WebAssembly.instantiate(Qt,H)}).then(function(Qt){return Qt}).then(oe,function(Qt){D("failed to asynchronously prepare wasm: "+Qt),Nu(Qt)})}function fe(){return!X&&typeof WebAssembly.instantiateStreaming=="function"&&!Vg(sn)&&!Tu(sn)&&typeof fetch=="function"?fetch(sn,{credentials:"same-origin"}).then(function(oe){var Qt=WebAssembly.instantiateStreaming(oe,H);return Qt.then(gt,function(xr){return D("wasm streaming compile failed: "+xr),D("falling back to ArrayBuffer instantiation"),$t(gt)})}):$t(gt)}if(e.instantiateWasm)try{var he=e.instantiateWasm(H,tt);return he}catch(oe){return D("Module.instantiateWasm callback failed with error: "+oe),!1}return fe().catch(o),{}}var KT,jT;function _d(H){for(;H.length>0;){var tt=H.shift();if(typeof tt=="function"){tt(e);continue}var gt=tt.func;typeof gt=="number"?tt.arg===void 0?Ed(gt)():Ed(gt)(tt.arg):gt(tt.arg===void 0?null:tt.arg)}}function _l(H){return H}function Gg(H){var tt=/\b_Z[\w\d_]+/g;return H.replace(tt,function(gt){var $t=gt;return gt===$t?gt:$t+" ["+gt+"]"})}var Wo=[];function Ed(H){var tt=Wo[H];return tt||(H>=Wo.length&&(Wo.length=H+1),Wo[H]=tt=so.get(H)),tt}function XT(){var H=new Error;if(!H.stack){try{throw new Error}catch(tt){H=tt}if(!H.stack)return"(no stack trace available)"}return H.stack.toString()}function pp(H,tt){so.set(H,tt),Wo[H]=tt}function n0(){Nu("")}function Ad(){return 2147483648}function Wg(H,tt,gt){ze.copyWithin(H,tt,tt+gt)}function an(H){try{return st.grow(H-Fe.byteLength+65535>>>16),Fn(st.buffer),1}catch(tt){}}function Ug(H){var tt=ze.length;H=H>>>0;var gt=Ad();if(H>gt)return!1;for(var $t=1;$t<=4;$t*=2){var fe=tt*(1+.2/$t);fe=Math.min(fe,H+100663296);var he=Math.min(gt,je(Math.max(H,fe),65536)),oe=an(he);if(oe)return!0}return!1}var mp={mappings:{},buffers:[null,[],[]],printChar:function(H,tt){var gt=mp.buffers[H];tt===0||tt===10?((H===1?$:D)(Dt(gt,0)),gt.length=0):gt.push(tt)},varargs:void 0,get:function(){mp.varargs+=4;var H=nn[mp.varargs-4>>2];return H},getStr:function(H){var tt=qt(H);return tt},get64:function(H,tt){return H}};function o0(H){return 0}function YT(H,tt,gt,$t,fe){}function ZT(H,tt,gt,$t){for(var fe=0,he=0;he<gt;he++){var oe=nn[tt>>2],Qt=nn[tt+4>>2];tt+=8;for(var xr=0;xr<Qt;xr++)mp.printChar(H,ze[oe+xr]);fe+=Qt}return nn[$t>>2]=fe,0}function s0(H){rt(H)}var Hg=!1,fp={abort:n0,emscripten_get_heap_max:Ad,emscripten_memcpy_big:Wg,emscripten_resize_heap:Ug,fd_close:o0,fd_seek:YT,fd_write:ZT,setTempRet0:s0},bW=r0(),JT=e.___wasm_call_ctors=function(){return(JT=e.___wasm_call_ctors=e.asm.__wasm_call_ctors).apply(null,arguments)},i0=e._init=function(){return(i0=e._init=e.asm.init).apply(null,arguments)},a0=e._init_with_threads_count=function(){return(a0=e._init_with_threads_count=e.asm.init_with_threads_count).apply(null,arguments)},qg=e._get_threads_count=function(){return(qg=e._get_threads_count=e.asm.get_threads_count).apply(null,arguments)},Kg=e._register_tensor=function(){return(Kg=e._register_tensor=e.asm.register_tensor).apply(null,arguments)},l0=e._dispose_data=function(){return(l0=e._dispose_data=e.asm.dispose_data).apply(null,arguments)},Ht=e._dispose=function(){return(Ht=e._dispose=e.asm.dispose).apply(null,arguments)},u0=e._Abs=function(){return(u0=e._Abs=e.asm.Abs).apply(null,arguments)},jg=e._Add=function(){return(jg=e._Add=e.asm.Add).apply(null,arguments)},_u=e._AddN=function(){return(_u=e._AddN=e.asm.AddN).apply(null,arguments)},dp=e._All=function(){return(dp=e._All=e.asm.All).apply(null,arguments)},c0=e._Any=function(){return(c0=e._Any=e.asm.Any).apply(null,arguments)},QT=e._ArgMax=function(){return(QT=e._ArgMax=e.asm.ArgMax).apply(null,arguments)},p0=e._AvgPool=function(){return(p0=e._AvgPool=e.asm.AvgPool).apply(null,arguments)},t1=e._BatchMatMul=function(){return(t1=e._BatchMatMul=e.asm.BatchMatMul).apply(null,arguments)},Eu=e._Ceil=function(){return(Eu=e._Ceil=e.asm.Ceil).apply(null,arguments)},m0=e._ClipByValue=function(){return(m0=e._ClipByValue=e.asm.ClipByValue).apply(null,arguments)},f0=e._Conv2D=function(){return(f0=e._Conv2D=e.asm.Conv2D).apply(null,arguments)},d0=e._Conv2DBackpropInput=function(){return(d0=e._Conv2DBackpropInput=e.asm.Conv2DBackpropInput).apply(null,arguments)},h0=e._Cos=function(){return(h0=e._Cos=e.asm.Cos).apply(null,arguments)},g0=e._Cosh=function(){return(g0=e._Cosh=e.asm.Cosh).apply(null,arguments)},x0=e._CropAndResize=function(){return(x0=e._CropAndResize=e.asm.CropAndResize).apply(null,arguments)},Xg=e._Cumprod=function(){return(Xg=e._Cumprod=e.asm.Cumprod).apply(null,arguments)},y0=e._Cumsum=function(){return(y0=e._Cumsum=e.asm.Cumsum).apply(null,arguments)},b0=e._DepthToSpace=function(){return(b0=e._DepthToSpace=e.asm.DepthToSpace).apply(null,arguments)},w0=e._DepthwiseConv2dNative=function(){return(w0=e._DepthwiseConv2dNative=e.asm.DepthwiseConv2dNative).apply(null,arguments)},v0=e._Elu=function(){return(v0=e._Elu=e.asm.Elu).apply(null,arguments)},C0=e._Equal=function(){return(C0=e._Equal=e.asm.Equal).apply(null,arguments)},Yg=e._Exp=function(){return(Yg=e._Exp=e.asm.Exp).apply(null,arguments)},I0=e._FlipLeftRight=function(){return(I0=e._FlipLeftRight=e.asm.FlipLeftRight).apply(null,arguments)},S0=e._Floor=function(){return(S0=e._Floor=e.asm.Floor).apply(null,arguments)},Au=e._FloorDiv=function(){return(Au=e._FloorDiv=e.asm.FloorDiv).apply(null,arguments)},$d=e._FusedBatchNorm=function(){return($d=e._FusedBatchNorm=e.asm.FusedBatchNorm).apply(null,arguments)},k0=e._FusedConv2D=function(){return(k0=e._FusedConv2D=e.asm.FusedConv2D).apply(null,arguments)},N0=e._FusedDepthwiseConv2D=function(){return(N0=e._FusedDepthwiseConv2D=e.asm.FusedDepthwiseConv2D).apply(null,arguments)},T0=e._Gather=function(){return(T0=e._Gather=e.asm.Gather).apply(null,arguments)},ee=e._GatherNd=function(){return(ee=e._GatherNd=e.asm.GatherNd).apply(null,arguments)},_0=e._Greater=function(){return(_0=e._Greater=e.asm.Greater).apply(null,arguments)},E0=e._GreaterEqual=function(){return(E0=e._GreaterEqual=e.asm.GreaterEqual).apply(null,arguments)},A0=e._LeakyRelu=function(){return(A0=e._LeakyRelu=e.asm.LeakyRelu).apply(null,arguments)},$0=e._Less=function(){return($0=e._Less=e.asm.Less).apply(null,arguments)},D0=e._LessEqual=function(){return(D0=e._LessEqual=e.asm.LessEqual).apply(null,arguments)},R0=e._Log=function(){return(R0=e._Log=e.asm.Log).apply(null,arguments)},Dd=e._LogicalAnd=function(){return(Dd=e._LogicalAnd=e.asm.LogicalAnd).apply(null,arguments)},Zg=e._Max=function(){return(Zg=e._Max=e.asm.Max).apply(null,arguments)},Jg=e._MaxPool=function(){return(Jg=e._MaxPool=e.asm.MaxPool).apply(null,arguments)},F0=e._Maximum=function(){return(F0=e._Maximum=e.asm.Maximum).apply(null,arguments)},O0=e._Mean=function(){return(O0=e._Mean=e.asm.Mean).apply(null,arguments)},M0=e._Min=function(){return(M0=e._Min=e.asm.Min).apply(null,arguments)},P0=e._Minimum=function(){return(P0=e._Minimum=e.asm.Minimum).apply(null,arguments)},L0=e._MirrorPad=function(){return(L0=e._MirrorPad=e.asm.MirrorPad).apply(null,arguments)},z0=e._Multiply=function(){return(z0=e._Multiply=e.asm.Multiply).apply(null,arguments)},or=e._Neg=function(){return(or=e._Neg=e.asm.Neg).apply(null,arguments)},B0=e._NonMaxSuppressionV3=function(){return(B0=e._NonMaxSuppressionV3=e.asm.NonMaxSuppressionV3).apply(null,arguments)},V0=e._NonMaxSuppressionV4=function(){return(V0=e._NonMaxSuppressionV4=e.asm.NonMaxSuppressionV4).apply(null,arguments)},G0=e._NonMaxSuppressionV5=function(){return(G0=e._NonMaxSuppressionV5=e.asm.NonMaxSuppressionV5).apply(null,arguments)},hp=e._NotEqual=function(){return(hp=e._NotEqual=e.asm.NotEqual).apply(null,arguments)},Qg=e._OneHot=function(){return(Qg=e._OneHot=e.asm.OneHot).apply(null,arguments)},tx=e._PadV2=function(){return(tx=e._PadV2=e.asm.PadV2).apply(null,arguments)},ex=e._Pow=function(){return(ex=e._Pow=e.asm.Pow).apply(null,arguments)},W0=e._Prelu=function(){return(W0=e._Prelu=e.asm.Prelu).apply(null,arguments)},rx=e._Prod=function(){return(rx=e._Prod=e.asm.Prod).apply(null,arguments)},U0=e._RealDiv=function(){return(U0=e._RealDiv=e.asm.RealDiv).apply(null,arguments)},e1=e._Relu=function(){return(e1=e._Relu=e.asm.Relu).apply(null,arguments)},nx=e._Relu6=function(){return(nx=e._Relu6=e.asm.Relu6).apply(null,arguments)},r1=e._ResizeBilinear=function(){return(r1=e._ResizeBilinear=e.asm.ResizeBilinear).apply(null,arguments)},H0=e._Reverse=function(){return(H0=e._Reverse=e.asm.Reverse).apply(null,arguments)},q0=e._RotateWithOffset=function(){return(q0=e._RotateWithOffset=e.asm.RotateWithOffset).apply(null,arguments)},K0=e._Round=function(){return(K0=e._Round=e.asm.Round).apply(null,arguments)},j0=e._Rsqrt=function(){return(j0=e._Rsqrt=e.asm.Rsqrt).apply(null,arguments)},X0=e._ScatterNd=function(){return(X0=e._ScatterNd=e.asm.ScatterNd).apply(null,arguments)},Y0=e._SelectV2=function(){return(Y0=e._SelectV2=e.asm.SelectV2).apply(null,arguments)},Z0=e._Sigmoid=function(){return(Z0=e._Sigmoid=e.asm.Sigmoid).apply(null,arguments)},J0=e._Sin=function(){return(J0=e._Sin=e.asm.Sin).apply(null,arguments)},Q0=e._Softmax=function(){return(Q0=e._Softmax=e.asm.Softmax).apply(null,arguments)},tC=e._SparseFillEmptyRows=function(){return(tC=e._SparseFillEmptyRows=e.asm.SparseFillEmptyRows).apply(null,arguments)},eC=e._SparseReshape=function(){return(eC=e._SparseReshape=e.asm.SparseReshape).apply(null,arguments)},rC=e._SparseSegmentReduction=function(){return(rC=e._SparseSegmentReduction=e.asm.SparseSegmentReduction).apply(null,arguments)},nC=e._Sqrt=function(){return(nC=e._Sqrt=e.asm.Sqrt).apply(null,arguments)},oC=e._Square=function(){return(oC=e._Square=e.asm.Square).apply(null,arguments)},sC=e._SquaredDifference=function(){return(sC=e._SquaredDifference=e.asm.SquaredDifference).apply(null,arguments)},iC=e._Step=function(){return(iC=e._Step=e.asm.Step).apply(null,arguments)},aC=e._StridedSlice=function(){return(aC=e._StridedSlice=e.asm.StridedSlice).apply(null,arguments)},lC=e._Sub=function(){return(lC=e._Sub=e.asm.Sub).apply(null,arguments)},uC=e._Sum=function(){return(uC=e._Sum=e.asm.Sum).apply(null,arguments)},cC=e._Tan=function(){return(cC=e._Tan=e.asm.Tan).apply(null,arguments)},pC=e._Tanh=function(){return(pC=e._Tanh=e.asm.Tanh).apply(null,arguments)},mC=e._Tile=function(){return(mC=e._Tile=e.asm.Tile).apply(null,arguments)},fC=e._TopK=function(){return(fC=e._TopK=e.asm.TopK).apply(null,arguments)},dC=e._Transform=function(){return(dC=e._Transform=e.asm.Transform).apply(null,arguments)},hC=e._Transpose=function(){return(hC=e._Transpose=e.asm.Transpose).apply(null,arguments)},gC=e.__FusedMatMul=function(){return(gC=e.__FusedMatMul=e.asm._FusedMatMul).apply(null,arguments)},xC=e._malloc=function(){return(xC=e._malloc=e.asm.malloc).apply(null,arguments)},yC=e._free=function(){return(yC=e._free=e.asm.free).apply(null,arguments)},bC=e.___errno_location=function(){return(bC=e.___errno_location=e.asm.__errno_location).apply(null,arguments)},wC=e._emscripten_main_thread_process_queued_calls=function(){return(wC=e._emscripten_main_thread_process_queued_calls=e.asm.emscripten_main_thread_process_queued_calls).apply(null,arguments)},ox=e.stackSave=function(){return(ox=e.stackSave=e.asm.stackSave).apply(null,arguments)},sx=e.stackRestore=function(){return(sx=e.stackRestore=e.asm.stackRestore).apply(null,arguments)},Rd=e.stackAlloc=function(){return(Rd=e.stackAlloc=e.asm.stackAlloc).apply(null,arguments)},vC=e.dynCall_iijjiiii=function(){return(vC=e.dynCall_iijjiiii=e.asm.dynCall_iijjiiii).apply(null,arguments)},CC=e.dynCall_jiji=function(){return(CC=e.dynCall_jiji=e.asm.dynCall_jiji).apply(null,arguments)};e.cwrap=bt;var gp;function Fd(H){this.name="ExitStatus",this.message="Program terminated with exit("+H+")",this.status=H}Tl=function H(){gp||Od(),gp||(Tl=H)};function Od(H){if(H=H||a,qn>0||(Og(),qn>0))return;function tt(){gp||(gp=!0,e.calledRun=!0,!it&&(Mg(),n(e),e.onRuntimeInitialized&&e.onRuntimeInitialized(),Pg()))}e.setStatus?(e.setStatus("Running..."),setTimeout(function(){setTimeout(function(){e.setStatus("")},1),tt()},1)):tt()}e.run=Od;function n1(H){ft=H,Nd()||(e.onExit&&e.onExit(H),it=!0),l(H,new Fd(H))}if(e.preInit)for(typeof e.preInit=="function"&&(e.preInit=[e.preInit]);e.preInit.length>0;)e.preInit.pop()();Od();var xp;s&&(xp={uncaughtException:process.listeners("uncaughtException").filter(function(H){return!s.uncaughtException.indexOf(H)>-1}),unhandledRejection:process.listeners("unhandledRejection").filter(function(H){return!s.unhandledRejection.indexOf(H)>-1})});var yp;if(typeof t!="undefined")yp=t;else if(typeof WasmBackendModuleThreadedSimd!="undefined")yp=WasmBackendModuleThreadedSimd;else throw new Error("Could not find wasm module in post.js");if(xp){var IC=yp._dispose;yp._dispose=function(){IC(),xp.uncaughtException.forEach(function(H){process.removeListener("uncaughtException",H)}),xp.unhandledRejection.forEach(function(H){process.removeListener("unhandledRejection",H)})}}return t.ready}})();typeof Zv=="object"&&typeof GT=="object"?GT.exports=VT:typeof define=="function"&&define.amd?define([],function(){return VT}):typeof Zv=="object"&&(Zv.WasmBackendModule=VT)});var Ji=class{constructor(t,e){this.backend=t,this.dataMover=e,this.data=new WeakMap,this.dataIdsCount=0}get(t){return this.data.has(t)||this.dataMover.moveData(this.backend,t),this.data.get(t)}set(t,e){this.dataIdsCount++,this.data.set(t,e)}has(t){return this.data.has(t)}delete(t){return this.dataIdsCount--,this.data.delete(t)}numDataIds(){return this.dataIdsCount}},jo=class{refCount(t){return Kn("refCount")}incRef(t){return Kn("incRef")}timerAvailable(){return!0}time(t){return Kn("time")}read(t){return Kn("read")}readSync(t){return Kn("readSync")}readToGPU(t,e){return Kn("readToGPU")}numDataIds(){return Kn("numDataIds")}disposeData(t,e){return Kn("disposeData")}write(t,e,n){return Kn("write")}move(t,e,n,o,s){return Kn("move")}memory(){return Kn("memory")}floatPrecision(){return Kn("floatPrecision")}epsilon(){return this.floatPrecision()===32?1e-7:1e-4}dispose(){return Kn("dispose")}};function Kn(r){throw new Error(`'${r}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function f1(r){let t=r.length,e=0;for(;t>0;)e=Math.random()*t|0,t--,fx(r,t,e)}function yU(r,t){if(r.length!==t.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${r.length}Second array length was ${t.length}`);let e=r.length,n=0;for(;e>0;)n=Math.random()*e|0,e--,fx(r,e,n),fx(t,e,n)}function Cp(r,t,e){return Math.max(r,Math.min(t,e))}function bU(r){return r%2===0?r:r+1}function fx(r,t,e){let n=r[t];r[t]=r[e],r[e]=n}function wU(r){let t=0;for(let e=0;e<r.length;e++)t+=r[e];return t}function vU(r,t){let e=Math.random();return t*e+(1-e)*r}function CU(r,t){let e=0;for(let n=0;n<r.length;n++){let o=Number(r[n])-Number(t[n]);e+=o*o}return e}function A(r,t){if(!r)throw new Error(typeof t=="string"?t:t())}function Me(r,t,e=""){A(Mn(r,t),()=>e+` Shapes ${r} and ${t} must match`)}function jn(r){A(r!=null,()=>"The input to the tensor constructor must be a non-null value.")}function Xo(r,t=[],e=!1){if(t==null&&(t=[]),Array.isArray(r)||yr(r)&&!e)for(let n=0;n<r.length;++n)Xo(r[n],t,e);else t.push(r);return t}function re(r){if(r.length===0)return 1;let t=r[0];for(let e=1;e<r.length;e++)t*=r[e];return t}function IU(r){return r.length===0}function Mn(r,t){if(r===t)return!0;if(r==null||t==null||r.length!==t.length)return!1;for(let e=0;e<r.length;e++)if(r[e]!==t[e])return!1;return!0}function Qi(r){return r%1===0}function SU(r){if(Math.tanh!=null)return Math.tanh(r);if(r===1/0)return 1;if(r===-1/0)return-1;{let t=Math.exp(2*r);return(t-1)/(t+1)}}function kU(r){let t=Math.ceil(Math.sqrt(r));return[t,Math.ceil(r/t)]}function NU(r){let t=new Uint32Array(r);for(let e=0;e<r;++e)t[e]=e;return f1(t),t}function Fu(r,t){return t<=r.length?r:r+" ".repeat(t-r.length)}function TU(r,t=n=>0,e){return new Promise((n,o)=>{let s=0,i=()=>{if(r()){n();return}s++;let a=t(s);if(e!=null&&s>=e){o();return}setTimeout(i,a)};i()})}function _U(r,t){let e=1,n=-1;for(let s=0;s<r.length;++s)if(r[s]>=0)e*=r[s];else if(r[s]===-1){if(n!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${n} and dim ${s}`);n=s}else if(r[s]<0)throw Error(`Shapes can not be < 0. Found ${r[s]} at dim ${s}`);if(n===-1){if(t>0&&t!==e)throw Error(`Size(${t}) must match the product of shape ${r}`);return r}if(e===0)throw Error(`Cannot infer the missing size in [${r}] when there are 0 elements`);if(t%e!==0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${e}`);let o=r.slice();return o[n]=t/e,o}function mr(r,t){let e=t.length;return r=r==null?t.map((n,o)=>o):[].concat(r),A(r.every(n=>n>=-e&&n<e),()=>`All values in axis param must be in range [-${e}, ${e}) but got axis ${r}`),A(r.every(n=>Qi(n)),()=>`All values in axis param must be integers but got axis ${r}`),r.map(n=>n<0?e+n:n)}function $C(r,t){let e=[],n=[],o=t!=null&&Array.isArray(t)&&t.length===0,s=t==null||o?null:mr(t,r).sort(),i=0;for(let a=0;a<r.length;++a){if(s!=null){if(s[i]===a&&r[a]!==1)throw new Error(`Can't squeeze axis ${a} since its dim '${r[a]}' is not 1`);(s[i]==null||s[i]>a)&&r[a]===1&&(e.push(r[a]),n.push(a)),s[i]<=a&&i++}r[a]!==1&&(e.push(r[a]),n.push(a))}return{newShape:e,keptDims:n}}function DC(r,t){let e=null;if(r==null||r==="float32")e=new Float32Array(t);else if(r==="int32")e=new Int32Array(t);else if(r==="bool")e=new Uint8Array(t);else throw new Error(`Unknown data type ${r}`);return e}function RC(r,t){let e=null;if(r==null||r==="float32")e=new Float32Array(t);else if(r==="int32")e=new Int32Array(t);else if(r==="bool")e=new Uint8Array(t);else if(r==="string")e=new Array(t);else throw new Error(`Unknown data type ${r}`);return e}function FC(r,t){for(let e=0;e<r.length;e++){let n=r[e];if(isNaN(n)||!isFinite(n))throw Error(`A tensor of type ${t} being uploaded contains ${n}.`)}}function OC(r){return r==="bool"||r==="complex64"||r==="float32"||r==="int32"||r==="string"}function EU(r,t){return!(t==="complex64"||t==="float32"&&r!=="complex64"||t==="int32"&&r!=="float32"&&r!=="complex64"||t==="bool"&&r==="bool")}function yr(r){return r instanceof Float32Array||r instanceof Int32Array||r instanceof Uint8Array||r instanceof Uint8ClampedArray}function dx(r){if(r==="float32"||r==="int32")return 4;if(r==="complex64")return 8;if(r==="bool")return 1;throw new Error(`Unknown dtype ${r}`)}function MC(r){if(r==null)return 0;let t=0;return r.forEach(e=>t+=e.length),t}function Yo(r){return typeof r=="string"||r instanceof String}function d1(r){return typeof r=="boolean"}function h1(r){return typeof r=="number"}function Ip(r){return Array.isArray(r)?Ip(r[0]):r instanceof Float32Array?"float32":r instanceof Int32Array||r instanceof Uint8Array||r instanceof Uint8ClampedArray?"int32":h1(r)?"float32":Yo(r)?"string":d1(r)?"bool":"float32"}function xi(r){return!!(r&&r.constructor&&r.call&&r.apply)}function Sp(r,t){for(let e=t;e<r;++e)if(r%e===0)return e;return r}function yi(r){let t=r.length;if(t<2)return[];let e=new Array(t-1);e[t-2]=r[t-1];for(let n=t-3;n>=0;--n)e[n]=e[n+1]*r[n+1];return e}function g1(r,t,e,n=!1){let o=new Array;if(t.length===1){let s=t[0]*(n?2:1);for(let i=0;i<s;i++)o[i]=e[r+i]}else{let s=t[0],i=t.slice(1),a=i.reduce((u,l)=>u*l)*(n?2:1);for(let u=0;u<s;u++)o[u]=g1(r+u*a,i,e,n)}return o}function Ru(r,t,e=!1){if(r.length===0)return t[0];let n=r.reduce((o,s)=>o*s)*(e?2:1);if(n===0)return[];if(n!==t.length)throw new Error(`[${r}] does not match the input size ${t.length}${e?" for a complex tensor":""}.`);return g1(0,r,t,e)}function Ld(r,t){let e=kp(r,t);for(let n=0;n<e.length;n++)e[n]=1;return e}function kp(r,t){if(t==null||t==="float32"||t==="complex64")return new Float32Array(r);if(t==="int32")return new Int32Array(r);if(t==="bool")return new Uint8Array(r);throw new Error(`Unknown data type ${t}`)}function AU(r,t){let e=r.reduce((n,o)=>n*o,1);if(t==null||t==="float32")return Ru(r,new Float32Array(e));if(t==="int32")return Ru(r,new Int32Array(e));if(t==="bool")return Ru(r,new Uint8Array(e));throw new Error(`Unknown data type ${t}`)}function zd(r){r.forEach(t=>{A(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${r}].`)})}function $U(r,t,e){if(t===0)return 0;if(t===1)return r[0];let n=r[r.length-1];for(let o=0;o<r.length-1;++o)n+=e[o]*r[o];return n}function DU(r,t,e){if(t===0)return[];if(t===1)return[r];let n=new Array(t);for(let o=0;o<n.length-1;++o)n[o]=Math.floor(r/e[o]),r-=n[o]*e[o];return n[n.length-1]=r,n}function Bd(r){return r&&r.then&&typeof r.then=="function"}var x1="tfjsflags",Vd=class{constructor(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=FU,this.populateURLFlags()}setPlatform(t,e){this.platform!=null&&(V().getBool("IS_TEST")||V().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${t}.`)),this.platformName=t,this.platform=e}registerFlag(t,e,n){if(this.flagRegistry[t]={evaluationFn:e,setHook:n},this.urlFlags[t]!=null){let o=this.urlFlags[t];V().getBool("IS_TEST")||V().getBool("PROD")||console.warn(`Setting feature override from URL ${t}: ${o}.`),this.set(t,o)}}async getAsync(t){return t in this.flags?this.flags[t]:(this.flags[t]=await this.evaluateFlag(t),this.flags[t])}get(t){if(t in this.flags)return this.flags[t];let e=this.evaluateFlag(t);if(Bd(e))throw new Error(`Flag ${t} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[t]=e,this.flags[t]}getNumber(t){return this.get(t)}getBool(t){return this.get(t)}getFlags(){return this.flags}get features(){return this.flags}set(t,e){if(this.flagRegistry[t]==null)throw new Error(`Cannot set flag ${t} as it has not been registered.`);this.flags[t]=e,this.flagRegistry[t].setHook!=null&&this.flagRegistry[t].setHook(e)}evaluateFlag(t){if(this.flagRegistry[t]==null)throw new Error(`Cannot evaluate flag '${t}': no evaluation function found.`);return this.flagRegistry[t].evaluationFn()}setFlags(t){this.flags=Object.assign({},t)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global=="undefined"||typeof this.global.location=="undefined"||typeof this.global.location.search=="undefined")return;let t=this.getQueryParams(this.global.location.search);x1 in t&&t[x1].split(",").forEach(n=>{let[o,s]=n.split(":");this.urlFlags[o]=MU(o,s)})}};function FU(r){let t={};return r.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(e,...n)=>(OU(t,n[0],n[1]),n.join("="))),t}function OU(r,t,e){r[decodeURIComponent(t)]=decodeURIComponent(e||"")}function MU(r,t){if(t=t.toLowerCase(),t==="true"||t==="false")return t==="true";if(`${+t}`===t)return+t;throw new Error(`Could not parse value flag value ${t} for flag ${r}.`)}function V(){return PC}var PC=null;function y1(r){PC=r}var LC;function zC(){if(LC==null){let r;if(typeof window!="undefined")r=window;else if(typeof global!="undefined")r=global;else if(typeof process!="undefined")r=process;else if(typeof self!="undefined")r=self;else throw new Error("Could not find a global object");LC=r}return LC}function PU(){let r=zC();return r._tfGlobals==null&&(r._tfGlobals=new Map),r._tfGlobals}function Gd(r,t){let e=PU();if(e.has(r))return e.get(r);{let n=t();return e.set(r,n),e.get(r)}}var bi="Abs",ta="Acos",ea="Acosh",Xn="Add",Zo="AddN",ra="All",na="Any",Jo="ArgMax",Al="ArgMin",oa="Asin",sa="Asinh",ia="Atan",aa="Atanh",la="Atan2",Qo="AvgPool",Np="AvgPoolGrad",$l="AvgPool3D",Tp="AvgPool3DGrad",ts="BatchMatMul",wi="BatchToSpaceND",_p="Bincount",b1="BroadcastTo",Ep="BroadcastArgs",io="Cast",es="Ceil",ao="ClipByValue",Ap="Complex",Dl="ComplexAbs",vi="Concat",rs="Conv2D",$p="Conv2DBackpropFilter",ns="Conv2DBackpropInput",Rl="Conv3D",Dp="Conv3DBackpropFilterV2",Rp="Conv3DBackpropInputV2",os="Cos",ss="Cosh",ua="Cumprod",is="Cumsum",ca="CropAndResize",Fp="DenseBincount",pa="DepthToSpace",as="DepthwiseConv2dNative",Op="DepthwiseConv2dNativeBackpropFilter",Mp="DepthwiseConv2dNativeBackpropInput",Pp="Diag",Fl="Dilation2D",Wd="Dilation2DBackpropInput",Ud="Dilation2DBackpropFilter",ls="RealDiv",Lp="Einsum",us="Elu",zp="EluGrad",ma="Erf",fa="Equal",cs="Exp",Ci="ExpandDims",da="Expm1",Bp="FFT",Ol="Fill",ha="FlipLeftRight",ps="Floor",ms="FloorDiv",fs="FusedBatchNorm",Ii="GatherV2",ga="GatherNd",xa="Greater",ds="GreaterEqual",lo="Identity",Vp="IFFT",Gp="Imag",ya="IsFinite",ba="IsInf",wa="IsNan",hs="LeakyRelu",va="Less",Ca="LessEqual",Wp="LinSpace",gs="Log",Ia="Log1p",Sa="LogicalAnd",Ou="LogicalNot",Mu="LogicalOr",w1="LogSoftmax",Ml="LRN",Up="LRNGrad",xs="Max",ys="Maximum",bs="MaxPool",Hp="MaxPoolGrad",Pl="MaxPool3D",qp="MaxPool3DGrad",Kp="MaxPoolWithArgmax",ws="Mean",vs="Min",Cs="Minimum",Is="MirrorPad",ka="Mod",jp="Multinomial",Ss="Multiply",Si="Neg",Na="NotEqual",Ta="NonMaxSuppressionV3",_a="NonMaxSuppressionV4",Ea="NonMaxSuppressionV5",ki="OnesLike",ks="OneHot",Ni="Pack",Ns="PadV2",Cat="Pool",Ts="Pow",_s="Prelu",Aa="Prod",Ll="Range",Xp="Real",$a="Reciprocal",Es="Relu",Ti="Reshape",zl="ResizeNearestNeighbor",Yp="ResizeNearestNeighborGrad",As="ResizeBilinear",Zp="ResizeBilinearGrad",$s="Relu6",Ds="Reverse",Rs="Round",Fs="Rsqrt",Da="ScatterNd",_i="Select",Ra="Selu",Ei="Slice",Os="Sin",Fa="Sinh",Oa="Sign",Ms="Sigmoid",Ma="Softplus",Ps="Sqrt",Ls="Sum",Ai="SpaceToBatchND",$i="SplitV",zs="Softmax",Bl="SparseFillEmptyRows",Pa="SparseReshape",Vl="SparseSegmentMean",Gl="SparseSegmentSum",Jp="SparseToDense",Bs="SquaredDifference",Wl="Square",La="StridedSlice",Qp="StringNGrams",tm="StringSplit",em="StringToHashBucketFast",Vs="Sub",Gs="Tan",Ws="Tanh",Yn="Tile",za="TopK",Ba="Transform",Us="Transpose",rm="Unique",Di="Unpack",Ul="UnsortedSegmentSum",Ri="ZerosLike",uo="Step",Hd="FromPixels",Va="RotateWithOffset",Fi="_FusedMatMul",Oi="FusedConv2D",Mi="FusedDepthwiseConv2D";function Pi(...r){V().getBool("IS_TEST")||V().getBool("PROD")||console.warn(...r)}function LU(...r){V().getBool("IS_TEST")||V().getBool("PROD")||console.log(...r)}var nm=Gd("kernelRegistry",()=>new Map),qd=Gd("gradRegistry",()=>new Map);function Kd(r,t){let e=VC(r,t);return nm.get(e)}function BC(r){return qd.get(r)}function hx(r){let t=nm.entries(),e=[];for(;;){let{done:n,value:o}=t.next();if(n)break;let[s,i]=o,[a]=s.split("_");a===r&&e.push(i)}return e}function Pu(r){let{kernelName:t,backendName:e}=r,n=VC(t,e);nm.has(n)&&Pi(`The kernel '${t}' for backend '${e}' is already registered`),nm.set(n,r)}function C1(r){let{kernelName:t}=r;qd.has(t)&&V().getBool("DEBUG")&&Pi(`Overriding the gradient for '${t}'`),qd.set(t,r)}function Tat(r,t){let e=VC(r,t);if(!nm.has(e))throw new Error(`The kernel '${r}' for backend '${t}' is not registered`);nm.delete(e)}function _at(r){if(!qd.has(r))throw new Error(`The gradient '${r}' for backend is not registered`);qd.delete(r)}function Eat(r,t){hx(r).forEach(n=>{let o=Object.assign({},n,{backendName:t});Pu(o)})}function VC(r,t){return`${t}_${r}`}var x={};Yt(x,{arraysEqual:()=>Mn,assert:()=>A,assertNonNegativeIntegerDimensions:()=>zd,assertNonNull:()=>jn,assertShapesMatch:()=>Me,bytesFromStringArray:()=>MC,bytesPerElement:()=>dx,checkConversionForErrors:()=>FC,clamp:()=>Cp,computeStrides:()=>yi,createScalarValue:()=>HU,createShuffledIndices:()=>NU,decodeString:()=>am,distSquared:()=>CU,encodeString:()=>ql,fetch:()=>KU,fingerPrint64:()=>UU,flatten:()=>Xo,getArrayFromDType:()=>RC,getTypedArrayFromDType:()=>DC,hasEncodingLoss:()=>EU,hexToLong:()=>jd,indexToLoc:()=>DU,inferDtype:()=>Ip,inferFromImplicitShape:()=>_U,isBoolean:()=>d1,isFunction:()=>xi,isInt:()=>Qi,isNumber:()=>h1,isPromise:()=>Bd,isScalarShape:()=>IU,isString:()=>Yo,isTypedArray:()=>yr,isValidDtype:()=>OC,locToIndex:()=>$U,makeOnesTypedArray:()=>Ld,makeZerosNestedTypedArray:()=>AU,makeZerosTypedArray:()=>kp,nearestDivisor:()=>Sp,nearestLargerEven:()=>bU,now:()=>Gu,parseAxisParam:()=>mr,randUniform:()=>vU,repeatedTry:()=>TU,rightPad:()=>Fu,shuffle:()=>f1,shuffleCombo:()=>yU,sizeFromShape:()=>re,sizeToSquarishShape:()=>kU,squeezeShape:()=>$C,sum:()=>wU,swap:()=>fx,tanh:()=>SU,toNestedArray:()=>Ru,toTypedArray:()=>im});var HC=Du(R1());var Vu=HC.default||HC;function jd(r){return Vu.fromString(r,!0,16)}var O1=jd("c3a5c85c97cb3127"),Bu=jd("b492b66fbe98f273"),un=jd("9ae16a3b2f90404f");function UC(r){return r.xor(r.shru(47))}function M1(r,t,e){let n=r.slice(t,t+e);return Vu.fromBytes(Array.from(n),!0,!0)}function Be(r,t){return M1(r,t,8)}function F1(r,t){return M1(r,t,4)}function Er(r,t){return t===0?r:r.shru(t).or(r.shl(64-t))}function Hl(r,t,e=jd("9ddfea08eb382d69")){let n=r.xor(t).mul(e);n=n.xor(n.shru(47));let o=t.xor(n).mul(e);return o=o.xor(o.shru(47)),o=o.mul(e),o}function BU(r,t,e,n,o,s){o=o.add(r),s=Er(s.add(o).add(n),21);let i=o;return o=o.add(t),o=o.add(e),s=s.add(Er(o,44)),[o.add(n),s.add(i)]}function xx(r,t,e,n){return BU(Be(r,t),Be(r,t+8),Be(r,t+16),Be(r,t+24),e,n)}function VU(r,t=r.length){if(t>=8){let e=un.add(t*2),n=Be(r,0).add(un),o=Be(r,t-8),s=Er(o,37).mul(e).add(n),i=Er(n,25).add(o).mul(e);return Hl(s,i,e)}if(t>=4){let e=un.add(t*2),n=F1(r,0);return Hl(n.shl(3).add(t),F1(r,t-4),e)}if(t>0){let e=r[0],n=r[t>>1],o=r[t-1],s=e+(n<<8),i=t+(o<<2);return UC(un.mul(s).xor(O1.mul(i))).mul(un)}return un}function GU(r,t=r.length){let e=un.add(t*2),n=Be(r,0).mul(Bu),o=Be(r,8),s=Be(r,t-8).mul(e),i=Be(r,t-16).mul(un);return Hl(Er(n.add(o),43).add(Er(s,30)).add(i),n.add(Er(o.add(un),18)).add(s),e)}function WU(r,t=r.length){let e=un.add(t*2),n=Be(r,0).mul(un),o=Be(r,8),s=Be(r,t-8).mul(e),i=Be(r,t-16).mul(un),a=Er(n.add(o),43).add(Er(s,30)).add(i),u=Hl(a,n.add(Er(o.add(un),18)).add(s),e),l=Be(r,16).mul(e),c=Be(r,24),p=a.add(Be(r,t-32)).mul(e),m=u.add(Be(r,t-24)).mul(e);return Hl(Er(l.add(c),43).add(Er(p,30)).add(m),l.add(Er(c.add(n),18)).add(p),e)}function UU(r,t=r.length){let e=Vu.fromNumber(81,!0);if(t<=32)return t<=16?VU(r,t):GU(r,t);if(t<=64)return WU(r,t);let n=e,o=e.mul(Bu).add(113),s=UC(o.mul(un).add(113)).mul(un),i=[Vu.UZERO,Vu.UZERO],a=[Vu.UZERO,Vu.UZERO];n=n.mul(un).add(Be(r,0));let u=0,l=(t-1>>6)*64,c=l+(t-1&63)-63;do n=Er(n.add(o).add(i[0]).add(Be(r,u+8)),37).mul(Bu),o=Er(o.add(i[1]).add(Be(r,u+48)),42).mul(Bu),n=n.xor(a[1]),o=o.add(i[0]).add(Be(r,u+40)),s=Er(s.add(a[0]),33).mul(Bu),i=xx(r,u,i[1].mul(Bu),n.add(a[0])),a=xx(r,u+32,s.add(a[1]),o.add(Be(r,u+16))),[s,n]=[n,s],u+=64;while(u!==l);let p=Bu.add(s.and(255).shl(1));return u=c,a[0]=a[0].add(t-1&63),i[0]=i[0].add(a[0]),a[0]=a[0].add(i[0]),n=Er(n.add(o).add(i[0]).add(Be(r,u+8)),37).mul(p),o=Er(o.add(i[1]).add(Be(r,u+48)),42).mul(p),n=n.xor(a[1].mul(9)),o=o.add(i[0].mul(9).add(Be(r,u+40))),s=Er(s.add(a[0]),33).mul(p),i=xx(r,u,i[1].mul(p),n.add(a[0])),a=xx(r,u+32,s.add(a[1]),o.add(Be(r,u+16))),[s,n]=[n,s],Hl(Hl(i[0],a[0],p).add(UC(o).mul(O1)).add(s),Hl(i[1],a[1],p).add(n),p)}function HU(r,t){return t==="string"?ql(r):im([r],t)}function qU(r,t){return r instanceof Float32Array&&t==="float32"||r instanceof Int32Array&&t==="int32"||r instanceof Uint8Array&&t==="bool"}function im(r,t){if(t==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(r)&&(r=Xo(r)),V().getBool("DEBUG")&&FC(r,t),qU(r,t))return r;if(t==null||t==="float32"||t==="complex64")return new Float32Array(r);if(t==="int32")return new Int32Array(r);if(t==="bool"){let e=new Uint8Array(r.length);for(let n=0;n<e.length;++n)Math.round(r[n])!==0&&(e[n]=1);return e}else throw new Error(`Unknown data type ${t}`)}function Gu(){return V().platform.now()}function KU(r,t){return V().platform.fetch(r,t)}function ql(r,t="utf-8"){return t=t||"utf-8",V().platform.encode(r,t)}function am(r,t="utf-8"){return t=t||"utf-8",V().platform.decode(r,t)}var yx=class{constructor(t,e){this.backendTimer=t,this.logger=e,e==null&&(this.logger=new qC)}profileKernel(t,e,n){let o,s=()=>{o=n()},i,a=Gu();if(this.backendTimer.timerAvailable())i=this.backendTimer.time(s);else{s();for(let l of o)l.dataSync();i=Promise.resolve({kernelMs:Gu()-a})}if(V().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let l=0;l<o.length;l++){let c=o[l];c.data().then(p=>{jU(p,c.dtype,t)})}return{kernelName:t,outputs:o,inputs:e,timeMs:i.then(l=>l.kernelMs),extraInfo:i.then(l=>l.getExtraProfileInfo!=null?l.getExtraProfileInfo():"")}}logKernelProfile(t){let{kernelName:e,outputs:n,timeMs:o,inputs:s,extraInfo:i}=t;n.forEach(a=>{Promise.all([a.data(),o,i]).then(u=>{this.logger.logKernelProfile(e,a,u[0],u[1],s,u[2])})})}};function jU(r,t,e){if(t!=="float32")return!1;for(let n=0;n<r.length;n++){let o=r[n];if(isNaN(o)||!isFinite(o))return console.warn(`Found ${o} in the result of '${e}'`),!0}return!1}var qC=class{logKernelProfile(t,e,n,o,s,i){let a=typeof o=="number"?Fu(`${o}ms`,9):o.error,u=Fu(t,25),l=e.rank,c=e.size,p=Fu(e.shape.toString(),14),m="";for(let f in s){let d=s[f];if(d!=null){let h=d.shape||e.shape,g=h.length;m+=`${f}: ${g}D ${g>0?h:""} `}}console.log(`%c${u}	%c${a}	%c${l}D ${p}	%c${c}	%c${m}	%c${i}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}};function P1(r,t,e){let n={},o={};for(let u=0;u<t.length;u++)n[t[u].id]=!0;for(let u=0;u<r.length;u++){let l=r[u],c=l.inputs;for(let p in c){let m=c[p],f=!1;for(let d=0;d<t.length;d++)if(n[m.id]){l.outputs.forEach(h=>n[h.id]=!0),f=!0,o[l.id]=!0;break}if(f)break}}let s={};s[e.id]=!0;let i={};for(let u=r.length-1;u>=0;u--){let l=r[u],c=l.inputs;for(let p=0;p<l.outputs.length;p++)if(s[l.outputs[p].id]){for(let m in c)s[c[m].id]=!0,i[l.id]=!0;break}}let a=[];for(let u=0;u<r.length;u++){let l=r[u];if(o[l.id]&&i[l.id]){let c={};for(let m in l.inputs){let f=l.inputs[m];n[f.id]&&(c[m]=f)}let p=Object.assign({},l);p.inputs=c,p.outputs=l.outputs,a.push(p)}}return a}function L1(r,t,e,n){for(let o=t.length-1;o>=0;o--){let s=t[o],i=[];if(s.outputs.forEach(u=>{let l=r[u.id];l!=null?i.push(l):i.push(null)}),s.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${s.kernelName}.`);let a=s.gradient(i);for(let u in s.inputs){if(!(u in a))throw new Error(`Cannot backprop through input ${u}. Available gradients found: ${Object.keys(a)}.`);let l=e(()=>a[u]());if(l.dtype!=="float32")throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input ${u} must have 'float32' dtype, but has '${l.dtype}'`);let c=s.inputs[u];if(!Mn(l.shape,c.shape))throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input '${u}' has shape '${l.shape}', which does not match the shape of the input '${c.shape}'`);if(r[c.id]==null)r[c.id]=l;else{let p=r[c.id];r[c.id]=n(p,l),p.dispose()}}}}var z1=20,Xd=3,KC=7;function B1(r,t,e,n){let o=yi(t),s=XU(r,t,e,o),i=t.length,a=bx(r,t,e,o,s),u=["Tensor"];return n&&(u.push(`  dtype: ${e}`),u.push(`  rank: ${i}`),u.push(`  shape: [${t}]`),u.push("  values:")),u.push(a.map(l=>"    "+l).join(`
`)),u.join(`
`)}function XU(r,t,e,n){let o=re(t),s=n[n.length-1],i=new Array(s).fill(0),a=t.length,u=e==="complex64"?Zd(r):r;if(a>1)for(let l=0;l<o/s;l++){let c=l*s;for(let p=0;p<s;p++)i[p]=Math.max(i[p],Yd(u[c+p],0,e).length)}return i}function Yd(r,t,e){let n;return Array.isArray(r)?n=`${parseFloat(r[0].toFixed(KC))} + ${parseFloat(r[1].toFixed(KC))}j`:Yo(r)?n=`'${r}'`:e==="bool"?n=V1(r):n=parseFloat(r.toFixed(KC)).toString(),Fu(n,t)}function V1(r){return r===0?"false":"true"}function bx(r,t,e,n,o,s=!0){let i=e==="complex64"?2:1,a=t[0],u=t.length;if(u===0){if(e==="complex64"){let h=Zd(r);return[Yd(h[0],0,e)]}return e==="bool"?[V1(r[0])]:[r[0].toString()]}if(u===1){if(a>z1){let g=Xd*i,y=Array.from(r.slice(0,g)),b=Array.from(r.slice((a-Xd)*i,a*i));return e==="complex64"&&(y=Zd(y),b=Zd(b)),["["+y.map((w,v)=>Yd(w,o[v],e)).join(", ")+", ..., "+b.map((w,v)=>Yd(w,o[a-Xd+v],e)).join(", ")+"]"]}let h=e==="complex64"?Zd(r):Array.from(r);return["["+h.map((g,y)=>Yd(g,o[y],e)).join(", ")+"]"]}let l=t.slice(1),c=n.slice(1),p=n[0]*i,m=[];if(a>z1){for(let h=0;h<Xd;h++){let g=h*p,y=g+p;m.push(...bx(r.slice(g,y),l,e,c,o,!1))}m.push("...");for(let h=a-Xd;h<a;h++){let g=h*p,y=g+p;m.push(...bx(r.slice(g,y),l,e,c,o,h===a-1))}}else for(let h=0;h<a;h++){let g=h*p,y=g+p;m.push(...bx(r.slice(g,y),l,e,c,o,h===a-1))}let f=u===2?",":"";m[0]="["+m[0]+f;for(let h=1;h<m.length-1;h++)m[h]=" "+m[h]+f;let d=`,
`;for(let h=2;h<u;h++)d+=`
`;return m[m.length-1]=" "+m[m.length-1]+"]"+(s?"":d),m}function Zd(r){let t=[];for(let e=0;e<r.length;e+=2)t.push([r[e],r[e+1]]);return t}var pe=class{constructor(t,e,n){if(this.dtype=e,this.shape=t.slice(),this.size=re(t),n!=null){let o=n.length;A(o===this.size,()=>`Length of values '${o}' does not match the size inferred by the shape '${this.size}'.`)}if(e==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||RC(e,this.size),this.strides=yi(t)}set(t,...e){e.length===0&&(e=[0]),A(e.length===this.rank,()=>`The number of provided coordinates (${e.length}) must match the rank (${this.rank})`);let n=this.locToIndex(e);this.values[n]=t}get(...t){t.length===0&&(t=[0]);let e=0;for(let o of t){if(o<0||o>=this.shape[e]){let s=`Requested out of range element at ${t}.   Buffer shape=${this.shape}`;throw new Error(s)}e++}let n=t[t.length-1];for(let o=0;o<t.length-1;++o)n+=this.strides[o]*t[o];return this.values[n]}locToIndex(t){if(this.rank===0)return 0;if(this.rank===1)return t[0];let e=t[t.length-1];for(let n=0;n<t.length-1;++n)e+=this.strides[n]*t[n];return e}indexToLoc(t){if(this.rank===0)return[];if(this.rank===1)return[t];let e=new Array(this.shape.length);for(let n=0;n<e.length-1;++n)e[n]=Math.floor(t/this.strides[n]),t-=e[n]*this.strides[n];return e[e.length-1]=t,e}get rank(){return this.shape.length}toTensor(){return qs().makeTensor(this.values,this.shape,this.dtype)}},qs=null,lm=null,YU=null;function G1(r){qs=r}function W1(r){lm=r}function U1(r){YU=r}var Pt=class{constructor(t,e,n,o){this.kept=!1,this.isDisposedInternal=!1,this.shape=t.slice(),this.dtype=e||"float32",this.size=re(t),this.strides=yi(t),this.dataId=n,this.id=o,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){let t=await this.data();return lm.buffer(this.shape,this.dtype,t)}bufferSync(){return lm.buffer(this.shape,this.dtype,this.dataSync())}async array(){let t=await this.data();return Ru(this.shape,t,this.dtype==="complex64")}arraySync(){return Ru(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();let t=qs().read(this.dataId);if(this.dtype==="string"){let e=await t;try{return e.map(n=>am(n))}catch(n){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return t}dataToGPU(t){return this.throwIfDisposed(),qs().readToGPU(this.dataId,t)}dataSync(){this.throwIfDisposed();let t=qs().readSync(this.dataId);if(this.dtype==="string")try{return t.map(e=>am(e))}catch(e){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return t}async bytes(){this.throwIfDisposed();let t=await qs().read(this.dataId);return this.dtype==="string"?t:new Uint8Array(t.buffer)}dispose(){this.isDisposed||(qs().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(t=!1){return lm.print(this,t)}clone(){return this.throwIfDisposed(),lm.clone(this)}toString(t=!1){let e=this.dataSync();return B1(e,this.shape,this.dtype,t)}cast(t){return this.throwIfDisposed(),lm.cast(this,t)}variable(t=!0,e,n){return this.throwIfDisposed(),qs().makeVariable(this,t,e,n)}};Object.defineProperty(Pt,Symbol.hasInstance,{value:r=>!!r&&r.data!=null&&r.dataSync!=null&&r.throwIfDisposed!=null});function L(){return Gd("Tensor",()=>Pt)}L();var Ga=class extends Pt{constructor(t,e,n,o){super(t.shape,t.dtype,t.dataId,o),this.trainable=e,this.name=n}assign(t){if(t.dtype!==this.dtype)throw new Error(`dtype of the new value (${t.dtype}) and previous value (${this.dtype}) must match`);if(!Mn(t.shape,this.shape))throw new Error(`shape of the new value (${t.shape}) and previous value (${this.shape}) must match`);qs().disposeTensor(this),this.dataId=t.dataId,qs().incRef(this,null)}dispose(){qs().disposeVariable(this),this.isDisposedInternal=!0}};Object.defineProperty(Ga,Symbol.hasInstance,{value:r=>r instanceof Pt&&r.assign!=null&&r.assign instanceof Function});var fo={};Yt(fo,{assertTypesMatch:()=>QC,getTensorsInContainer:()=>Jd,isTensorInList:()=>JU,makeTypesMatch:()=>jt});var jC;(function(r){r.R0="R0",r.R1="R1",r.R2="R2",r.R3="R3",r.R4="R4",r.R5="R5",r.R6="R6"})(jC||(jC={}));var XC;(function(r){r.float32="float32",r.int32="int32",r.bool="int32",r.complex64="complex64"})(XC||(XC={}));var YC;(function(r){r.float32="float32",r.int32="int32",r.bool="bool",r.complex64="complex64"})(YC||(YC={}));var ZC;(function(r){r.float32="float32",r.int32="float32",r.bool="float32",r.complex64="complex64"})(ZC||(ZC={}));var JC;(function(r){r.float32="complex64",r.int32="complex64",r.bool="complex64",r.complex64="complex64"})(JC||(JC={}));var ZU={float32:ZC,int32:XC,bool:YC,complex64:JC};function ar(r,t){if(r==="string"||t==="string"){if(r==="string"&&t==="string")return"string";throw new Error(`Can not upcast ${r} with ${t}`)}return ZU[r][t]}function Wu(r){return ar(r,"int32")}function jt(r,t){if(r.dtype===t.dtype)return[r,t];let e=ar(r.dtype,t.dtype);return[r.cast(e),t.cast(e)]}function QC(r,t){A(r.dtype===t.dtype,()=>`The dtypes of the first(${r.dtype}) and second(${t.dtype}) input must match`)}function JU(r,t){return t.some(e=>e.id===r.id)}function Jd(r){let t=[];return H1(r,t,new Set),t}function H1(r,t,e){if(r==null)return;if(r instanceof Pt){t.push(r);return}if(!QU(r))return;let n=r;for(let o in n){let s=n[o];e.has(s)||(e.add(s),H1(s,t,e))}}function QU(r){return Array.isArray(r)||typeof r=="object"}function tI(r){return r.kernelName!=null}var wx=class{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(t=>t.name)))}}}dispose(){for(let t in this.registeredVariables)this.registeredVariables[t].dispose()}},Kl=class{constructor(t){this.ENV=t,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new wx}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;let t=this.getSortedBackends();for(let e=0;e<t.length;e++){let n=t[e];if(await this.initializeBackend(n).success){await this.setBackend(n);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){let{name:t,asyncInit:e}=this.initializeBackendsAndReturnBest();if(e)throw new Error(`The highest priority backend '${t}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry))if(t in this.registryFactory){let{asyncInit:e}=this.initializeBackend(t);if(e)return null}else return null;return this.registry[t]}findBackendFactory(t){return t in this.registryFactory?this.registryFactory[t].factory:null}registerBackend(t,e,n=1){return t in this.registryFactory?(Pi(`${t} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[t]={factory:e,priority:n},!0)}async setBackend(t){if(this.registryFactory[t]==null)throw new Error(`Backend name '${t}' not found in registry`);if(this.backendName=t,this.registry[t]==null){this.backendInstance=null;let{success:e,asyncInit:n}=this.initializeBackend(t);if(!(n?await e:e))return!1}return this.backendInstance=this.registry[t],this.setupRegisteredKernels(),this.profiler=new yx(this.backendInstance),!0}setupRegisteredKernels(){hx(this.backendName).forEach(e=>{e.setupFunc!=null&&e.setupFunc(this.backendInstance)})}disposeRegisteredKernels(t){hx(t).forEach(n=>{n.disposeFunc!=null&&n.disposeFunc(this.registry[t])})}initializeBackend(t){let e=this.registryFactory[t];if(e==null)throw new Error(`Cannot initialize backend ${t}, no registration found.`);try{let n=e.factory();if(n&&!(n instanceof jo)&&typeof n.then=="function"){let o=++this.pendingBackendInitId,s=n.then(i=>o<this.pendingBackendInitId?!1:(this.registry[t]=i,this.pendingBackendInit=null,!0)).catch(i=>(o<this.pendingBackendInitId||(this.pendingBackendInit=null,Pi(`Initialization of backend ${t} failed`),Pi(i.stack||i.message)),!1));return this.pendingBackendInit=s,{success:s,asyncInit:!0}}else return this.registry[t]=n,{success:!0,asyncInit:!1}}catch(n){return Pi(`Initialization of backend ${t} failed`),Pi(n.stack||n.message),{success:!1,asyncInit:!1}}}removeBackend(t){if(!(t in this.registryFactory))throw new Error(`${t} backend not found in registry`);this.backendName===t&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((t,e)=>this.registryFactory[e].priority-this.registryFactory[t].priority)}initializeBackendsAndReturnBest(){let t=this.getSortedBackends();for(let e=0;e<t.length;e++){let n=t[e],{success:o,asyncInit:s}=this.initializeBackend(n);if(s||o)return{name:n,asyncInit:s}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(t,e){let n=this.state.tensorInfo.get(e),o=n.backend,s=this.readSync(e),i=o.refCount(e);o.disposeData(e,!0),n.backend=t,t.move(e,s,n.shape,n.dtype,i),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(t,e){let n=null;if(e==null){if(typeof t!="function")throw new Error("Please provide a function to tidy()");e=t}else{if(typeof t!="string"&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof e!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");n=t}let o;return this.scopedRun(()=>this.startScope(n),()=>this.endScope(o),()=>(o=e(),o instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),o))}scopedRun(t,e,n){t();try{let o=n();return e(),o}catch(o){throw e(),o}}nextTensorId(){return Kl.nextTensorId++}nextVariableId(){return Kl.nextVariableId++}clone(t){let e=_.runKernel(lo,{x:t}),n={x:t},o=i=>({x:()=>{let a="float32",u={x:i},l={dtype:a};return _.runKernel(io,u,l)}}),s=[];return this.addTapeNode(this.state.activeScope.name,n,[e],o,s,{}),e}runKernel(t,e,n){if(this.backendName==null&&this.backend,!(Kd(t,this.backendName)!=null))throw new Error(`Kernel '${t}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:t,inputs:e,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(t,e,n){let o=this.backend.numDataIds(),s=0;n.forEach(u=>{s+=u.dtype==="complex64"?3:1});let i=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],a=o-e-s-i;if(a>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${a} data ids) after running '${t}'`)}runKernelFunc(t){let e,n=[],o=this.isTapeOn(),s=this.state.numBytes,i=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let a;this.backendName==null&&this.backend;let u,l=tI(t)?t.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(tI(t)){let{kernelName:d,inputs:h,attrs:g}=t;this.backendName==null&&this.backend;let y=Kd(d,this.backendName);A(y!=null,()=>`Cannot find registered kernel '${d}' for backend '${this.backendName}'`),a=()=>{let b=this.backend.numDataIds();u=y.kernelFunc({inputs:h,attrs:g,backend:this.backend});let w=Array.isArray(u)?u:[u];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(d,b,w);let v=w.map(k=>{if(k.rank!=null)return k;let{dataId:E,shape:$,dtype:D}=k;return this.makeTensorFromDataId(E,$,D)});if(o){let k=this.getTensorsForGradient(d,h,v);n=this.saveTensorsForBackwardMode(k)}return v}}else{let{forwardFunc:d}=t,h=g=>{!o||(n=g.map(y=>this.keep(this.clone(y))))};a=()=>{let g=this.backend.numDataIds();u=this.tidy(()=>d(this.backend,h));let y=Array.isArray(u)?u:[u];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(l,g,y),y}}let{inputs:c,attrs:p}=t,m=tI(t)?null:t.backwardsFunc,f;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?e=a():(f=this.profiler.profileKernel(l,c,()=>a()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(f),e=f.outputs)}),o&&this.addTapeNode(l,c,e,m,n,p),this.state.profiling&&this.state.activeProfile.kernels.push({name:l,bytesAdded:this.state.numBytes-s,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-i,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(c).map(d=>c[d]!=null?c[d].shape:null),outputShapes:e.map(d=>d.shape),kernelTimeMs:f.timeMs,extraInfo:f.extraInfo}),Array.isArray(u)?e:e[0]}saveTensorsForBackwardMode(t){return t.map(n=>this.keep(this.clone(n)))}getTensorsForGradient(t,e,n){let o=BC(t);if(o!=null){let s=o.inputsToSave||[],i=o.outputsToSave||[],a;o.saveAllInputs?(A(Array.isArray(e),()=>"saveAllInputs is true, expected inputs to be an array."),a=Object.keys(e).map(l=>e[l])):a=s.map(l=>e[l]);let u=n.filter((l,c)=>i[c]);return a.concat(u)}return[]}makeTensor(t,e,n,o){if(t==null)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",o=o||this.backend;let s=t;n==="string"&&Yo(t[0])&&(s=t.map(u=>ql(u)));let i=o.write(s,e,n),a=new Pt(e,n,i,this.nextTensorId());if(this.trackTensor(a,o),n==="string"){let u=this.state.tensorInfo.get(i),l=MC(s);this.state.numBytes+=l-u.bytes,u.bytes=l}return a}makeTensorFromDataId(t,e,n,o){n=n||"float32";let s=new Pt(e,n,t,this.nextTensorId());return this.trackTensor(s,o),s}makeVariable(t,e=!0,n,o){n=n||this.nextVariableId().toString(),o!=null&&o!==t.dtype&&(t=t.cast(o));let s=new Ga(t,e,n,this.nextTensorId());if(this.state.registeredVariables[s.name]!=null)throw new Error(`Variable with name ${s.name} was already registered`);return this.state.registeredVariables[s.name]=s,this.incRef(s,this.backend),s}trackTensor(t,e){this.state.numTensors++,t.dtype==="string"&&this.state.numStringTensors++;let n=0;t.dtype!=="complex64"&&t.dtype!=="string"&&(n=t.size*dx(t.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(t.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(t.dataId,{backend:e||this.backend,dtype:t.dtype,shape:t.shape,bytes:n})),t instanceof Ga||this.track(t)}incRef(t,e){this.trackTensor(t,e),this.backend.incRef(t.dataId)}removeDataId(t,e){this.state.tensorInfo.has(t)&&this.state.tensorInfo.get(t).backend===e&&(this.state.tensorInfo.delete(t),this.state.numDataBuffers--)}disposeTensor(t){if(!this.state.tensorInfo.has(t.dataId))return;let e=this.state.tensorInfo.get(t.dataId);if(this.state.numTensors--,t.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=e.bytes),t.dtype!=="complex64"&&t.dtype!=="string"){let n=t.size*dx(t.dtype);this.state.numBytes-=n}e.backend.disposeData(t.dataId)&&this.removeDataId(t.dataId,e.backend)}disposeVariables(){for(let t in this.state.registeredVariables){let e=this.state.registeredVariables[t];this.disposeVariable(e)}}disposeVariable(t){this.disposeTensor(t),this.state.registeredVariables[t.name]!=null&&delete this.state.registeredVariables[t.name]}memory(){let t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,t.reasons==null&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t}async profile(t){this.state.profiling=!0;let e=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await t(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(o=>o.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-e,this.state.activeProfile.newTensors=this.state.numTensors-n;for(let o of this.state.activeProfile.kernels)o.kernelTimeMs=await o.kernelTimeMs,o.extraInfo=await o.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(t,e,n,o,s,i){let a={id:this.state.nextTapeNodeId++,kernelName:t,inputs:e,outputs:n,saved:s},u=BC(t);u!=null&&(o=u.gradFunc),o!=null&&(a.gradient=l=>(l=l.map((c,p)=>{if(c==null){let m=n[p],f=kp(m.size,m.dtype);return this.makeTensor(f,m.shape,m.dtype)}return c}),o(l.length>1?l:l[0],s,i))),this.state.activeTape.push(a)}keep(t){return t.kept=!0,t}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){let e={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(e.name=t),this.state.scopeStack.push(e),this.state.activeScope=e}endScope(t){let e=Jd(t),n=new Set(e.map(s=>s.id));for(let s=0;s<this.state.activeScope.track.length;s++){let i=this.state.activeScope.track[s];!i.kept&&!n.has(i.id)&&i.dispose()}let o=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],e.forEach(s=>{!s.kept&&s.scopeId===o.id&&this.track(s)})}gradients(t,e,n,o=!1){if(A(e.length>0,()=>"gradients() received an empty list of xs."),n!=null&&n.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);let s=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",t));A(s instanceof Pt,()=>"The result y returned by f() must be a tensor.");let i=P1(this.state.activeTape,e,s);if(!o&&i.length===0&&e.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{let a={};a[s.id]=n==null?t4(s.shape):n,L1(a,i,l=>this.tidy(l),e4);let u=e.map(l=>a[l.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(l=>{for(let c of l.saved)c.dispose()}),this.state.activeTape=null),{value:s,grads:u}})}customGrad(t){return A(xi(t),()=>"The f passed in customGrad(f) must be a function."),(...e)=>{A(e.every(a=>a instanceof Pt),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let n,o={};e.forEach((a,u)=>{o[u]=a});let s=(a,u)=>(n=t(...e,u),A(n.value instanceof Pt,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),A(xi(n.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),n.value),i=(a,u)=>{let l=n.gradFunc(a,u),c=Array.isArray(l)?l:[l];A(c.length===e.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),A(c.every(m=>m instanceof Pt),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");let p={};return c.forEach((m,f)=>{p[f]=()=>m}),p};return this.runKernelFunc({forwardFunc:s,backwardsFunc:i,inputs:o})}}readSync(t){return this.state.tensorInfo.get(t).backend.readSync(t)}read(t){return this.state.tensorInfo.get(t).backend.read(t)}readToGPU(t,e){return this.state.tensorInfo.get(t).backend.readToGPU(t,e)}async time(t){let e=Gu(),n=await this.backend.time(t);return n.wallMs=Gu()-e,n}track(t){return this.state.activeScope!=null&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new wx;for(let t in this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}};Kl.nextTensorId=0;Kl.nextVariableId=0;function t4(r){let t=Ld(re(r),"float32");return _.makeTensor(t,r,"float32")}function eI(){let r=zC();if(r._tfengine==null){let t=new Vd(r);r._tfengine=new Kl(t)}return y1(r._tfengine.ENV),G1(()=>r._tfengine),r._tfengine}var _=eI();function e4(r,t){let e={a:r,b:t};return _.runKernel(Xn,e)}var jl={};Yt(jl,{isBrowser:()=>nI,isMobile:()=>o4,mockIsMobile:()=>n4});function r4(){return typeof navigator!="undefined"&&navigator!=null}var rI;function n4(r){rI=r}function o4(r){if(rI!==void 0)return rI;if(r||r4()){if(r||(r=navigator),r.product==="ReactNative")return!0;let t=r.userAgent||r.vendor||(typeof window!="undefined"?window.opera:"");if(!t){let e=r;return e.userAgentData&&e.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function nI(){return typeof window!="undefined"&&window.document!=null||typeof WorkerGlobalScope!="undefined"}var ho=V();ho.registerFlag("DEBUG",()=>!1,r=>{r&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});ho.registerFlag("IS_BROWSER",()=>nI());ho.registerFlag("IS_NODE",()=>typeof process!="undefined"&&typeof process.versions!="undefined"&&typeof process.versions.node!="undefined");ho.registerFlag("IS_CHROME",()=>typeof navigator!="undefined"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));ho.registerFlag("PROD",()=>!1);ho.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>ho.getBool("DEBUG"));ho.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);ho.registerFlag("IS_TEST",()=>!1);ho.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>!0);ho.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);ho.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);function Or(r,t){let e=r;if(yr(r))return t==="string"?[]:[r.length];if(!Array.isArray(r))return[];let n=[];for(;Array.isArray(e)||yr(e)&&t!=="string";)n.push(e.length),e=e[0];return Array.isArray(r)&&V().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&K1(r,n,[]),n}function K1(r,t,e){if(e=e||[],!Array.isArray(r)&&!yr(r)){A(t.length===0,()=>`Element arr[${e.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);return}A(t.length>0,()=>`Element arr[${e.join("][")}] should be a primitive, but is an array of ${r.length} elements`),A(r.length===t[0],()=>`Element arr[${e.join("][")}] should have ${t[0]} elements, but has ${r.length} elements`);let n=t.slice(1);for(let o=0;o<r.length;++o)K1(r[o],n,e.concat(o))}function q1(r,t,e,n){if(r!=="string_or_numeric"){if(r==null)throw new Error("Expected dtype cannot be null.");if(r!=="numeric"&&r!==t||r==="numeric"&&t==="string")throw new Error(`Argument '${e}' passed to '${n}' must be ${r} tensor, but got ${t} tensor`)}}function C(r,t,e,n="numeric"){if(r instanceof Pt)return q1(n,r.dtype,t,e),r;let o=Ip(r);if(o!=="string"&&["bool","int32","float32"].indexOf(n)>=0&&(o=n),q1(n,o,t,e),r==null||!yr(r)&&!Array.isArray(r)&&typeof r!="number"&&typeof r!="boolean"&&typeof r!="string"){let u=r==null?"null":r.constructor.name;throw new Error(`Argument '${t}' passed to '${e}' must be a Tensor or TensorLike, but got '${u}'`)}let s=Or(r,o);!yr(r)&&!Array.isArray(r)&&(r=[r]);let a=o!=="string"?im(r,o):Xo(r,[],!0);return _.makeTensor(a,s,o)}function Wa(r,t,e,n="numeric"){if(!Array.isArray(r))throw new Error(`Argument ${t} passed to ${e} must be a \`Tensor[]\` or \`TensorLike[]\``);return r.map((s,i)=>C(s,`${t}[${i}]`,e,n))}var j1="__op";function N(r){let t=Object.keys(r);if(t.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let e=t[0],n=r[e];e.endsWith("_")&&(e=e.substring(0,e.length-1)),e=e+j1;let o=(...s)=>{_.startScope(e);try{let i=n(...s);return Bd(i)&&console.error("Cannot return a Promise inside of tidy."),_.endScope(i),i}catch(i){throw _.endScope(null),i}};return Object.defineProperty(o,"name",{value:e,configurable:!0}),o}function s4(r,t){let e=C(r,"real","complex"),n=C(t,"imag","complex");Me(e.shape,n.shape,`real and imag shapes, ${e.shape} and ${n.shape}, must match in call to tf.complex().`);let o={real:e,imag:n};return _.runKernel(Ap,o)}var zn=N({complex_:s4});function cn(r,t,e,n){if(n==null&&(n=Ip(r)),n==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!yr(r)&&!Array.isArray(r)&&typeof r!="number"&&typeof r!="boolean"&&typeof r!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(t!=null){zd(t);let o=re(t),s=re(e);A(o===s,()=>`Based on the provided shape, [${t}], the tensor should have ${o} values but has ${s}`);for(let i=0;i<e.length;++i){let a=e[i],u=i===e.length-1?a!==re(t.slice(i)):!0;A(e[i]===t[i]||!u,()=>`Error creating a new Tensor. Inferred shape (${e}) does not match the provided shape (${t}). `)}}return!yr(r)&&!Array.isArray(r)&&(r=[r]),t=t||e,r=n!=="string"?im(r,n):Xo(r,[],!0),_.makeTensor(r,t,n)}function Ar(r,t,e){let n=Or(r,e);return cn(r,t,n,e)}var Qd={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};var vx=4;async function Y1(r,t){let e=[],n=[],o=Array.isArray(r)?r.map(i=>i.name):Object.keys(r);for(let i=0;i<o.length;++i){let a=o[i],u=Array.isArray(r)?r[i].tensor:r[a];if(u.dtype!=="float32"&&u.dtype!=="int32"&&u.dtype!=="bool"&&u.dtype!=="string"&&u.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${a}': ${u.dtype}`);let l={name:a,shape:u.shape,dtype:u.dtype};if(u.dtype==="string"){let c=new Promise(async p=>{let m=await u.bytes(),f=m.reduce((g,y)=>g+y.length,0)+vx*m.length,d=new Uint8Array(f),h=0;for(let g=0;g<m.length;g++){let y=m[g],b=new Uint8Array(new Uint32Array([y.length]).buffer);d.set(b,h),h+=vx,d.set(y,h),h+=y.length}p(d)});n.push(c)}else n.push(u.data());t!=null&&(l.group=t),e.push(l)}let s=await Promise.all(n);return{data:i4(s),specs:e}}function Cx(r,t){let e={},n,o=0;for(let s of t){let i=s.name,a=s.dtype,u=s.shape,l=re(u),c;if("quantization"in s){let p=s.quantization;if(p.dtype==="uint8"||p.dtype==="uint16"){if(!("min"in p&&"scale"in p))throw new Error(`Weight ${s.name} with quantization ${p.dtype} doesn't have corresponding metadata min and scale.`)}else if(p.dtype==="float16"){if(a!=="float32")throw new Error(`Weight ${s.name} is quantized with ${p.dtype} which only supports weights of type float32 not ${a}.`)}else throw new Error(`Weight ${s.name} has unknown quantization dtype ${p.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);let m=Qd[p.dtype],f=r.slice(o,o+l*m),d=p.dtype==="uint8"?new Uint8Array(f):new Uint16Array(f);if(a==="float32")if(p.dtype==="uint8"||p.dtype==="uint16"){c=new Float32Array(d.length);for(let h=0;h<d.length;h++){let g=d[h];c[h]=g*p.scale+p.min}}else if(p.dtype==="float16")n===void 0&&(n=c4()),c=n(d);else throw new Error(`Unsupported quantization type ${p.dtype} for weight type float32.`);else if(a==="int32"){if(p.dtype!=="uint8"&&p.dtype!=="uint16")throw new Error(`Unsupported quantization type ${p.dtype} for weight type int32.`);c=new Int32Array(d.length);for(let h=0;h<d.length;h++){let g=d[h];c[h]=Math.round(g*p.scale+p.min)}}else throw new Error(`Unsupported dtype in weight '${i}': ${a}`);o+=l*m}else if(a==="string"){let p=re(s.shape);c=[];for(let m=0;m<p;m++){let f=new Uint32Array(r.slice(o,o+vx))[0];o+=vx;let d=new Uint8Array(r.slice(o,o+f));c.push(d),o+=f}}else{let p=Qd[a],m=r.slice(o,o+l*p);if(a==="float32")c=new Float32Array(m);else if(a==="int32")c=new Int32Array(m);else if(a==="bool")c=new Uint8Array(m);else if(a==="complex64"){c=new Float32Array(m);let f=new Float32Array(c.length/2),d=new Float32Array(c.length/2);for(let y=0;y<f.length;y++)f[y]=c[y*2],d[y]=c[y*2+1];let h=Ar(f,u,"float32"),g=Ar(d,u,"float32");e[i]=zn(h,g),h.dispose(),g.dispose()}else throw new Error(`Unsupported dtype in weight '${i}': ${a}`);o+=l*p}a!=="complex64"&&(e[i]=Ar(c,u,a))}return e}function i4(r){if(r===null)throw new Error(`Invalid input value: ${JSON.stringify(r)}`);let t=0,e=[];r.forEach(s=>{if(t+=s.byteLength,e.push(s.byteLength===s.buffer.byteLength?s:new s.constructor(s)),!(s instanceof Float32Array||s instanceof Int32Array||s instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${s.constructor.name}`)});let n=new Uint8Array(t),o=0;return e.forEach(s=>{n.set(new Uint8Array(s.buffer),o),o+=s.byteLength}),n.buffer}var oI=typeof Buffer!="undefined"&&(typeof Blob=="undefined"||typeof atob=="undefined"||typeof btoa=="undefined");function X1(r){return oI?Buffer.byteLength(r):new Blob([r]).size}function Z1(r){if(oI)return Buffer.from(r).toString("base64");let t=new Uint8Array(r),e="";for(let n=0,o=t.length;n<o;n++)e+=String.fromCharCode(t[n]);return btoa(e)}function J1(r){if(oI){let n=Buffer.from(r,"base64");return n.buffer.slice(n.byteOffset,n.byteOffset+n.byteLength)}let t=atob(r),e=new Uint8Array(t.length);for(let n=0;n<t.length;++n)e.set([t.charCodeAt(n)],n);return e.buffer}function um(r){if(r.length===1)return r[0];let t=0;r.forEach(o=>{t+=o.byteLength});let e=new Uint8Array(t),n=0;return r.forEach(o=>{e.set(new Uint8Array(o),n),n+=o.byteLength}),e.buffer}function sI(r){let t="/";for(r=r.trim();r.endsWith(t);)r=r.slice(0,r.length-1);let e=r.split(t);return e[e.length-1]}function Ix(r,t){let e={modelTopology:r.modelTopology,format:r.format,generatedBy:r.generatedBy,convertedBy:r.convertedBy,weightsManifest:t};return r.signature!=null&&(e.signature=r.signature),r.userDefinedMetadata!=null&&(e.userDefinedMetadata=r.userDefinedMetadata),r.modelInitializer!=null&&(e.modelInitializer=r.modelInitializer),r.trainingConfig!=null&&(e.trainingConfig=r.trainingConfig),e}async function cm(r,t){let e={modelTopology:r.modelTopology,format:r.format,generatedBy:r.generatedBy,convertedBy:r.convertedBy};if(r.trainingConfig!=null&&(e.trainingConfig=r.trainingConfig),r.weightsManifest!=null){let[n,o]=await t(r.weightsManifest);e.weightSpecs=n,e.weightData=o}return r.signature!=null&&(e.signature=r.signature),r.userDefinedMetadata!=null&&(e.userDefinedMetadata=r.userDefinedMetadata),r.modelInitializer!=null&&(e.modelInitializer=r.modelInitializer),e}function Li(r){if(r.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:r.modelTopology==null?0:X1(JSON.stringify(r.modelTopology)),weightSpecsBytes:r.weightSpecs==null?0:X1(JSON.stringify(r.weightSpecs)),weightDataBytes:r.weightData==null?0:r.weightData.byteLength}}function a4(){let r=e=>{let n=e<<13,o=0;for(;(n&8388608)===0;)o-=8388608,n<<=1;return n&=-8388609,o+=947912704,n|o},t=new Uint32Array(2048);t[0]=0;for(let e=1;e<1024;e++)t[e]=r(e);for(let e=1024;e<2048;e++)t[e]=939524096+(e-1024<<13);return t}function l4(){let r=new Uint32Array(64);r[0]=0,r[31]=1199570944,r[32]=2147483648,r[63]=3347054592;for(let t=1;t<31;t++)r[t]=t<<23;for(let t=33;t<63;t++)r[t]=2147483648+(t-32<<23);return r}function u4(){let r=new Uint32Array(64);for(let t=0;t<64;t++)r[t]=1024;return r[0]=r[32]=0,r}function c4(){let r=a4(),t=l4(),e=u4();return n=>{let o=new ArrayBuffer(4*n.length),s=new Uint32Array(o);for(let i=0;i<n.length;i++){let a=n[i],u=r[e[a>>10]+(a&1023)]+t[a>>10];s[i]=u}return new Float32Array(o)}}var ke=class{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return ke.instance==null&&(ke.instance=new ke),ke.instance}static registerSaveRouter(t){ke.getInstance().saveRouters.push(t)}static registerLoadRouter(t){ke.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return ke.getHandlers(t,"save")}static getLoadHandlers(t,e){return ke.getHandlers(t,"load",e)}static getHandlers(t,e,n){let o=[];return(e==="load"?ke.getInstance().loadRouters:ke.getInstance().saveRouters).forEach(i=>{let a=i(t,n);a!==null&&o.push(a)}),o}},Q1=r=>ke.registerSaveRouter(r),t_=r=>ke.registerLoadRouter(r),e_=r=>ke.getSaveHandlers(r),r_=(r,t)=>ke.getLoadHandlers(r,t);var iI="tensorflowjs",aI=1,Uu="models_store",Xl="model_info_store";function n_(){if(!V().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");let r=typeof window=="undefined"?self:window,t=r.indexedDB||r.mozIndexedDB||r.webkitIndexedDB||r.msIndexedDB||r.shimIndexedDB;if(t==null)throw new Error("The current browser does not appear to support IndexedDB.");return t}function lI(r){let t=r.result;t.createObjectStore(Uu,{keyPath:"modelPath"}),t.createObjectStore(Xl,{keyPath:"modelPath"})}var zi=class{constructor(t){if(this.indexedDB=n_(),t==null||!t)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=t}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,t)}async load(){return this.databaseAction(this.modelPath)}databaseAction(t,e){return new Promise((n,o)=>{let s=this.indexedDB.open(iI,aI);s.onupgradeneeded=()=>lI(s),s.onsuccess=()=>{let i=s.result;if(e==null){let a=i.transaction(Uu,"readonly"),l=a.objectStore(Uu).get(this.modelPath);l.onsuccess=()=>{if(l.result==null)return i.close(),o(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));n(l.result.modelArtifacts)},l.onerror=c=>(i.close(),o(l.error)),a.oncomplete=()=>i.close()}else{let a=Li(e),u=i.transaction(Xl,"readwrite"),l=u.objectStore(Xl),c=l.put({modelPath:this.modelPath,modelArtifactsInfo:a}),p;c.onsuccess=()=>{p=i.transaction(Uu,"readwrite");let f=p.objectStore(Uu).put({modelPath:this.modelPath,modelArtifacts:e,modelArtifactsInfo:a});f.onsuccess=()=>n({modelArtifactsInfo:a}),f.onerror=d=>{l=u.objectStore(Xl);let h=l.delete(this.modelPath);h.onsuccess=()=>(i.close(),o(f.error)),h.onerror=g=>(i.close(),o(f.error))}},c.onerror=m=>(i.close(),o(c.error)),u.oncomplete=()=>{p==null?i.close():p.oncomplete=()=>i.close()}}},s.onerror=i=>o(s.error)})}};zi.URL_SCHEME="indexeddb://";var o_=r=>V().getBool("IS_BROWSER")&&!Array.isArray(r)&&r.startsWith(zi.URL_SCHEME)?p4(r.slice(zi.URL_SCHEME.length)):null;ke.registerSaveRouter(o_);ke.registerLoadRouter(o_);function p4(r){return new zi(r)}function m4(r){return r.startsWith(zi.URL_SCHEME)?r.slice(zi.URL_SCHEME.length):r}var Sx=class{constructor(){this.indexedDB=n_()}async listModels(){return new Promise((t,e)=>{let n=this.indexedDB.open(iI,aI);n.onupgradeneeded=()=>lI(n),n.onsuccess=()=>{let o=n.result,s=o.transaction(Xl,"readonly"),a=s.objectStore(Xl).getAll();a.onsuccess=()=>{let u={};for(let l of a.result)u[l.modelPath]=l.modelArtifactsInfo;t(u)},a.onerror=u=>(o.close(),e(a.error)),s.oncomplete=()=>o.close()},n.onerror=o=>e(n.error)})}async removeModel(t){return t=m4(t),new Promise((e,n)=>{let o=this.indexedDB.open(iI,aI);o.onupgradeneeded=()=>lI(o),o.onsuccess=()=>{let s=o.result,i=s.transaction(Xl,"readwrite"),a=i.objectStore(Xl),u=a.get(t),l;u.onsuccess=()=>{if(u.result==null)return s.close(),n(new Error(`Cannot find model with path '${t}' in IndexedDB.`));{let c=a.delete(t),p=()=>{l=s.transaction(Uu,"readwrite");let f=l.objectStore(Uu).delete(t);f.onsuccess=()=>e(u.result.modelArtifactsInfo),f.onerror=d=>n(u.error)};c.onsuccess=p,c.onerror=m=>(p(),s.close(),n(u.error))}},u.onerror=c=>(s.close(),n(u.error)),i.oncomplete=()=>{l==null?s.close():l.oncomplete=()=>s.close()}},o.onerror=s=>n(o.error)})}};var Ua="/",pm="tensorflowjs_models",s_="info",f4="model_topology",d4="weight_specs",h4="weight_data",g4="model_metadata";function i_(r){return{info:[pm,r,s_].join(Ua),topology:[pm,r,f4].join(Ua),weightSpecs:[pm,r,d4].join(Ua),weightData:[pm,r,h4].join(Ua),modelMetadata:[pm,r,g4].join(Ua)}}function a_(r){for(let t of Object.values(r))window.localStorage.removeItem(t)}function x4(r){let t=r.split(Ua);if(t.length<3)throw new Error(`Invalid key format: ${r}`);return t.slice(1,t.length-1).join(Ua)}function y4(r){return r.startsWith(Bi.URL_SCHEME)?r.slice(Bi.URL_SCHEME.length):r}var Bi=class{constructor(t){if(!V().getBool("IS_BROWSER")||typeof window=="undefined"||typeof window.localStorage=="undefined")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,t==null||!t)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=t,this.keys=i_(this.modelPath)}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{let e=JSON.stringify(t.modelTopology),n=JSON.stringify(t.weightSpecs),o=Li(t);try{this.LS.setItem(this.keys.info,JSON.stringify(o)),this.LS.setItem(this.keys.topology,e),this.LS.setItem(this.keys.weightSpecs,n),this.LS.setItem(this.keys.weightData,Z1(t.weightData));let s={format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,signature:t.signature!=null?t.signature:void 0,userDefinedMetadata:t.userDefinedMetadata!=null?t.userDefinedMetadata:void 0,modelInitializer:t.modelInitializer!=null?t.modelInitializer:void 0,trainingConfig:t.trainingConfig!=null?t.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(s)),{modelArtifactsInfo:o}}catch(s){throw a_(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${o.modelTopologyBytes}, weightSpecsBytes=${o.weightSpecsBytes}, weightDataBytes=${o.weightDataBytes}.`)}}}async load(){let t=JSON.parse(this.LS.getItem(this.keys.info));if(t==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(t.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");let e={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(n==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);e.modelTopology=n;let o=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(o==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);e.weightSpecs=o;let s=this.LS.getItem(this.keys.modelMetadata);if(s!=null){let a=JSON.parse(s);e.format=a.format,e.generatedBy=a.generatedBy,e.convertedBy=a.convertedBy,a.signature!=null&&(e.signature=a.signature),a.userDefinedMetadata!=null&&(e.userDefinedMetadata=a.userDefinedMetadata),a.modelInitializer!=null&&(e.modelInitializer=a.modelInitializer),a.trainingConfig!=null&&(e.trainingConfig=a.trainingConfig)}let i=this.LS.getItem(this.keys.weightData);if(i==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return e.weightData=J1(i),e}};Bi.URL_SCHEME="localstorage://";var l_=r=>V().getBool("IS_BROWSER")&&!Array.isArray(r)&&r.startsWith(Bi.URL_SCHEME)?b4(r.slice(Bi.URL_SCHEME.length)):null;ke.registerSaveRouter(l_);ke.registerLoadRouter(l_);function b4(r){return new Bi(r)}var kx=class{constructor(){A(V().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),A(typeof window=="undefined"||typeof window.localStorage!="undefined",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){let t={},e=pm+Ua,n=Ua+s_;for(let o=0;o<this.LS.length;++o){let s=this.LS.key(o);if(s.startsWith(e)&&s.endsWith(n)){let i=x4(s);t[i]=JSON.parse(this.LS.getItem(s))}}return t}async removeModel(t){t=y4(t);let e=i_(t);if(this.LS.getItem(e.info)==null)throw new Error(`Cannot find model at path '${t}'`);let n=JSON.parse(this.LS.getItem(e.info));return a_(e),n}};var mm="://",Xr=class{constructor(){this.managers={}}static getInstance(){return Xr.instance==null&&(Xr.instance=new Xr),Xr.instance}static registerManager(t,e){A(t!=null,()=>"scheme must not be undefined or null."),t.endsWith(mm)&&(t=t.slice(0,t.indexOf(mm))),A(t.length>0,()=>"scheme must not be an empty string.");let n=Xr.getInstance();A(n.managers[t]==null,()=>`A model store manager is already registered for scheme '${t}'.`),n.managers[t]=e}static getManager(t){let e=this.getInstance().managers[t];if(e==null)throw new Error(`Cannot find model manager for scheme '${t}'`);return e}static getSchemes(){return Object.keys(this.getInstance().managers)}};function Nx(r){if(r.indexOf(mm)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${Xr.getSchemes().join(",")}`);return{scheme:r.split(mm)[0],path:r.split(mm)[1]}}async function u_(r,t,e=!1){A(r!==t,()=>`Old path and new path are the same: '${r}'`);let n=ke.getLoadHandlers(r);A(n.length>0,()=>`Copying failed because no load handler is found for source URL ${r}.`),A(n.length<2,()=>`Copying failed because more than one (${n.length}) load handlers for source URL ${r}.`);let o=n[0],s=ke.getSaveHandlers(t);A(s.length>0,()=>`Copying failed because no save handler is found for destination URL ${t}.`),A(s.length<2,()=>`Copying failed because more than one (${n.length}) save handlers for destination URL ${t}.`);let i=s[0],a=Nx(r).scheme,u=Nx(r).path,l=a===Nx(r).scheme,c=await o.load();e&&l&&await Xr.getManager(a).removeModel(u);let p=await i.save(c);return e&&!l&&await Xr.getManager(a).removeModel(u),p.modelArtifactsInfo}async function c_(){let r=Xr.getSchemes(),t={};for(let e of r){let n=await Xr.getManager(e).listModels();for(let o in n){let s=e+mm+o;t[s]=n[o]}}return t}async function p_(r){let t=Nx(r);return Xr.getManager(t.scheme).removeModel(t.path)}async function m_(r,t){return u_(r,t,!1)}async function f_(r,t){return u_(r,t,!0)}var uI=class{fetch(t,e){return fetch(t,e)}now(){return performance.now()}encode(t,e){if(e!=="utf-8"&&e!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${e}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(t)}decode(t,e){return new TextDecoder(e).decode(t)}};if(V().get("IS_BROWSER")){V().setPlatform("browser",new uI);try{Xr.registerManager(Bi.URL_SCHEME,new kx)}catch(r){}try{Xr.registerManager(zi.URL_SCHEME,new Sx)}catch(r){}}var w4={importFetch:()=>d_()},cI;var pI=class{constructor(){this.util=h_(),this.textEncoder=new this.util.TextEncoder}fetch(t,e){return V().global.fetch!=null?V().global.fetch(t,e):(cI==null&&(cI=w4.importFetch()),cI(t,e))}now(){let t=process.hrtime();return t[0]*1e3+t[1]/1e6}encode(t,e){if(e!=="utf-8"&&e!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${e}`);return this.textEncoder.encode(t)}decode(t,e){return t.length===0?"":new this.util.TextDecoder(e).decode(t)}};V().get("IS_NODE")&&!V().get("IS_BROWSER")&&V().setPlatform("node",new pI);function It(r,t="float32",e){return t=t||"float32",zd(r),new pe(r,t,e)}function v4(r,t){let e=C(r,"x","cast");if(!OC(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if(t==="string"&&e.dtype!=="string"||t!=="string"&&e.dtype==="string")throw new Error("Only strings can be casted to strings");let n={x:e},o={dtype:t};return _.runKernel(io,n,o)}var Z=N({cast_:v4});function C4(r){let e={x:C(r,"x","clone","string_or_numeric")};return _.runKernel(lo,e)}var kn=N({clone_:C4});function mI(r,t=!1){console.log(r.toString(t))}eI();var I4={buffer:It,cast:Z,clone:kn,print:mI};W1(I4);var Mr={};Yt(Mr,{browserFiles:()=>x_,browserHTTPRequest:()=>w_,concatenateArrayBuffers:()=>um,copyModel:()=>m_,decodeWeights:()=>Cx,encodeWeights:()=>Y1,fromMemory:()=>v_,getLoadHandlers:()=>r_,getModelArtifactsForJSON:()=>cm,getModelArtifactsInfoForJSON:()=>Li,getSaveHandlers:()=>e_,http:()=>_x,isHTTPScheme:()=>Tx,listModels:()=>c_,loadWeights:()=>y_,moveModel:()=>f_,registerLoadRouter:()=>t_,registerSaveRouter:()=>Q1,removeModel:()=>p_,weightsLoaderFactory:()=>gI,withSaveHandler:()=>C_});var S4="model",k4=".json",N4=".weights.bin";function g_(r){return new Promise(t=>setTimeout(t)).then(r)}var Ha=class{constructor(t){if(!V().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");t.startsWith(Ha.URL_SCHEME)&&(t=t.slice(Ha.URL_SCHEME.length)),(t==null||t.length===0)&&(t=S4),this.modelJsonFileName=t+k4,this.weightDataFileName=t+N4}async save(t){if(typeof document=="undefined")throw new Error("Browser downloads are not supported in this environment since `document` is not present");let e=window.URL.createObjectURL(new Blob([t.weightData],{type:"application/octet-stream"}));if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{let n=[{paths:["./"+this.weightDataFileName],weights:t.weightSpecs}],o=Ix(t,n),s=window.URL.createObjectURL(new Blob([JSON.stringify(o)],{type:"application/json"})),i=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(i.download=this.modelJsonFileName,i.href=s,await g_(()=>i.dispatchEvent(new MouseEvent("click"))),t.weightData!=null){let a=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;a.download=this.weightDataFileName,a.href=e,await g_(()=>a.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:Li(t)}}}};Ha.URL_SCHEME="downloads://";var fI=class{constructor(t){if(t==null||t.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${t}`);this.jsonFile=t[0],this.weightsFiles=t.slice(1)}async load(){return new Promise((t,e)=>{let n=new FileReader;n.onload=o=>{let s=JSON.parse(o.target.result),i=s.modelTopology;if(i==null){e(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(s.weightsManifest==null){e(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){t({modelTopology:i});return}let u=cm(s,l=>this.loadWeights(l));t(u)},n.onerror=o=>e(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),n.readAsText(this.jsonFile)})}loadWeights(t){let e=[],n=[];for(let i of t)e.push(...i.weights),n.push(...i.paths);let o=this.checkManifestAndWeightFiles(t),s=n.map(i=>this.loadWeightsFile(i,o[i]));return Promise.all(s).then(i=>[e,um(i)])}loadWeightsFile(t,e){return new Promise((n,o)=>{let s=new FileReader;s.onload=i=>{let a=i.target.result;n(a)},s.onerror=i=>o(`Failed to weights data from file of path '${t}'.`),s.readAsArrayBuffer(e)})}checkManifestAndWeightFiles(t){let e=[],n=this.weightsFiles.map(s=>sI(s.name)),o={};for(let s of t)s.paths.forEach(i=>{let a=sI(i);if(e.indexOf(a)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${a}'`);if(e.push(a),n.indexOf(a)===-1)throw new Error(`Weight file with basename '${a}' is not provided.`);o[i]=this.weightsFiles[n.indexOf(a)]});if(e.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${e.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return o}},T4=r=>V().getBool("IS_BROWSER")&&!Array.isArray(r)&&r.startsWith(Ha.URL_SCHEME)?_4(r.slice(Ha.URL_SCHEME.length)):null;ke.registerSaveRouter(T4);function _4(r="model"){return new Ha(r)}function x_(r){return new fI(r)}function dI(r,t,e,n){i(r),e=e==null?0:e,n=n==null?1:n,a(e,n);let o=0,s=u=>(u.then(l=>{let c=e+ ++o/r.length*(n-e);return t(c),l}),u);function i(u){A(u!=null&&Array.isArray(u)&&u.length>0,()=>"promises must be a none empty array")}function a(u,l){A(u>=0&&u<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${u}`),A(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${l}`),A(l>=u,()=>`startFraction must be no more than endFraction, but got startFraction ${u} and endFraction ${l}`)}return Promise.all(r.map(s))}async function hI(r,t){t==null&&(t={});let e=t.fetchFunc==null?V().platform.fetch:t.fetchFunc,n=r.map(p=>e(p,t.requestInit,{isBinary:!0})),o=0,s=.5,a=(t.onProgress==null?await Promise.all(n):await dI(n,t.onProgress,o,s)).map(p=>p.arrayBuffer()),u=.5,l=1;return t.onProgress==null?await Promise.all(a):await dI(a,t.onProgress,u,l)}async function y_(r,t="",e,n){return gI(i=>hI(i,{requestInit:n}))(r,t,e)}function gI(r){return async(t,e="",n)=>{let o=t.map(()=>!1),s={},i=n!=null?n.map(()=>!1):[],a=[];if(t.forEach((f,d)=>{let h=0;f.weights.forEach(g=>{let y="quantization"in g?g.quantization.dtype:g.dtype,b=Qd[y]*re(g.shape),w=()=>{o[d]=!0,s[d]==null&&(s[d]=[]),s[d].push({manifestEntry:g,groupOffset:h,sizeBytes:b})};n!=null?n.forEach((v,k)=>{v===g.name&&(w(),i[k]=!0)}):w(),a.push(g.name),h+=b})}),!i.every(f=>f)){let f=n.filter((d,h)=>!i[h]);throw new Error(`Could not find weights in manifest with names: ${f.join(", ")}. 
Manifest JSON has weights with names: ${a.join(", ")}.`)}let u=o.reduce((f,d,h)=>(d&&f.push(h),f),[]),l=[];u.forEach(f=>{t[f].paths.forEach(d=>{let h=e+(e.endsWith("/")?"":"/")+d;l.push(h)})});let c=await r(l),p={},m=0;return u.forEach(f=>{let d=t[f].paths.length,h=0;for(let v=0;v<d;v++)h+=c[m+v].byteLength;let g=new ArrayBuffer(h),y=new Uint8Array(g),b=0;for(let v=0;v<d;v++){let k=new Uint8Array(c[m+v]);y.set(k,b),b+=k.byteLength}s[f].forEach(v=>{let k=g.slice(v.groupOffset,v.groupOffset+v.sizeBytes),E=Cx(k,[v.manifestEntry]);for(let $ in E)p[$]=E[$]}),m+=d}),p}}var E4="application/octet-stream",A4="application/json",th=class{constructor(t,e){if(this.DEFAULT_METHOD="POST",e==null&&(e={}),this.weightPathPrefix=e.weightPathPrefix,this.onProgress=e.onProgress,this.weightUrlConverter=e.weightUrlConverter,e.fetchFunc!=null?(A(typeof e.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=e.fetchFunc):this.fetch=V().platform.fetch,A(t!=null&&t.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(t)&&A(t.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${t.length}).`),this.path=t,e.requestInit!=null&&e.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=e.requestInit||{}}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");let e=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);e.body=new FormData;let n=[{paths:["./model.weights.bin"],weights:t.weightSpecs}],o=Ix(t,n);e.body.append("model.json",new Blob([JSON.stringify(o)],{type:A4}),"model.json"),t.weightData!=null&&e.body.append("model.weights.bin",new Blob([t.weightData],{type:E4}),"model.weights.bin");let s=await this.fetch(this.path,e);if(s.ok)return{modelArtifactsInfo:Li(t),responses:[s]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${s.status}.`)}async load(){let t=await this.fetch(this.path,this.requestInit);if(!t.ok)throw new Error(`Request to ${this.path} failed with status code ${t.status}. Please verify this URL points to the model JSON of the model to load.`);let e;try{e=await t.json()}catch(s){let i=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?i+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":i+=" Please make sure the server is serving valid JSON for this request.",new Error(i)}let n=e.modelTopology,o=e.weightsManifest;if(n==null&&o==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return cm(e,s=>this.loadWeights(s))}async loadWeights(t){let e=Array.isArray(this.path)?this.path[1]:this.path,[n,o]=$4(e),s=this.weightPathPrefix||n,i=[];for(let c of t)i.push(...c.weights);let a=[],u=[];for(let c of t)for(let p of c.paths)this.weightUrlConverter!=null?u.push(this.weightUrlConverter(p)):a.push(s+p+o);this.weightUrlConverter&&a.push(...await Promise.all(u));let l=await hI(a,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress});return[i,um(l)]}};th.URL_SCHEME_REGEX=/^https?:\/\//;function $4(r){let t=r.lastIndexOf("/"),e=r.lastIndexOf("?"),n=r.substring(0,t),o=e>t?r.substring(e):"";return[n+"/",o]}function Tx(r){return r.match(th.URL_SCHEME_REGEX)!=null}var b_=(r,t)=>{if(typeof fetch=="undefined"&&(t==null||t.fetchFunc==null))return null;{let e=!0;if(Array.isArray(r)?e=r.every(n=>Tx(n)):e=Tx(r),e)return _x(r,t)}return null};ke.registerSaveRouter(b_);ke.registerLoadRouter(b_);function _x(r,t){return new th(r,t)}function w_(r,t){return _x(r,t)}var eh=class{constructor(t){this.modelArtifacts=t}async load(){return this.modelArtifacts}},xI=class{constructor(t){this.saveHandler=t}async save(t){return this.saveHandler(t)}};function v_(r,t,e,n){return arguments.length===1?r.modelTopology!=null||r.weightSpecs!=null?new eh(r):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new eh({modelTopology:r})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new eh({modelTopology:r,weightSpecs:t,weightData:e,trainingConfig:n}))}function C_(r){return new xI(r)}var S_={};Yt(S_,{confusionMatrix:()=>I_});function D4(r,t,e=!1,n=!1){let o=C(r,"a","matMul"),s=C(t,"b","matMul");[o,s]=jt(o,s);let i={a:o,b:s},a={transposeA:e,transposeB:n};return _.runKernel(ts,i,a)}var Lt=N({matMul_:D4});function R4(r,t,e=1,n=0){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);let s={indices:C(r,"indices","oneHot","int32")},i={depth:t,onValue:e,offValue:n};return _.runKernel(ks,s,i)}var Ks=N({oneHot_:R4});function F4(r,t){let e=C(r,"x","transpose");if(t==null&&(t=e.shape.map((s,i)=>i).reverse()),A(e.rank===t.length,()=>`Error in transpose: rank of input ${e.rank} must match length of perm ${t}.`),t.forEach(s=>{A(s>=0&&s<e.rank,()=>`All entries in 'perm' must be between 0 and ${e.rank-1} but got ${t}`)}),e.rank<=1)return e.clone();let n={x:e},o={perm:t};return _.runKernel(Us,n,o)}var Wt=N({transpose_:F4});function O4(r,t,e){let n=C(r,"labels","confusionMatrix"),o=C(t,"predictions","confusionMatrix");A(e==null||e>0&&Number.isInteger(e),()=>`If provided, numClasses must be a positive integer, but got ${e}`),A(n.rank===1,()=>`Expected the rank of labels to be 1, but got ${n.rank}`),A(o.rank===1,()=>`Expected the rank of predictions to be 1, but got ${o.rank}`),A(n.shape[0]===o.shape[0],()=>`Mismatch in the number of examples: ${n.shape[0]} vs. ${o.shape[0]}. Labels and predictions should have the same number of elements.`),A(e>0&&Number.isInteger(e),()=>`numClasses is required to be a positive integer, but got ${e}`);let s=Ks(Z(n,"int32"),e),i=Ks(Z(o,"int32"),e),a=Wt(s),u=Lt(a,i);return Z(u,"int32")}var I_=N({confusionMatrix_:O4});var Pr={};Yt(Pr,{assertAndGetBroadcastShape:()=>zt,getBroadcastDims:()=>k_,getReductionAxes:()=>ge});function k_(r,t){let e=r.length,n=[];for(let o=0;o<e;o++){let s=e-1-o,i=r[s]||1;(t[t.length-1-o]||1)>1&&i===1&&n.unshift(s)}return n}function ge(r,t){let e=[];for(let n=0;n<t.length;n++){let o=r[r.length-n-1],s=t.length-n-1,i=t[s];(o==null||o===1&&i>1)&&e.unshift(s)}return e}function zt(r,t){let e=[],n=Math.max(r.length,t.length);for(let o=0;o<n;o++){let s=r[r.length-o-1];s==null&&(s=1);let i=t[t.length-o-1];if(i==null&&(i=1),s===1)e.unshift(i);else if(i===1)e.unshift(s);else if(s!==i){let a=`Operands could not be broadcast together with shapes ${r} and ${t}.`;throw Error(a)}else e.unshift(s)}return e}var Ex={};Yt(Ex,{fromPixels:()=>G4,fromPixelsAsync:()=>B4,toPixels:()=>V4});function yI(r,t,e){if(jn(r),t!=null&&t.length!==3)throw new Error("tensor3d() requires shape to have three numbers");let n=Or(r,e);if(n.length!==3&&n.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(n.length===1&&t==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return cn(r,t,n,e)}var Hu;function N_(r,t=3){if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(r==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let e=!1,n=!1,o=!1,s=!1,i=!1,a=!1;if(r.data instanceof Uint8Array)e=!0;else if(typeof ImageData!="undefined"&&r instanceof ImageData)n=!0;else if(typeof HTMLVideoElement!="undefined"&&r instanceof HTMLVideoElement)o=!0;else if(typeof HTMLImageElement!="undefined"&&r instanceof HTMLImageElement)s=!0;else if(r.getContext!=null)i=!0;else if(typeof ImageBitmap!="undefined"&&r instanceof ImageBitmap)a=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${r.constructor.name}`);if(o&&o&&r.readyState<2)throw new Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.");if(Kd(Hd,_.backendName)!=null){let d={pixels:r},h={numChannels:t};return _.runKernel(Hd,d,h)}let[l,c]=o?[r.videoWidth,r.videoHeight]:[r.width,r.height],p;if(i)p=r.getContext("2d").getImageData(0,0,l,c).data;else if(n||e)p=r.data;else if(s||o||a){if(Hu==null)if(typeof document=="undefined")if(typeof OffscreenCanvas!="undefined"&&typeof OffscreenCanvasRenderingContext2D!="undefined")Hu=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else Hu=document.createElement("canvas").getContext("2d");Hu.canvas.width=l,Hu.canvas.height=c,Hu.drawImage(r,0,0,l,c),p=Hu.getImageData(0,0,l,c).data}let m;if(t===4)m=new Int32Array(p);else{let d=l*c;m=new Int32Array(d*t);for(let h=0;h<d;h++)for(let g=0;g<t;++g)m[h*t+g]=p[h*4+g]}return yI(m,[c,l,t],"int32")}function M4(r){return r!=null&&r.data instanceof Uint8Array}function P4(){return typeof window!="undefined"&&typeof ImageBitmap!="undefined"&&window.hasOwnProperty("createImageBitmap")}function L4(r){return r!=null&&r.width!==0&&r.height!==0}function z4(r){return P4()&&!(r instanceof ImageBitmap)&&L4(r)&&!M4(r)}async function B4(r,t=3){let e=null;if(V().getBool("WRAP_TO_IMAGEBITMAP")&&z4(r)){let n;try{n=await createImageBitmap(r,{premultiplyAlpha:"none"})}catch(o){n=null}n!=null&&n.width===r.width&&n.height===r.height?e=n:e=r}else e=r;return N_(e,t)}async function V4(r,t){let e=C(r,"img","toPixels");if(!(r instanceof Pt)){let l=e;e=Z(l,"int32"),l.dispose()}if(e.rank!==2&&e.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${e.rank}.`);let[n,o]=e.shape.slice(0,2),s=e.rank===2?1:e.shape[2];if(s>4||s===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${s}`);if(e.dtype!=="float32"&&e.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${e.dtype}. Please use float32 or int32 tensors.`);let i=await e.data(),a=e.dtype==="float32"?255:1,u=new Uint8ClampedArray(o*n*4);for(let l=0;l<n*o;++l){let c=[0,0,0,255];for(let m=0;m<s;m++){let f=i[l*s+m];if(e.dtype==="float32"){if(f<0||f>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${f}.`)}else if(e.dtype==="int32"&&(f<0||f>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${f}.`);s===1?(c[0]=f*a,c[1]=f*a,c[2]=f*a):c[m]=f*a}let p=l*4;u[p+0]=Math.round(c[0]),u[p+1]=Math.round(c[1]),u[p+2]=Math.round(c[2]),u[p+3]=Math.round(c[3])}if(t!=null){t.width=o,t.height=n;let l=t.getContext("2d"),c=new ImageData(u,o,n);l.putImageData(c,0,0)}return e!==r&&e.dispose(),u}var G4=N({fromPixels_:N_});var Ax={};Yt(Ax,{prepareAndValidate:()=>T_});function T_(r,t){let e=r.shape.length,n=t.shape.length;if(e<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${e}.`);if(n<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${n}.`);if(t.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[n-1]>e)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[n-1]} vs. ${e}`);if(re(r.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${r.shape}.`);let o=t.shape,s=o[o.length-1],i=1;for(let p=0;p<o.length-1;++p)i*=o[p];let a=r.shape,u=o.slice();u.pop();let l=1;for(let p=s;p<e;++p)l*=a[p],u.push(a[p]);let c=[...yi(r.shape).map(p=>p/l),1].slice(0,s);return[u,i,l,c]}var rh={};Yt(rh,{calculateShapes:()=>__,validateInput:()=>$x,validateUpdateShape:()=>bI});function bI(r,t,e){let n=t.rank>1?t.shape[t.rank-1]:1,o=t.rank>1?t.rank-1:1,s=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${e.shape}, indices.shape: ${t.shape}, shape: ${r}, sliceDim: ${n}, and batchDim: ${o}.`;if(e.rank<o)throw new Error(s+` update.rank < ${o}. `);if(r.length<n+(e.rank-o))throw new Error(s+` Output shape length < ${n+(e.rank-o)}`);if(e.rank!==o+r.length-n)throw new Error(s+` update.rank != ${o+r.length-n}`);for(let i=0;i<o;++i)if(e.shape[i]!==t.shape[i])throw new Error(s+` updates.shape[${i}] (${e.shape[i]}) != indices.shape[${i}] (${t.shape[i]}).`);for(let i=0;i<e.rank-o;++i)if(e.shape[i+o]!==r[i+n])throw new Error(s+` updates.shape[${i+o}] (${e.shape[i+o]}) != shape[${i+o}] (${r[i+o]})`)}function $x(r,t,e){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(r.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${r.rank}.`);if(t.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(e.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${e}`);if(e.length===0){if(t.size===0)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(r.size===0)throw new Error(`Updates specified for empty output. updates shape: ${r.shape}`)}bI(e,t,r)}function __(r,t,e){let n=t.shape.length,o=n>1?t.shape[n-1]:1,s=e.length,i=1;for(let p=o;p<s;++p)i*=e[p];let a=o<1?1:o,u=re(t.shape)/a,l=[...yi(e.slice(0,o)),1],c=re(e);return{sliceRank:o,numUpdates:u,sliceSize:i,strides:l,outputSize:c}}var Ve={};Yt(Ve,{assertParamsValid:()=>U4,computeFlatOffset:()=>X4,computeOutShape:()=>q4,getNormalizedAxes:()=>K4,isSliceContinous:()=>j4,maskToAxes:()=>H4,parseSliceParams:()=>vI,sliceInfo:()=>Y4,startForAxis:()=>M_,startIndicesWithElidedDims:()=>R_,stopForAxis:()=>P_,stopIndicesWithElidedDims:()=>F_,stridesForAxis:()=>O_,stridesWithElidedDims:()=>A_});var wI=-2,W4=-1;function U4(r,t,e){let n=r.shape.length;A(n===t.length,()=>`Error in slice${n}D: Length of begin ${t} must match the rank of the array (${n}).`),A(n===e.length,()=>`Error in slice${n}D: Length of size ${e} must match the rank of the array (${n}).`);for(let o=0;o<n;++o)A(t[o]+e[o]<=r.shape[o],()=>`Error in slice${n}D: begin[${o}] + size[${o}] (${t[o]+e[o]}) would overflow input.shape[${o}] (${r.shape[o]})`)}function H4(r){let t=[],e=0;for(;r>0;)r&1&&t.push(e),r/=2,e++;return t}function q4(r,t,e){let n=[];for(let o=0;o<r.length;o++)n[o]=Math.ceil((t[o]-r[o])/e[o]);return n}function A_(r,t,e,n){let o=[...r];for(let s=o.length;s<n.length;s++)o.push(1);for(let s=0;s<e;s++)s===0?o[t]=1:(o.splice(t,0,1),o.pop());return o}function $_(r,t,e){return e<=r?e:e-(t-1)}function D_(r,t){let e=[];for(let n=0;n<r;n++)e.push(t+n);return e}function K4(r,t,e,n,o,s,i,a,u){let l=r.length,c=new Array(l),p=new Array(l),m=new Array(l);if(t.length&&e>0){let f=t[0],d=e+1;c=R_(i,f,d,n,r),p=F_(a,f,d,o,r),m=A_(s,f,d,r)}else for(let f=0;f<l;f++)c[f]=M_(i,n,s,r,f,u),p[f]=P_(a,o,s,r,f,u),m[f]=O_(s,f,u);return{begin:c,end:p,strides:m}}function R_(r,t,e,n,o){let s=[...o],i=D_(e,t);for(let a=0;a<s.length;a++)if(i.indexOf(a)>-1)s[a]=0;else{let u=$_(t,e,a),l=n[u];r&1<<u&&(l=0),s[a]=l}return s}function F_(r,t,e,n,o){let s=[...o],i=D_(e,t);for(let a=0;a<s.length;a++)if(i.indexOf(a)>-1)s[a]=Number.MAX_SAFE_INTEGER;else{let u=$_(t,e,a),l=n[u];r&1<<u&&(l=Number.MAX_SAFE_INTEGER),s[a]=l}for(let a=0;a<s.length;a++){let u=o[a];s[a]<0&&(s[a]+=u),s[a]=Cp(0,s[a],o[a])}return s}function O_(r,t,e){let n=r[t];return(e&1<<t||n==null)&&(n=1),n}function M_(r,t,e,n,o,s){let i=t[o],a=e[o]||1;(r&1<<o||s&1<<o||i==null)&&(a>0?i=Number.MIN_SAFE_INTEGER:i=Number.MAX_SAFE_INTEGER);let u=n[o];return i<0&&(i+=u),i=Cp(0,i,u-1),i}function P_(r,t,e,n,o,s){let i=t[o],a=e[o]||1;(r&1<<o||s&1<<o||i==null)&&(a>0?i=Number.MAX_SAFE_INTEGER:i=Number.MIN_SAFE_INTEGER);let u=n[o];return i<0&&(i+=u),a>0?i=Cp(0,i,u):i=Cp(-1,i,u-1),i}function j4(r,t,e){let n=e.length;for(let o=0;o<e.length;o++)if(e[o]>1){n=o;break}for(let o=n+1;o<e.length;o++)if(t[o]>0||e[o]!==r[o])return!1;return!0}function X4(r,t){let e=r.length>0?r[r.length-1]:1;for(let n=0;n<r.length-1;n++)e+=r[n]*t[n];return e}function vI(r,t,e){let n,o=r.shape.length;typeof t=="number"?n=[t,...new Array(o-1).fill(0)]:t.length<o?n=t.concat(new Array(o-t.length).fill(0)):n=t.slice(),n.forEach(i=>{A(i!==-1,()=>"slice() does not support negative begin indexing.")});let s;return e==null?s=new Array(o).fill(-1):typeof e=="number"?s=[e,...new Array(o-1).fill(-1)]:e.length<o?s=e.concat(new Array(o-e.length).fill(-1)):s=e,s=s.map((i,a)=>i>=0?i:(A(i===-1,()=>`Negative size values should be exactly -1 but got ${i} for the slice() size at index ${a}.`),r.shape[a]-n[a])),[n,s]}function Y4(r,t,e,n,o,s,i,a,u){let l;if(n==null?(l=new Array(t.length),l.fill(1)):l=n,i!=null&&(i&i-1)!==0)throw new Error("Multiple ellipses in slice is not allowed.");let c=!1,p={dims:l.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:e.slice(),strides:l.slice(),beginMask:o,endMask:s,ellipsisMask:i,newAxisMask:a,shrinkAxisMask:u};for(let w=0;w<p.dims;w++)c&&(1<<w&a)!==0&&p.numAddAxisAfterEllipsis++,1<<w&i&&(c=!0);c||(p.ellipsisMask|=1<<p.dims,p.dims++);let m={dims:r.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};Z4(p,m);let f=!0,d=!0,h=!0,g=[],y=[];for(let w=0;w<r.length;++w){if(m.strides[w]===0)throw Error(`strides[${w}] must be non-zero`);let v=!!(m.shrinkAxisMask&1<<w),k=r[w];if(k===-1){g.push(v?1:-1);continue}let E=[m.beginMask&1<<w,m.endMask&1<<w],$=[m.strides[w]>0?0:-1,m.strides[w]>0?k:k-1];if(v&&m.strides[w]<=0)throw Error("only stride 1 allowed on non-range indexing.");h=h&&m.strides[w]===1;let D=!!(m.beginMask&1<<w&&m.endMask&1<<w);if(m.beginValid&&m.endValid){if(v){let U=m.begin[w]<0?k+m.begin[w]:m.begin[w];if(m.begin[w]=U,m.end[w]=m.begin[w]+1,U<0||U>=k)throw Error(`slice index ${m.begin[w]} of dimension ${w} out of bounds.`)}else m.begin[w]=E_(m.begin[w],0,m.strides[w],k,E,$),m.end[w]=E_(m.end[w],1,m.strides[w],k,E,$);let W=m.strides[w]===1&&m.begin[w]===0&&m.end[w]===k;f=f&&W,d=d&&(w===0&&m.strides[w]===1||W)}else f=f&&m.strides[w]===1&&D,d=d&&(w===0&&m.strides[w]===1||D);let R,P=!1;if(m.beginValid&&m.endValid?(R=m.end[w]-m.begin[w],P=!0):v?(R=1,P=!0):D&&k>=0&&(m.strides[w]<0?R=-k:R=k,P=!0),P){let W;R===0||R<0!=m.strides[w]<0?W=0:W=Math.trunc(R/m.strides[w])+(R%m.strides[w]!==0?1:0),g.push(W)}else g.push(-1)}for(let w=0;w<m.finalShapeGatherIndices.length;++w){let v=m.finalShapeGatherIndices[w];v>=0?y.push(g[v]):v===wI&&y.push(1)}return{finalShapeSparse:y.filter((w,v)=>m.finalShapeGatherIndices[v]!==wI),finalShape:y,isIdentity:f,sliceDim0:d,isSimpleSlice:h,begin:m.begin,end:m.end,strides:m.strides}}function Z4(r,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let e=0;t.beginValid=r.begin!=null,t.endValid=r.end!=null,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let n=0;n<r.dims;n++)if(1<<n&r.ellipsisMask){let o=Math.min(t.dims-(r.dims-n)+1+r.numAddAxisAfterEllipsis,t.dims);for(;e<o;e++)t.begin[e]=0,t.end[e]=0,t.strides[e]=1,t.beginMask|=1<<e,t.endMask|=1<<e,t.finalShapeGatherIndices.push(e),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[e]=n}else if(1<<n&r.newAxisMask)t.finalShapeGatherIndices.push(wI),t.finalShapeGatherIndicesSparse.push(-1);else{if(e===t.begin.length)throw Error(`Index out of range using input dim ${e}; input has only ${t.dims} dims, ${t.begin.length}.`);r.begin!=null&&(t.begin[e]=r.begin[n]),r.end!=null&&(t.end[e]=r.end[n]),t.strides[e]=r.strides[n],r.beginMask&1<<n&&(t.beginMask|=1<<e),r.endMask&1<<n&&(t.endMask|=1<<e),r.shrinkAxisMask&1<<n?(t.finalShapeGatherIndices.push(W4),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<e):(t.finalShapeGatherIndices.push(e),t.finalShapeGatherIndicesSparse.push(n)),t.inputShapeGatherIndicesSparse[e]=n,e++}}function E_(r,t,e,n,o,s){if(o[t])return e>0?s[t]:s[t+1&1];{let i=r<0?n+r:r;return i<s[0]?s[0]:i>s[1]?s[1]:i}}var et={};Yt(et,{Serializable:()=>nh,SerializationMap:()=>Vi,registerClass:()=>Nn});var nh=class{getClassName(){return this.constructor.className}static fromConfig(t,e){return new t(e)}},Vi=class{constructor(){this.classNameMap={}}static getMap(){return Vi.instance==null&&(Vi.instance=new Vi),Vi.instance}static register(t){Vi.getMap().classNameMap[t.className]=[t,t.fromConfig]}};function Nn(r){A(r.className!=null,()=>"Class being registered does not have the static className property defined."),A(typeof r.className=="string",()=>"className is required to be a string, but got type "+typeof r.className),A(r.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),Vi.register(r)}var V_={};Yt(V_,{TEST_EPSILON_FLOAT16:()=>L_,encodeStrings:()=>B_,expectArrayBuffersEqual:()=>nH,expectArraysClose:()=>Q4,expectArraysEqual:()=>eH,expectNumbersClose:()=>z_,expectPromiseToFail:()=>tH,expectValuesInRange:()=>rH,testEpsilon:()=>Dx});var J4=.001,L_=.1;function Q4(r,t,e){return e==null&&(e=Dx()),CI(r,t,(n,o)=>II(n,o,e))}function Dx(){return _.backend.floatPrecision()===32?J4:L_}function CI(r,t,e){let n=!0;if((yr(r)||yr(t))&&(n=!1),yr(r)&&yr(t)&&(n=!0),n){let i=r.constructor.name,a=t.constructor.name;if(i!==a)throw new Error(`Arrays are of different type. Actual: ${i}. Expected: ${a}`)}if(Array.isArray(r)&&Array.isArray(t)){let i=Or(r),a=Or(t);if(!Mn(i,a))throw new Error(`Arrays have different shapes. Actual: [${i}]. Expected: [${a}]`)}let o=yr(r)?r:Xo(r),s=yr(t)?t:Xo(t);if(o.length!==s.length)throw new Error(`Arrays have different lengths actual: ${o.length} vs expected: ${s.length}.
Actual:   ${o}.
Expected: ${s}.`);for(let i=0;i<s.length;++i){let a=o[i],u=s[i];if(!e(a,u))throw new Error(`Arrays differ: actual[${i}] = ${a}, expected[${i}] = ${u}.
Actual:   ${o}.
Expected: ${s}.`)}}function tH(r,t){r().then(()=>t.fail(),()=>t())}function eH(r,t){let e=typeof t=="string"||typeof t=="number"||typeof t=="boolean"?[t]:t;return Yo(r)||Yo(r[0])||Yo(t)||Yo(t[0])?CI(r,e,(n,o)=>n==o):CI(r,t,(n,o)=>II(n,o,0))}function z_(r,t,e){if(e==null&&(e=Dx()),!II(r,t,e))throw new Error(`Numbers differ: actual === ${r}, expected === ${t}`)}function II(r,t,e){return!isFinite(r)&&!isFinite(t)?!0:!(isNaN(r)||isNaN(t)||Math.abs(r-t)>e)}function rH(r,t,e){for(let n=0;n<r.length;n++)if(r[n]<t||r[n]>e)throw new Error(`Value out of range:${r[n]} low: ${t}, high: ${e}`)}function nH(r,t){let e=new Float32Array(r),n=new Float32Array(t);if(e.length!==n.length)throw new Error(`Expected ArrayBuffer to be of length ${n.length}, but it was ${e.length}`);for(let o=0;o<n.length;o++)if(e[o]!==n[o])throw new Error(`Expected ArrayBuffer value at ${o} to be ${n[o]} but got ${e[o]} instead`)}function B_(r){for(let t=0;t<r.length;t++){let e=r[t];Array.isArray(e)?B_(e):r[t]=ql(e)}return r}var G_="3.15.0";function Yct(){V().set("PROD",!0)}function Zct(){V().set("DEBUG",!0)}function Jct(){V().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function SI(r){V().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(r+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}U1(SI);function Qct(){_.disposeVariables()}function go(){return _}function oh(){return _.memory()}function tpt(r){return _.profile(r)}function B(r,t){return _.tidy(r,t)}function _t(r){Jd(r).forEach(e=>e.dispose())}function Pe(r){return _.keep(r)}function ept(r){return _.time(r)}function oH(r){return _.setBackend(r)}function rpt(){return _.ready()}function npt(){return _.backendName}function opt(r){_.removeBackend(r)}function spt(r){return _.findBackend(r)}function ipt(r){return _.findBackendFactory(r)}function fm(r,t,e=1){return _.registerBackend(r,t,e)}function W_(){return _.backend}function apt(r,t){V().setPlatform(r,t)}function sH(r,t){let e=C(r,"a","add"),n=C(t,"b","add");[e,n]=jt(e,n);let o={a:e,b:n};return _.runKernel(Xn,o)}var J=N({add_:sH});function iH(r,t){let e=C(r,"a","floorDiv"),n=C(t,"b","floorDiv");[e,n]=jt(e,n);let o={a:e,b:n};return _.runKernel(ms,o)}var qu=N({floorDiv_:iH});function aH(r,t){let e=C(r,"a","div"),n=C(t,"b","div");if([e,n]=jt(e,n),e.dtype==="int32"&&n.dtype==="int32")return qu(e,n);let o={a:e,b:n},s={};return _.runKernel(ls,o,s)}var ct=N({div_:aH});function lH(r,t){let e=C(r,"a","mul"),n=C(t,"b","mul");[e,n]=jt(e,n);let o={a:e,b:n};return _.runKernel(Ss,o)}var M=N({mul_:lH});function uH(r){let t=C(r,"x","abs");if(t.dtype==="complex64"){let e={x:t};return _.runKernel(Dl,e)}else{let e={x:t};return _.runKernel(bi,e)}}var Ne=N({abs_:uH});function cH(r){let e={x:C(r,"x","acos")};return _.runKernel(ta,e)}var sh=N({acos_:cH});function pH(r){let e={x:C(r,"x","acosh")};return _.runKernel(ea,e)}var ih=N({acosh_:pH});function mH(r){A(Array.isArray(r),()=>"The argument passed to tf.addN() must be a list of tensors"),A(r.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${r.length}`);let t=r.map((o,s)=>C(o,`tensors${s}`,"addN")),e=t[0];t.forEach(o=>{if(o.dtype!==e.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),t.forEach(o=>{if(!Mn(o.shape,e.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});let n=t;return _.runKernel(Zo,n)}var kI=N({addN_:mH});function fH(r,t=null,e=!1){let o={x:C(r,"x","all","bool")},s={axis:t,keepDims:e};return _.runKernel(ra,o,s)}var Ku=N({all_:fH});function dH(r,t=null,e=!1){let o={x:C(r,"x","any","bool")},s={axis:t,keepDims:e};return _.runKernel(na,o,s)}var Yl=N({any_:dH});function hH(r,t=0){let n={x:C(r,"x","argMax")},o={axis:t};return _.runKernel(Jo,n,o)}var js=N({argMax_:hH});function gH(r,t=0){let n={x:C(r,"x","argMin")},o={axis:t};return _.runKernel(Al,n,o)}var ah=N({argMin_:gH});function xH(r){let e={x:C(r,"x","asin")};return _.runKernel(oa,e)}var lh=N({asin_:xH});function yH(r){let e={x:C(r,"x","asinh")};return _.runKernel(sa,e)}var uh=N({asinh_:yH});function bH(r){let e={x:C(r,"x","atan")};return _.runKernel(ia,e)}var ch=N({atan_:bH});function wH(r,t){let e=C(r,"a","atan2"),n=C(t,"b","atan2");[e,n]=jt(e,n);let o={a:e,b:n};return _.runKernel(la,o)}var ph=N({atan2_:wH});function vH(r){let e={x:C(r,"x","atanh")};return _.runKernel(aa,e)}var mh=N({atanh_:vH});function CH(r,t,e,n,o="NHWC",s){let i=r[3],a=[...t,i],u=H_(o);return Xu(r,a,e,s,n,null,null,u)}function TI(r,t,e,n,o,s,i="channelsLast"){let[a,u]=Rx(t),l;if(i==="channelsLast")l=[a,u,r[3],r[3]];else if(i==="channelsFirst")l=[a,u,r[1],r[1]];else throw new Error(`Unknown dataFormat ${i}`);return Xu(r,l,e,n,o,s,!1,i)}function IH(r,t,e,n,o,s,i="NDHWC"){let[a,u,l]=NI(t),c,p;if(i==="NDHWC")p="channelsLast",c=[a,u,l,r[4],r[4]];else if(i==="NCDHW")p="channelsFirst",c=[a,u,l,r[1],r[1]];else throw new Error(`Unknown dataFormat ${i}`);return U_(r,c,e,n,o,!1,p,s)}function Xu(r,t,e,n,o,s,i=!1,a="channelsLast"){let[u,l,c,p]=[-1,-1,-1,-1];if(a==="channelsLast")[u,l,c,p]=r;else if(a==="channelsFirst")[u,p,l,c]=r;else throw new Error(`Unknown dataFormat ${a}`);let[m,f,,d]=t,[h,g]=Rx(e),[y,b]=Rx(n),w=dm(m,y),v=dm(f,b),{padInfo:k,outHeight:E,outWidth:$}=NH(o,l,c,h,g,w,v,s,a),D=i?d*p:d,R;return a==="channelsFirst"?R=[u,D,E,$]:a==="channelsLast"&&(R=[u,E,$,D]),{batchSize:u,dataFormat:a,inHeight:l,inWidth:c,inChannels:p,outHeight:E,outWidth:$,outChannels:D,padInfo:k,strideHeight:h,strideWidth:g,filterHeight:m,filterWidth:f,effectiveFilterHeight:w,effectiveFilterWidth:v,dilationHeight:y,dilationWidth:b,inShape:r,outShape:R,filterShape:t}}function U_(r,t,e,n,o,s=!1,i="channelsLast",a){let[u,l,c,p,m]=[-1,-1,-1,-1,-1];if(i==="channelsLast")[u,l,c,p,m]=r;else if(i==="channelsFirst")[u,m,l,c,p]=r;else throw new Error(`Unknown dataFormat ${i}`);let[f,d,h,,g]=t,[y,b,w]=NI(e),[v,k,E]=NI(n),$=dm(f,v),D=dm(d,k),R=dm(h,E),{padInfo:P,outDepth:W,outHeight:U,outWidth:q}=TH(o,l,c,p,y,b,w,$,D,R,a),K=s?g*m:g,j;return i==="channelsFirst"?j=[u,K,W,U,q]:i==="channelsLast"&&(j=[u,W,U,q,K]),{batchSize:u,dataFormat:i,inDepth:l,inHeight:c,inWidth:p,inChannels:m,outDepth:W,outHeight:U,outWidth:q,outChannels:K,padInfo:P,strideDepth:y,strideHeight:b,strideWidth:w,filterDepth:f,filterHeight:d,filterWidth:h,effectiveFilterDepth:$,effectiveFilterHeight:D,effectiveFilterWidth:R,dilationDepth:v,dilationHeight:k,dilationWidth:E,inShape:r,outShape:j,filterShape:t}}function SH(r,t,e,n,o){n==null&&(n=_I(r,t,e));let s=r[0],i=r[1],a=ju((s-t+2*n)/e+1,o),u=ju((i-t+2*n)/e+1,o);return[a,u]}function kH(r,t,e,n,o,s){o==null&&(o=_I(r,t,n));let i=r[0],a=r[1],u=r[2],l=ju((i-t+2*o)/n+1,s),c=ju((a-t+2*o)/n+1,s),p=ju((u-t+2*o)/n+1,s);return[l,c,p,e]}function _I(r,t,e,n=1){let o=dm(t,n);return Math.floor((r[0]*(e-1)-e+o)/2)}function Rx(r){return typeof r=="number"?[r,r,r]:r.length===2?[r[0],r[1],1]:r}function NI(r){return typeof r=="number"?[r,r,r]:r}function dm(r,t){return t<=1?r:r+(r-1)*(t-1)}function NH(r,t,e,n,o,s,i,a,u){let l,c,p;if(typeof r=="number"){l={top:r,bottom:r,left:r,right:r,type:r===0?"VALID":"NUMBER"};let f=SH([t,e],s,n,r,a);c=f[0],p=f[1]}else if(r==="same"){c=Math.ceil(t/n),p=Math.ceil(e/o);let m=Math.max(0,(c-1)*n+s-t),f=Math.max(0,(p-1)*o+i-e),d=Math.floor(m/2),h=m-d,g=Math.floor(f/2),y=f-g;l={top:d,bottom:h,left:g,right:y,type:"SAME"}}else if(r==="valid")l={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((t-s+1)/n),p=Math.ceil((e-i+1)/o);else if(typeof r=="object"){let m=u==="channelsLast"?r[1][0]:r[2][0],f=u==="channelsLast"?r[1][1]:r[2][1],d=u==="channelsLast"?r[2][0]:r[3][0],h=u==="channelsLast"?r[2][1]:r[3][1];l={top:m,bottom:f,left:d,right:h,type:m===0&&f===0&&d===0&&h===0?"VALID":"EXPLICIT"},c=ju((t-s+m+f)/n+1,a),p=ju((e-i+d+h)/o+1,a)}else throw Error(`Unknown padding parameter: ${r}`);return{padInfo:l,outHeight:c,outWidth:p}}function TH(r,t,e,n,o,s,i,a,u,l,c){let p,m,f,d;if(typeof r=="number"){p={top:r,bottom:r,left:r,right:r,front:r,back:r,type:r===0?"VALID":"NUMBER"};let g=kH([t,e,n,1],a,1,o,r,c);m=g[0],f=g[1],d=g[2]}else if(r==="same"){m=Math.ceil(t/o),f=Math.ceil(e/s),d=Math.ceil(n/i);let h=(m-1)*o+a-t,g=(f-1)*s+u-e,y=(d-1)*i+l-n,b=Math.floor(h/2),w=h-b,v=Math.floor(g/2),k=g-v,E=Math.floor(y/2),$=y-E;p={top:v,bottom:k,left:E,right:$,front:b,back:w,type:"SAME"}}else if(r==="valid")p={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},m=Math.ceil((t-a+1)/o),f=Math.ceil((e-u+1)/s),d=Math.ceil((n-l+1)/i);else throw Error(`Unknown padding parameter: ${r}`);return{padInfo:p,outDepth:m,outHeight:f,outWidth:d}}function ju(r,t){if(!t)return Math.trunc(r);switch(t){case"round":return Math.round(r);case"ceil":return Math.ceil(r);case"floor":return Math.floor(r);default:throw new Error(`Unknown roundingMode ${t}`)}}function Zn(r){let[t,e,n]=Rx(r);return t===1&&e===1&&n===1}function $r(r,t){return Zn(r)||Zn(t)}function H_(r){if(r==="NHWC")return"channelsLast";if(r==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${r}`)}function Te(r,t,e){if(e!=null){if(typeof t=="string")throw Error(`Error in ${r}: pad must be an integer when using dimRoundingMode ${e} but got pad ${t}.`);if(typeof t=="number")A(Qi(t),()=>`Error in ${r}: pad must be an integer when using dimRoundingMode ${e} but got pad ${t}.`);else if(typeof t=="object")t.forEach(n=>{n.forEach(o=>{A(Qi(o),()=>`Error in ${r}: pad must be an integer when using dimRoundingMode ${e} but got pad ${o}.`)})});else throw Error(`Error in ${r}: Unknown padding parameter: ${t}`)}}function _H(r,t){let n={x:C(r,"x","reshape","string_or_numeric")},o={shape:t};return _.runKernel(Ti,n,o)}var O=N({reshape_:_H});function EH(r,t,e,n,o){let s=C(r,"x","avgPool","float32"),i=1;A($r(e,i),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${e} and dilations '${i}'`);let a=s,u=!1;s.rank===3&&(u=!0,a=O(s,[1,s.shape[0],s.shape[1],s.shape[2]])),A(a.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${a.rank}.`),Te("avgPool",n,o);let l={x:a},c={filterSize:t,strides:e,pad:n,dimRoundingMode:o},p=_.runKernel(Qo,l,c);return p=Z(p,s.dtype),u?O(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var qa=N({avgPool_:EH});function AH(r,t,e,n,o,s="NDHWC"){let i=C(r,"x","avgPool3d","float32"),a=i,u=!1;i.rank===4&&(u=!0,a=O(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),A(a.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${a.rank}.`),A(s==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),Te("avgPool3d",n,o);let l={x:a},c={filterSize:t,strides:e,pad:n,dimRoundingMode:o,dataFormat:s},p=_.runKernel($l,l,c);return p=Z(p,a.dtype),u?O(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}var fh=N({avgPool3d_:AH});function $H(r,t=0){A(r.length>=1,()=>"Pass at least one tensor to concat");let e=Wa(r,"tensors","concat","string_or_numeric");if(e[0].dtype==="complex64"&&e.forEach(s=>{if(s.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${s.dtype}. `)}),e.length===1)return kn(e[0]);let n=e,o={axis:t};return _.runKernel(vi,n,o)}var se=N({concat_:$H});function DH(r){let e={x:C(r,"x","sigmoid","float32")};return _.runKernel(Ms,e)}var Lr=N({sigmoid_:DH});function RH(r,t,e){let n=C(r,"x","slice","string_or_numeric");if(n.rank===0)throw new Error("Slicing scalar is not possible");let o={x:n},s={begin:t,size:e};return _.runKernel(Ei,o,s)}var Rt=N({slice_:RH});function FH(r){let e={x:C(r,"x","tanh","float32")};return _.runKernel(Ws,e)}var Xs=N({tanh_:FH});function OH(r,t,e,n,o,s){let i=C(r,"forgetBias","basicLSTMCell"),a=C(t,"lstmKernel","basicLSTMCell"),u=C(e,"lstmBias","basicLSTMCell"),l=C(n,"data","basicLSTMCell"),c=C(o,"c","basicLSTMCell"),p=C(s,"h","basicLSTMCell"),m=se([l,p],1),f=Lt(m,a),d=J(f,u),h=d.shape[0],g=d.shape[1]/4,y=[h,g],b=Rt(d,[0,0],y),w=Rt(d,[0,g],y),v=Rt(d,[0,g*2],y),k=Rt(d,[0,g*3],y),E=J(M(Lr(b),Xs(w)),M(c,Lr(J(i,v)))),$=M(Xs(E),Lr(k));return[E,$]}var MH=N({basicLSTMCell_:OH});function PH(r,t,e){let n=C(r,"x","batchToSpaceND"),o=t.reduce((a,u)=>a*u);A(n.rank>=1+t.length,()=>`input rank is ${n.rank} but should be > than blockShape.length ${t.length}`),A(e.length===t.length,()=>`crops.length is ${e.length} but should be equal to blockShape.length  ${t.length}`),A(n.shape[0]%o===0,()=>`input tensor batch is ${n.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${o}`);let s={x:n},i={blockShape:t,crops:e};return _.runKernel(wi,s,i)}var Ka=N({batchToSpaceND_:PH});function q_(r){let t;return r.rank===0||r.rank===1?t=O(r,[1,1,1,r.size]):r.rank===2?t=O(r,[1,1,r.shape[0],r.shape[1]]):r.rank===3?t=O(r,[1,r.shape[0],r.shape[1],r.shape[2]]):t=r,t}function LH(r,t,e,n,o,s){s==null&&(s=.001);let i=C(r,"x","batchNorm"),a=C(t,"mean","batchNorm"),u=C(e,"variance","batchNorm"),l;o!=null&&(l=C(o,"scale","batchNorm"));let c;n!=null&&(c=C(n,"offset","batchNorm")),A(a.rank===u.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),A(c==null||a.rank===c.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),A(l==null||a.rank===l.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let m={x:q_(i),scale:l,offset:c,mean:a,variance:u},f={varianceEpsilon:s},d=_.runKernel(fs,m,f);return O(d,i.shape)}var xo=N({batchNorm_:LH});function zH(r,t,e,n,o,s){let i=C(r,"x","batchNorm"),a=C(t,"mean","batchNorm"),u=C(e,"variance","batchNorm"),l;o!=null&&(l=C(o,"scale","batchNorm"));let c;return n!=null&&(c=C(n,"offset","batchNorm")),A(i.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${i.rank}.`),A(a.rank===2||a.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${a.rank}.`),A(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${u.rank}.`),l!=null&&A(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${l.rank}.`),c!=null&&A(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`),xo(i,a,u,c,l,s)}var EI=N({batchNorm2d_:zH});function BH(r,t,e,n,o,s){let i=C(r,"x","batchNorm"),a=C(t,"mean","batchNorm"),u=C(e,"variance","batchNorm"),l;o!=null&&(l=C(o,"scale","batchNorm"));let c;return n!=null&&(c=C(n,"offset","batchNorm")),A(i.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${i.rank}.`),A(a.rank===3||a.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${a.rank}.`),A(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${u.rank}.`),l!=null&&A(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${l.rank}.`),c!=null&&A(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`),xo(i,a,u,c,l,s)}var AI=N({batchNorm3d_:BH});function VH(r,t,e,n,o,s){let i=C(r,"x","batchNorm"),a=C(t,"mean","batchNorm"),u=C(e,"variance","batchNorm"),l;o!=null&&(l=C(o,"scale","batchNorm"));let c;return n!=null&&(c=C(n,"offset","batchNorm")),A(i.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${i.rank}.`),A(a.rank===4||a.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${a.rank}.`),A(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${u.rank}.`),l!=null&&A(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${l.rank}.`),c!=null&&A(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`),xo(i,a,u,c,l,s)}var $I=N({batchNorm4d_:VH});function GH(r,t,e){let n=C(r,"x","bincount"),o=C(t,"weights","bincount");A(n.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${n.dtype}`),A(e>=0,()=>`size must be non-negative, but got ${e}.`),A(o.size===n.size||o.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${n.shape}, weights shape: ${o.shape}.`);let s={x:n,weights:o},i={size:e};return _.runKernel(_p,s,i)}var dh=N({bincount_:GH});function WH(r,t){let e=C(r,"s0","broadcastArgs","int32"),n=C(t,"s1","broadcastArgs","int32");if(e.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${e.rank}`);if(n.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${n.rank}`);let o={s0:e,s1:n};return _.runKernel(Ep,o)}var DI=N({broadcastArgs_:WH});function UH(r,t){let e=C(r,"broadcastTo","x"),n=e.shape;if(t.some(l=>!(l>0)||l%1!==0))throw new Error(`broadcastTo(): Invalid broadcast shape [${t}].`);if(t.length<e.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${e.rank}.`);if(t.length>e.rank){let l=e.shape.slice();for(;l.length<t.length;)l.unshift(1);e=O(e,l)}let o=e.shape,s=Array.from(t);for(let l=t.length-1;l>=0;l--)if(o[l]===t[l])s[l]=1;else if(e.shape[l]!==1)throw new Error(`broadcastTo(): [${n}] cannot be broadcast to [${t}].`);if(s.map((l,c)=>l>1?c:-1).filter(l=>l>=0).length===0)return kn(e);let a={x:e},u={reps:s};return _.runKernel(Yn,a,u)}var ja=N({broadcastTo_:UH});function HH(r){let e={x:C(r,"x","ceil","float32")};return _.runKernel(es,e)}var hh=N({ceil_:HH});function qH(r,t,e){let n=C(r,"x","clipByValue");A(t<=e,()=>`Error in clip: min (${t}) must be less than or equal to max (${e}).`);let o={x:n},s={clipValueMin:t,clipValueMax:e};return _.runKernel(ao,o,s)}var br=N({clipByValue_:qH});function KH(r){return se(r,0)}var RI=N({concat1d_:KH});function jH(r,t){return se(r,t)}var FI=N({concat2d_:jH});function XH(r,t){return se(r,t)}var OI=N({concat3d_:XH});function YH(r,t){return se(r,t)}var MI=N({concat4d_:YH});function ZH(r,t,e,n,o="NHWC",s=[1,1],i){let a=C(r,"x","conv2d","float32"),u=C(t,"filter","conv2d","float32"),l=a,c=!1;a.rank===3&&(c=!0,l=O(a,[1,a.shape[0],a.shape[1],a.shape[2]])),A(l.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${l.rank}.`),A(u.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${u.rank}.`),Te("conv2d",n,i);let p=o==="NHWC"?l.shape[3]:l.shape[1];A(p===u.shape[2],()=>`Error in conv2d: depth of input (${p}) must match input depth for filter ${u.shape[2]}.`),A($r(e,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${s}'`);let m={x:l,filter:u},f={strides:e,pad:n,dataFormat:o,dilations:s,dimRoundingMode:i},d=_.runKernel(rs,m,f);return c?O(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var pn=N({conv2d_:ZH});function JH(r,t,e,n,o="NWC",s=1,i){let a=C(r,"x","conv1d"),u=C(t,"filter","conv1d"),l=a,c=!1;a.rank===2&&(c=!0,l=O(a,[1,a.shape[0],a.shape[1]])),A(l.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${l.rank}.`),A(u.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${u.rank}.`),Te("conv1d",n,i),A(l.shape[2]===u.shape[1],()=>`Error in conv1d: depth of input (${l.shape[2]}) must match input depth for filter ${u.shape[1]}.`),A($r(e,s),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${e} and dilation '${s}'`),A(o==="NWC",()=>`Error in conv1d: got dataFormat of ${o} but only NWC is currently supported.`);let p=O(u,[1,u.shape[0],u.shape[1],u.shape[2]]),m=O(l,[l.shape[0],1,l.shape[1],l.shape[2]]),g=pn(m,p,[1,e],n,"NHWC",[1,s],i);return c?O(g,[g.shape[2],g.shape[3]]):O(g,[g.shape[0],g.shape[2],g.shape[3]])}var Yu=N({conv1d_:JH});function QH(r,t,e,n,o,s="NHWC",i){A(r.length===t.rank,()=>`Length of inShape (${r.length}) and rank of dy (${t.rank}) must match`);let a=r,u=t,l=!1;t.rank===3&&(l=!0,u=O(t,[1,t.shape[0],t.shape[1],t.shape[2]]),a=[1,r[0],r[1],r[2]]),A(a.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${a.length}.`),A(u.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${u.rank}`),A(e.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${e.rank}`);let c=s==="NHWC"?a[3]:a[1],p=s==="NHWC"?u.shape[3]:u.shape[1];A(c===e.shape[2],()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${e.shape[2]}.`),A(p===e.shape[3],()=>`Error in conv2dDerInput: depth of output (${p}) must match output depth for filter ${e.shape[3]}.`),Te("conv2dDerInput",o,i);let m={dy:u,filter:e},f={strides:n,pad:o,dataFormat:s,dimRoundingMode:i,inputShape:a},d=_.runKernel(ns,m,f);return l?O(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var hm=N({conv2DBackpropInput_:QH});function tq(r,t,e,n,o,s){let i=C(r,"x","conv2dTranspose"),a=C(t,"filter","conv2dTranspose");return hm(e,i,a,n,o,"NHWC",s)}var Zu=N({conv2dTranspose_:tq});function eq(r,t,e,n,o="NDHWC",s=[1,1,1]){let i=C(r,"x","conv3d"),a=C(t,"filter","conv3d"),u=i,l=!1;i.rank===4&&(l=!0,u=O(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),A(u.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${u.rank}.`),A(a.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${a.rank}.`),A(u.shape[4]===a.shape[3],()=>`Error in conv3d: depth of input (${u.shape[4]}) must match input depth for filter ${a.shape[3]}.`),A($r(e,s),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${e} and dilations '${s}'`),A(o==="NDHWC",()=>`Error in conv3d: got dataFormat of ${o} but only NDHWC is currently supported.`);let c={x:u,filter:a},p={strides:e,pad:n,dataFormat:o,dilations:s},m=_.runKernel(Rl,c,p);return l?O(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}var gh=N({conv3d_:eq});function rq(r,t,e,n,o){A(r.length===t.rank,()=>`Length of inShape (${r.length}) and rank of dy (${t.rank}) must match`);let s=r,i=t,a=!1;t.rank===4&&(a=!0,i=O(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),s=[1,r[0],r[1],r[2],r[3]]);let u=s[4],l=i.shape[4];A(s.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${s.length}.`),A(i.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${i.rank}`),A(e.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${e.rank}`),A(u===e.shape[3],()=>`Error in conv3dDerInput: depth of input (${u}) must match input depth for filter ${e.shape[3]}.`),A(l===e.shape[4],()=>`Error in conv3dDerInput: depth of output (${l}) must match output depth for filter ${e.shape[4]}.`);let c={dy:i,filter:e},p={pad:o,strides:n,inputShape:s},m=_.runKernel(Rp,c,p);return a?O(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}var Fx=N({conv3DBackpropInput_:rq});function nq(r,t,e,n,o){let s=C(r,"x","conv3dTranspose"),i=C(t,"filter","conv3dTranspose");return Fx(e,s,i,n,o)}var PI=N({conv3dTranspose_:nq});function oq(r){let e={x:C(r,"x","cos","float32")};return _.runKernel(os,e)}var Xa=N({cos_:oq});function sq(r){let e={x:C(r,"x","cosh","float32")};return _.runKernel(ss,e)}var Ju=N({cosh_:sq});function iq(r,t=0,e=!1,n=!1){let s={x:C(r,"x","cumprod")},i={axis:t,exclusive:e,reverse:n};return _.runKernel(ua,s,i)}var xh=N({cumprod_:iq});function aq(r,t=0,e=!1,n=!1){let s={x:C(r,"x","cumsum")},i={axis:t,exclusive:e,reverse:n};return _.runKernel(is,s,i)}var Qu=N({cumsum_:aq});function lq(r,t,e,n=!1){let o=C(r,"x","denseBincount"),s=C(t,"weights","denseBincount");A(o.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${o.dtype}`),A(o.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${o.rank}.`),A(e>=0,()=>`size must be non-negative, but got ${e}.`),A(s.size===o.size||s.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${o.shape}, weights shape: ${s.shape}.`);let i={x:o,weights:s},a={size:e,binaryOutput:n};return _.runKernel(Fp,i,a)}var LI=N({denseBincount_:lq});function uq(r,t,e="NHWC"){let n=C(r,"x","depthToSpace","float32"),o=e==="NHWC"?n.shape[1]:n.shape[2],s=e==="NHWC"?n.shape[2]:n.shape[3],i=e==="NHWC"?n.shape[3]:n.shape[1];A(t>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`),A(o*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${o} and ${t}  for depthToSpace with input shape
    ${n.shape}`),A(s*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${s} and ${t} for depthToSpace with input shape
        ${n.shape}`),A(i%(t*t)===0,()=>`Dimension size must be evenly divisible by ${t*t} but is ${i} for depthToSpace with input shape ${n.shape}`);let a={x:n},u={blockSize:t,dataFormat:e};return _.runKernel(pa,a,u)}var yh=N({depthToSpace_:uq});function cq(r,t,e,n,o="NHWC",s=[1,1],i){let a=C(r,"x","depthwiseConv2d","float32"),u=C(t,"filter","depthwiseConv2d","float32"),l=a,c=!1;a.rank===3&&(c=!0,l=O(a,[1,a.shape[0],a.shape[1],a.shape[2]])),A(l.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${l.rank}.`),A(u.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${u.rank}.`),A(l.shape[3]===u.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`),Te("depthwiseConv2d",n,i);let p={x:l,filter:u},m={strides:e,pad:n,dataFormat:o,dilations:s,dimRoundingMode:i},f=_.runKernel(as,p,m);return c?O(f,[f.shape[1],f.shape[2],f.shape[3]]):f}var Ys=N({depthwiseConv2d_:cq});function pq(r){let e={x:C(r,"x","diag")};return _.runKernel(Pp,e)}var mq=N({diag_:pq});function fq(r,t,e,n,o=[1,1],s="NHWC"){let i=C(r,"x","dilation2d"),a=C(t,"filter","dilation2d");A(i.rank===3||i.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`),A(a.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${a.rank}.`),A(s==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${s}`);let u=i,l=!1;i.rank===3&&(u=O(i,[1,i.shape[0],i.shape[1],i.shape[2]]),l=!0);let c={x:u,filter:a},p={strides:e,pad:n,dilations:o},m=_.runKernel(Fl,c,p);return l?O(m,[m.shape[1],m.shape[2],m.shape[3]]):m}var bh=N({dilation2d_:fq});function dq(r,t){let e=C(r,"a","equal","string_or_numeric"),n=C(t,"b","equal","string_or_numeric");[e,n]=jt(e,n),zt(e.shape,n.shape);let o={a:e,b:n};return _.runKernel(fa,o)}var Sr=N({equal_:dq});function hq(r,t,e){let n=C(t,"a","where"),o=C(e,"b","where"),s=C(r,"condition","where","bool"),i=zt(zt(s.shape,n.shape),o.shape),a=ja(s,i),u=ja(n,i),l=ja(o,i),c={condition:a,t:u,e:l};return _.runKernel(_i,c)}var _e=N({where_:hq});function gq(r){let e={x:C(r,"x","zerosLike")};return _.runKernel(Ri,e)}var St=N({zerosLike_:gq});function xq(r,t){let e=C(r,"a","div"),n=C(t,"b","div");[e,n]=jt(e,n);let o=ct(e,n),s=St(o),i=Sr(n,s);return _e(i,s,o)}var wh=N({divNoNan_:xq});function yq(r,t){let e=C(r,"t1","dot"),n=C(t,"t2","dot");A((e.rank===1||e.rank===2)&&(n.rank===1||n.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${e.rank} and ${n.rank}.`);let o=e.rank===1?e.size:e.shape[1],s=n.rank===1?n.size:n.shape[0];if(A(o===s,()=>`Error in dot: inner dimensions of inputs must match, but got ${o} and ${s}.`),e.rank===1&&n.rank===1){let i=O(e,[1,-1]),a=O(n,[-1,1]),u=Lt(i,a);return O(u,[])}else if(e.rank===1&&n.rank===2){let i=O(e,[1,-1]),a=O(n,[n.shape[0],n.shape[1]]),u=Lt(i,a);return O(u,[u.size])}else if(e.rank===2&&n.rank===1){let i=O(n,[-1,1]),a=Lt(e,i);return O(a,[a.size])}else{let i=O(n,[n.shape[0],n.shape[1]]);return Lt(e,i)}}var zI=N({dot_:yq});function bq(r,...t){let e=t.map((o,s)=>C(o,`tensors${s}`,"einsum")),n={equation:r};return _.runKernel(Lp,e,n)}var BI=N({einsum_:bq});function wq(r){let e={x:C(r,"x","elu","float32")};return _.runKernel(us,e)}var Zs=N({elu_:wq});function vq(r){let t=C(r,"x","erf");A(t.dtype==="int32"||t.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),t.dtype==="int32"&&(t=Z(t,"float32"));let e={x:t};return _.runKernel(ma,e)}var vh=N({erf_:vq});function Cq(r){let e={x:C(r,"x","exp")};return _.runKernel(cs,e)}var Ze=N({exp_:Cq});function Iq(r,t=0){let e=C(r,"x","expandDims","string_or_numeric");A(t<=e.rank,()=>"Axis must be <= rank of the tensor");let n={input:e},o={dim:t};return _.runKernel(Ci,n,o)}var fr=N({expandDims_:Iq});function Sq(r){let e={x:C(r,"x","expm1")};return _.runKernel(da,e)}var Ch=N({expm1_:Sq});function kq(r,t){let e=C(r,"x","tile","string_or_numeric");A(e.rank===t.length,()=>`Error in transpose: rank of input ${e.rank} must match length of reps ${t}.`);let n={x:e},o={reps:t};return _.runKernel(Yn,n,o)}var kr=N({tile_:kq});function Nq(r,t,e,n="float32"){t==null&&(t=r);let o=It([r,t],n),s=r<=t?r:t;for(let a=0;a<s;++a)o.set(1,a,a);let i=O(o.toTensor(),[r,t]);if(e==null)return i;if(e.length===1)return kr(fr(i,0),[e[0],1,1]);if(e.length===2)return kr(fr(fr(i,0),0),[e[0],e[1],1,1]);if(e.length===3)return kr(fr(fr(fr(i,0),0),0),[e[0],e[1],e[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${e.length}D.`)}var gm=N({eye_:Nq});function Js(r,t,e){let n={shape:r,value:t,dtype:e};return _.runKernel(Ol,{},n)}function Tq(r){let e={x:C(r,"x","floor","float32")};return _.runKernel(ps,e)}var Qs=N({floor_:Tq});function _q(r,t,e=0,n=0){let o=C(r,"x","gather"),s=C(t,"indices","gather","int32"),i={x:o,indices:s},a={axis:e,batchDims:n};return _.runKernel(Ii,i,a)}var yo=N({gather_:_q});function Eq(r,t){let e=C(r,"a","greater","string_or_numeric"),n=C(t,"b","greater","string_or_numeric");[e,n]=jt(e,n),zt(e.shape,n.shape);let o={a:e,b:n};return _.runKernel(xa,o)}var Ge=N({greater_:Eq});function Aq(r,t){let e=C(r,"a","greaterEqual","string_or_numeric"),n=C(t,"b","greaterEqual","string_or_numeric");[e,n]=jt(e,n),zt(e.shape,n.shape);let o={a:e,b:n};return _.runKernel(ds,o)}var Tn=N({greaterEqual_:Aq});function $q(r){let e={input:C(r,"input","imag")};return _.runKernel(Gp,e)}var tc=N({imag_:$q});function Dq(r){let e={x:C(r,"x","isFinite")};return _.runKernel(ya,e)}var VI=N({isFinite_:Dq});function Rq(r){let e={x:C(r,"x","isInf")};return _.runKernel(ba,e)}var GI=N({isInf_:Rq});function Fq(r){let e={x:C(r,"x","isNaN")};return _.runKernel(wa,e)}var Ih=N({isNaN_:Fq});function Oq(r,t=.2){let n={x:C(r,"x","leakyRelu")},o={alpha:t};return _.runKernel(hs,n,o)}var Ya=N({leakyRelu_:Oq});function Mq(r,t){let e=C(r,"a","less","string_or_numeric"),n=C(t,"b","less","string_or_numeric");[e,n]=jt(e,n),zt(e.shape,n.shape);let o={a:e,b:n};return _.runKernel(va,o)}var ec=N({less_:Mq});function Pq(r,t){let e=C(r,"a","lessEqual","string_or_numeric"),n=C(t,"b","lessEqual","string_or_numeric");[e,n]=jt(e,n),zt(e.shape,n.shape);let o={a:e,b:n};return _.runKernel(Ca,o)}var _n=N({lessEqual_:Pq});function WI(r,t,e){if(e<=0)throw new Error("The number of values should be positive.");let n={start:r,stop:t,num:e};return _.runKernel(Wp,{},n)}function Lq(r,t=5,e=1,n=1,o=.5){let s=C(r,"x","localResponseNormalization");A(s.rank===4||s.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${s.rank}.`),A(Qi(t),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);let i=s,a=!1;s.rank===3&&(a=!0,i=O(s,[1,s.shape[0],s.shape[1],s.shape[2]]));let u={x:i},l={depthRadius:t,bias:e,alpha:n,beta:o},c=_.runKernel(Ml,u,l);return a?O(c,[c.shape[1],c.shape[2],c.shape[3]]):c}var Sh=N({localResponseNormalization_:Lq});function zq(r){let e={x:C(r,"x","log","float32")};return _.runKernel(gs,e)}var wr=N({log_:zq});function Bq(r){let e={x:C(r,"x","log1p")};return _.runKernel(Ia,e)}var Za=N({log1p_:Bq});function Vq(r){return A(xi(r),()=>"The f passed in grad(f) must be a function"),(t,e)=>{let n=C(t,"x","tf.grad","string_or_numeric"),o=e!=null?C(e,"dy","tf.grad"):null;return _.tidy(()=>{let{value:s,grads:i}=_.gradients(()=>r(n),[n],o);return o!=null&&Me(s.shape,o.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),Mx(i),i[0]})}}function Gq(r){return A(xi(r),()=>"The f passed in grads(f) must be a function"),(t,e)=>{A(Array.isArray(t),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");let n=Wa(t,"args","tf.grads","string_or_numeric"),o=e!=null?C(e,"dy","tf.grads"):null;return _.tidy(()=>{let{value:s,grads:i}=_.gradients(()=>r(...n),n,o);return o!=null&&Me(s.shape,o.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),Mx(i),i})}}function Wq(r){return A(xi(r),()=>"The f passed in valueAndGrad(f) must be a function"),(t,e)=>{A(t instanceof Pt,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),A(e==null||e instanceof Pt,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");let{grads:n,value:o}=_.gradients(()=>r(t),[t],e);return Mx(n),{grad:n[0],value:o}}}function Uq(r){return A(xi(r),()=>"The f passed in valueAndGrads(f) must be a function"),(t,e)=>{A(Array.isArray(t)&&t.every(o=>o instanceof Pt),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),A(e==null||e instanceof Pt,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");let n=_.gradients(()=>r(...t),t,e);return e!=null&&Me(n.value.shape,e.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),Mx(n.grads),n}}function Ox(r,t){A(xi(r),()=>"The f passed in variableGrads(f) must be a function"),A(t==null||Array.isArray(t)&&t.every(l=>l instanceof Ga),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");let e=t!=null;if(!e){t=[];for(let l in _.registeredVariables)t.push(_.registeredVariables[l])}let n=e?t.filter(l=>!l.trainable):null,o=t.length;t=t.filter(l=>l.trainable),A(t.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${o} variables is trainable.`);let s=!0,{value:i,grads:a}=_.gradients(r,t,null,s);A(a.some(l=>l!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),A(i.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${i.rank} tensor`);let u={};return t.forEach((l,c)=>{a[c]!=null&&(u[l.name]=a[c])}),n!=null&&n.forEach(l=>u[l.name]=null),{value:i,grads:u}}function mn(r){return _.customGrad(r)}function Mx(r){if(r.filter(e=>e==null).length>0)throw new Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that
    the f you passed encloses all operations that lead from x to y.`)}function Hq(r){let e={x:C(r,"x","neg")};return _.runKernel(Si,e)}var Zt=N({neg_:Hq});function qq(r){let e={x:C(r,"x","softplus")};return _.runKernel(Ma,e)}var bo=N({softplus_:qq});function Kq(r){let t=C(r,"x","logSigmoid");return mn(n=>({value:Zt(bo(Zt(n))),gradFunc:i=>M(i,Lr(Zt(n)))}))(t)}var UI=N({logSigmoid_:Kq});function jq(r,t=null,e=!1){let o={x:C(r,"x","max")},s={reductionIndices:t,keepDims:e};return _.runKernel(xs,o,s)}var Dr=N({max_:jq});function Xq(r,t){let e=C(r,"a","sub"),n=C(t,"b","sub");[e,n]=jt(e,n);let o={a:e,b:n};return _.runKernel(Vs,o)}var lt=N({sub_:Xq});function Yq(r,t=null,e=!1){let n=C(r,"x","sum");n.dtype==="bool"&&(n=Z(n,"int32"));let o={x:n},s={axis:t,keepDims:e};return _.runKernel(Ls,o,s)}var mt=N({sum_:Yq});function Zq(r,t=-1){let e=C(r,"logits","logSoftmax");if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and axis was ${t}`);return mn((o,s)=>{let a=Dr(o,t,!0),u=lt(o,a),l=lt(Z(u,"float32"),wr(mt(Ze(u),t,!0)));return s([l]),{value:l,gradFunc:(p,m)=>{let[f]=m,d=!0,h=Ze(f);return lt(p,M(mt(p,t,d),h))}}})(e)}var rc=N({logSoftmax_:Zq});function HI(r,t){for(let e=0;e<r.length;++e)if(r[r.length-e-1]!==t-1-e)return!1;return!0}function K_(r,t,e){let n=r.length+t.length,o=[],s=0,i=0;for(let a=0;a<n;a++)e.indexOf(a)===-1?o.push(r[s++]):o.push(t[i++]);return o}function qI(r,t){let e=[],n=r.length;for(let s=0;s<n;s++)t.indexOf(s)===-1&&e.push(r[s]);let o=t.map(s=>r[s]);return[e,o]}function wo(r,t){let e=t.map(n=>1);return K_(r,e,t)}function Jq(r,t,e){A(HI(t,e),()=>`${r} supports only inner-most axes for now. Got axes ${t} and rank-${e} input.`)}function KI(r,t){if(HI(r,t))return null;let e=[];for(let n=0;n<t;++n)r.indexOf(n)===-1&&e.push(n);return r.forEach(n=>e.push(n)),e}function kh(r){return r.map((t,e)=>[e,t]).sort((t,e)=>t[1]-e[1]).map(t=>t[0])}function Qq(r,t){let e=[];for(let n=t-r;n<t;++n)e.push(n);return e}function tK(r,t=null,e=!1){let n=C(r,"x","logSumExp"),o=mr(t,n.shape),s=Dr(n,o,!0),i=lt(n,s),a=Ze(i),u=mt(a,o),l=wr(u),c=J(O(s,l.shape),l);if(e){let p=wo(c.shape,o);return O(c,p)}return c}var Nh=N({logSumExp_:tK});function eK(r,t){let e=C(r,"a","logicalAnd","bool"),n=C(t,"b","logicalAnd","bool");zt(e.shape,n.shape);let o={a:e,b:n};return _.runKernel(Sa,o)}var Nr=N({logicalAnd_:eK});function rK(r){let e={x:C(r,"x","logicalNot","bool")};return _.runKernel(Ou,e)}var Ja=N({logicalNot_:rK});function nK(r,t){let e=C(r,"a","logicalOr","bool"),n=C(t,"b","logicalOr","bool");zt(e.shape,n.shape);let o={a:e,b:n};return _.runKernel(Mu,o)}var nc=N({logicalOr_:nK});function oK(r,t){let e=C(r,"a","logicalXor","bool"),n=C(t,"b","logicalXor","bool");return zt(e.shape,n.shape),Nr(nc(r,t),Ja(Nr(r,t)))}var XI=N({logicalXor_:oK});function sK(r,t,e,n,o){let s=C(r,"x","maxPool"),i=1,a=s,u=!1;s.rank===3&&(u=!0,a=O(s,[1,s.shape[0],s.shape[1],s.shape[2]])),A(a.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${a.rank}.`),A($r(e,i),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${e} and dilations '${i}'`),Te("maxPool",n,o);let l={x:a},c={filterSize:t,strides:e,pad:n,dimRoundingMode:o},p=_.runKernel(bs,l,c);return u?O(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var Qa=N({maxPool_:sK});function iK(r,t=[1,1,1],e,n,o,s="NDHWC"){let i=C(r,"x","maxPool3d"),a=i,u=!1;i.rank===4&&(u=!0,a=O(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),A(a.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${a.rank}.`),A(s==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),Te("maxPool3d",n,o);let l={x:a},c={filterSize:t,strides:e,pad:n,dimRoundingMode:o,dataFormat:s},p=_.runKernel(Pl,l,c);return u?O(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}var Th=N({maxPool3d_:iK});function aK(r,t,e,n,o=!1){let i={x:C(r,"x","maxPoolWithArgmax")},a={filterSize:t,strides:e,pad:n,includeBatchInIndex:o},u=_.runKernel(Kp,i,a);return{result:u[0],indexes:u[1]}}var YI=N({maxPoolWithArgmax_:aK});function lK(r,t){let e=C(r,"a","maximum"),n=C(t,"b","maximum");[e,n]=jt(e,n),e.dtype==="bool"&&(e=Z(e,"int32"),n=Z(n,"int32")),zt(e.shape,n.shape);let o={a:e,b:n};return _.runKernel(ys,o)}var fn=N({maximum_:lK});function uK(r,t=null,e=!1){let o={x:C(r,"x","mean")},s={axis:t,keepDims:e};return _.runKernel(ws,o,s)}var xe=N({mean_:uK});function ye(r,t="float32"){if(t==="complex64"){let n=ye(r,"float32"),o=ye(r,"float32");return zn(n,o)}let e=kp(re(r),t);return _.makeTensor(e,r,t)}function lr(r,t="float32"){if(t==="complex64"){let n=lr(r,"float32"),o=ye(r,"float32");return zn(n,o)}let e=Ld(re(r),t);return _.makeTensor(e,r,t)}function cK(r,t,{indexing:e="xy"}={}){if(e!=="xy"&&e!=="ij")throw new TypeError(`${e} is not a valid third argument to meshgrid`);if(r===void 0)return[];let n=C(r,"x","meshgrid",r instanceof Pt?r.dtype:"float32");if(t===void 0)return[n];let o=C(t,"y","meshgrid",t instanceof Pt?t.dtype:"float32"),s=re(n.shape),i=re(o.shape);return e==="xy"?(n=O(n,[1,-1]),o=O(o,[-1,1]),[Lt(lr([i,1],n.dtype),n),Lt(o,lr([1,s],o.dtype))]):(n=O(n,[-1,1]),o=O(o,[1,-1]),[Lt(n,lr([1,i],n.dtype)),Lt(lr([s,1],o.dtype),o)])}function pK(r,t=null,e=!1){let o={x:C(r,"x","min")},s={axis:t,keepDims:e};return _.runKernel(vs,o,s)}var Zl=N({min_:pK});function mK(r,t){let e=C(r,"a","minimum"),n=C(t,"b","minimum");[e,n]=jt(e,n),e.dtype==="bool"&&(e=Z(e,"int32"),n=Z(n,"int32")),zt(e.shape,n.shape);let o={a:e,b:n};return _.runKernel(Cs,o)}var ti=N({minimum_:mK});function fK(r,t,e){A(e==="reflect"||e==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${e}.`);let n=C(r,"x","mirrorPad");if(n.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");A(t.length===n.rank,()=>`Padding doesn't match input. Must be ${n.rank}. Got ${t.length}.`);let o=e==="reflect"?1:0;for(let a=0;a<n.rank;a++)A(t[a].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),A(t[a][0]>=0&&t[a][0]<=n.shape[a]-o&&t[a][1]>=0&&t[a][1]<=n.shape[a]-o,()=>`Padding in dimension ${a} cannot be greater than or equal to ${n.shape[a]-o} or less than 0 for input of shape ${n.shape}`);let s={paddings:t,mode:e},i={x:n};return _.runKernel(Is,i,s)}var _h=N({mirrorPad_:fK});function dK(r,t){let e=C(r,"a","mod"),n=C(t,"b","mod");[e,n]=jt(e,n);let o={a:e,b:n};return _.runKernel(ka,o)}var Eh=N({mod_:dK});function hK(r){let t=C(r,"x","square"),e={};return _.runKernel("Square",{x:t},e)}var Ut=N({square_:hK});function gK(r,t=null,e=!1){r=C(r,"x","moments");let n=mr(t,r.shape),o=xe(r,n,e),s=o.shape;e||(s=wo(o.shape,n));let i=Ut(lt(Z(r,"float32"),O(o,s))),a=xe(i,n,e);return{mean:o,variance:a}}var xm=N({moments_:gK});function xK(r,t,e,n){let o=C(t,"data","multiRNNCell"),s=Wa(e,"c","multiRNNCell"),i=Wa(n,"h","multiRNNCell"),a=o,u=[];for(let p=0;p<r.length;p++){let m=r[p](a,s[p],i[p]);u.push(m[0]),u.push(m[1]),a=m[1]}let l=[],c=[];for(let p=0;p<u.length;p+=2)l.push(u[p]),c.push(u[p+1]);return[l,c]}var yK=N({multiRNNCell_:xK});function bK(r,t,e,n=!1){let o=C(r,"logits","multinomial"),s=o.size,i=o.rank;if(s<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${s}.`);if(i>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${i}`);e=e||Math.random();let u={logits:i===1?O(o,[1,-1]):o},l={numSamples:t,seed:e,normalized:n},c=_.runKernel(jp,u,l);return i===1?O(c,[c.size]):c}var ZI=N({multinomial_:bK});function wK(r,t){let e=C(r,"a","notEqual","string_or_numeric"),n=C(t,"b","notEqual","string_or_numeric");[e,n]=jt(e,n),zt(e.shape,n.shape);let o={a:e,b:n};return _.runKernel(Na,o)}var vo=N({notEqual_:wK});function vK(r){let e={x:C(r,"x","onesLike")};return _.runKernel(ki,e)}var dr=N({onesLike_:vK});function CK(r,t){let e=C(r,"v1","outerProduct"),n=C(t,"v2","outerProduct");A(e.rank===1&&n.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${e.rank} and ${n.rank}.`);let o=O(e,[-1,1]),s=O(n,[1,-1]);return Lt(o,s)}var IK=N({outerProduct_:CK});function SK(r,t,e=0){let n=C(r,"x","pad");if(n.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");let o={paddings:t,constantValue:e},s={x:n};return _.runKernel(Ns,s,o)}var Yr=N({pad_:SK});function kK(r,t,e=0){return A(t.length===2,()=>"Invalid number of paddings. Must be length of 2."),Yr(r,[t],e)}var NK=N({pad1d_:kK});function TK(r,t,e=0){return A(t.length===2&&t[0].length===2&&t[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Yr(r,t,e)}var _K=N({pad2d_:TK});function EK(r,t,e=0){return A(t.length===3&&t[0].length===2&&t[1].length===2&&t[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Yr(r,t,e)}var AK=N({pad3d_:EK});function $K(r,t,e=0){return A(t.length===4&&t[0].length===2&&t[1].length===2&&t[2].length===2&&t[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Yr(r,t,e)}var DK=N({pad4d_:$K});function RK(r,t,e){let n=C(r,"x","spaceToBatchND");A(n.rank>=1+t.length,()=>`input rank ${n.rank} should be > than [blockShape] ${t.length}`),A(e.length===t.length,()=>`paddings.shape[0] ${e.length} must be equal to [blockShape] ${t.length}`),A(n.shape.reduce((i,a,u)=>u>0&&u<=t.length?i&&(a+e[u-1][0]+e[u-1][1])%t[u-1]===0:i,!0),()=>`input spatial dimensions ${n.shape.slice(1)} with paddings ${e.toString()} must be divisible by blockShapes ${t.toString()}`);let o={x:n},s={blockShape:t,paddings:e};return _.runKernel(Ai,o,s)}var tl=N({spaceToBatchND_:RK});function FK(r,t,e,n,o,s,i){o==null&&(o=[1,1]),s==null&&(s=1),n===0&&(n="valid");let a=C(r,"x","maxPool"),u=a,l=!1;a.rank===3&&(l=!0,u=O(a,[1,a.shape[0],a.shape[1],a.shape[2]])),A($r(s,o),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${s} and dilations '${o}'`);let c=TI(u.shape,t,s,o,n),p=[c.dilationHeight,c.dilationWidth],m;n==="same"?m=MK([c.filterHeight,c.filterWidth],p):m=[[0,0],[0,0]];let f=p[0]===1&&p[1]===1,[d,h]=OK([c.inHeight,c.inWidth],p,m),g=f?n:"valid",y=f?u:tl(u,p,d),w=(e==="avg"?()=>qa(y,t,s,g,i):()=>Qa(y,t,s,g,i))(),v=f?w:Ka(w,p,h);return l?O(v,[v.shape[1],v.shape[2],v.shape[3]]):v}function OK(r,t,e){let n=e.map(c=>c[0]),o=e.map(c=>c[1]),s=r.concat(n,o),i=t.map((c,p)=>(c-s[p]%c)%c),a=o.map((c,p)=>c+i[p]),u=t.map((c,p)=>[n[p],a[p]]),l=t.map((c,p)=>[0,i[p]]);return[u,l]}function MK(r,t){let n=r.map((i,a)=>i+(i-1)*(t[a]-1)).map(i=>i-1),o=n.map(i=>Math.floor(i/2)),s=n.map((i,a)=>i-o[a]);return n.map((i,a)=>[o[a],s[a]])}var JI=N({pool_:FK});function PK(r,t){let e=C(r,"base","pow"),n=C(t,"exp","pow");[e,n]=jt(e,n);let o={a:e,b:n};return _.runKernel(Ts,o)}var Zr=N({pow_:PK});function LK(r,t){let e=C(r,"x","prelu"),n=C(t,"alpha","prelu"),o={x:e,alpha:n};return _.runKernel(_s,o)}var el=N({prelu_:LK});function zK(r,t=null,e=!1){let n=C(r,"x","prod");n.dtype==="bool"&&(n=Z(n,"int32"));let o={x:n},s={axis:t,keepDims:e};return _.runKernel(Aa,o,s)}var oc=N({prod_:zK});function BK(r,t,e){let n=re(r),o=null;if(e==null||e==="float32")o=new Float32Array(n);else if(e==="int32")o=new Int32Array(n);else if(e==="bool")o=new Uint8Array(n);else throw new Error(`Unknown data type ${e}`);for(let s=0;s<n;s++)o[s]=t();return _.makeTensor(o,r,e)}var VK=N({rand_:BK});var Bx=Du(iS());var ic=class{constructor(t,e,n,o,s){this.mean=t,this.stdDev=e,this.dtype=n,this.nextVal=NaN,this.truncated=o,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);let i=s||Math.random();this.random=Bx.alea(i.toString())}nextValue(){if(!isNaN(this.nextVal)){let o=this.nextVal;return this.nextVal=NaN,o}let t,e,n=!1;for(;!n;){let o,s,i;do o=2*this.random()-1,s=2*this.random()-1,i=o*o+s*s;while(i>=1||i===0);let a=Math.sqrt(-2*Math.log(i)/i);t=this.mean+this.stdDev*o*a,e=this.mean+this.stdDev*s*a,(!this.truncated||this.isValidTruncated(t))&&(n=!0)}return(!this.truncated||this.isValidTruncated(e))&&(this.nextVal=this.convertValue(e)),this.convertValue(t)}convertValue(t){return this.dtype==null||this.dtype==="float32"?t:Math.round(t)}isValidTruncated(t){return t<=this.upper&&t>=this.lower}},Lx=class{constructor(t,e,n,o){this.alpha=t,this.beta=1/e,this.dtype=n;let s=o||Math.random();this.randu=Bx.alea(s.toString()),this.randn=new ic(0,1,n,!1,this.randu()),t<1?this.d=t+2/3:this.d=t-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let t,e,n,o,s,i;for(;;){do o=this.randn.nextValue(),i=1+this.c*o;while(i<=0);if(i*=i*i,t=o*o,e=1-.331*t*t,n=.5*t+this.d*(1-i+Math.log(i)),s=this.randu(),s<e||Math.log(s)<n)break}return i=1/this.beta*this.d*i,this.alpha<1&&(i*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(i)}convertValue(t){return this.dtype==="float32"?t:Math.round(t)}},zx=class{constructor(t=0,e=1,n,o){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=t,this.range=e-t,this.dtype=n,o==null&&(o=Math.random()),typeof o=="number"&&(o=o.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${t} - ${e} <= 1 and dtype is not float`);this.random=Bx.alea(o)}convertValue(t){return this.canReturnFloat()?t:Math.round(t)}nextValue(){return this.convertValue(this.min+this.range*this.random())}};function jK(r,t,e=1,n="float32",o){if(e==null&&(e=1),n==null&&(n="float32"),n!=="float32"&&n!=="int32")throw new Error(`Unsupported data type ${n}`);let s=new Lx(t,e,n,o),i=It(r,n);for(let a=0;a<i.values.length;a++)i.values[a]=s.nextValue();return i.toTensor()}var XK=N({randomGamma_:jK});function YK(r,t=0,e=1,n,o){if(n!=null&&n==="bool")throw new Error(`Unsupported data type ${n}`);let s=new ic(t,e,n,!1,o),i=It(r,n);for(let a=0;a<i.values.length;a++)i.values[a]=s.nextValue();return i.toTensor()}var Vx=N({randomNormal_:YK});function ZK(r,t=0,e=1,n="float32",o){let s=It(r,n),i=new zx(t,e,null,o);for(let a=0;a<s.values.length;a++)s.values[a]=i.nextValue();return s.toTensor()}var ei=N({randomUniform_:ZK});function rl(r,t,e=1,n="float32"){if(e===0)throw new Error("Cannot have a step of zero");let o={start:r,stop:t,step:e,dtype:n};return _.runKernel(Ll,{},o)}function JK(r){let e={input:C(r,"input","real")};return _.runKernel(Xp,e)}var Jl=N({real_:JK});function QK(r){let e={x:C(r,"x","reciprocal")};return _.runKernel($a,e)}var Ah=N({reciprocal_:QK});function tj(r){let e={x:C(r,"x","relu")};return _.runKernel(Es,e)}var Tr=N({relu_:tj});function ej(r){let e={x:C(r,"x","relu6")};return _.runKernel($s,e)}var ac=N({relu6_:ej});function rj(r,t){let n={x:C(r,"x","reverse")},o={dims:t};return _.runKernel(Ds,n,o)}var ir=N({reverse_:rj});function nj(r){let t=C(r,"x","reverse");return A(t.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`),ir(t,0)}var oj=N({reverse1d_:nj});function sj(r,t){let e=C(r,"x","reverse");return A(e.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${e.rank}.`),ir(e,t)}var ij=N({reverse2d_:sj});function aj(r,t){let e=C(r,"x","reverse");return A(e.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${e.rank}.`),ir(e,t)}var lj=N({reverse3d_:aj});function uj(r,t){let e=C(r,"x","reverse");return A(e.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${e.rank}.`),ir(e,t)}var cj=N({reverse4d_:uj});function pj(r){let e={x:C(r,"x","round")};return _.runKernel(Rs,e)}var lc=N({round_:pj});function mj(r){let e={x:C(r,"x","rsqrt","float32")};return _.runKernel(Fs,e)}var uc=N({rsqrt_:mj});function pt(r,t){if((yr(r)&&t!=="string"||Array.isArray(r))&&t!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(t==="string"&&yr(r)&&!(r instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return cn(r,[],[],t)}function fj(r){let e={x:C(r,"x","selu")};return _.runKernel(Ra,e)}var cc=N({selu_:fj});function dj(r,t,e,n,o,s=[1,1],i="NHWC"){let a=C(r,"x","separableConv2d"),u=C(t,"depthwiseFilter","separableConv2d"),l=C(e,"pointwiseFilter","separableConv2d"),c=a,p=!1;if(a.rank===3&&(p=!0,c=O(a,[1,a.shape[0],a.shape[1],a.shape[2]])),i==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");A(c.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`),A(u.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${u.rank}.`),A(l.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${u.rank}.`),A(l.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${l.shape[0]}.`),A(l.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${l.shape[1]}.`);let m=u.shape[2],f=u.shape[3];A(l.shape[2]===m*f,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${m*f}, but got ${l.shape[2]}.`);let d=Ys(c,u,n,o,i,s),g=pn(d,l,1,"valid",i);return p?O(g,[g.shape[1],g.shape[2],g.shape[3]]):g}var $h=N({separableConv2d_:dj});async function hj(r,t){let e=C(r,"x","setdiff1d"),n=C(t,"y","setdiff1d");A(e.dtype===n.dtype,()=>`x and y should have the same dtype, but got x (${e.dtype}) and y (${n.dtype}).`),A(e.rank===1,()=>`x should be 1D tensor, but got x (${e.shape}).`),A(n.rank===1,()=>`y should be 1D tensor, but got y (${n.shape}).`);let o=await e.data(),s=await n.data(),i=new Set(s),a=0;for(let c=0;c<o.length;c++)i.has(o[c])||a++;let u=new pe([a],e.dtype),l=new pe([a],"int32");for(let c=0,p=0;c<o.length;c++)i.has(o[c])||(u.values[p]=o[c],l.values[p]=c,p++);return[u.toTensor(),l.toTensor()]}var aS=hj;function gj(r){let e={x:C(r,"x","sign")};return _.runKernel(Oa,e)}var Dh=N({sign_:gj});function xj(r){let e={x:C(r,"x","sin","float32")};return _.runKernel(Os,e)}var pc=N({sin_:xj});function yj(r){let e={x:C(r,"x","sinh")};return _.runKernel(Fa,e)}var mc=N({sinh_:yj});function bj(r,t,e){let n=C(r,"x","slice1d");return A(n.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${n.rank} tensor`),Rt(n,[t],[e])}var Rh=N({slice1d_:bj});function wj(r,t,e){let n=C(r,"x","slice2d");return A(n.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${n.rank} tensor`),Rt(n,t,e)}var Gx=N({slice2d_:wj});function vj(r,t,e){let n=C(r,"x","slice3d");return A(n.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${n.rank} tensor`),Rt(n,t,e)}var Fh=N({slice3d_:vj});function Cj(r,t,e){let n=C(r,"x","slice4d");return A(n.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${n.rank} tensor`),Rt(n,t,e)}var ym=N({slice4d_:Cj});function Ij(r,t=-1){let e=C(r,"logits","softmax","float32");if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and dim was ${t}`);let n={logits:e},o={dim:t};return _.runKernel(zs,n,o)}var nl=N({softmax_:Ij});function Sj(r){A(r.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${r.dtype}.`);let t={input:r};return _.runKernel(Bp,t)}var ol=N({fft_:Sj});function kj(r){A(r.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${r.dtype}.`);let t={input:r};return _.runKernel(Vp,t)}var Gi=N({ifft_:kj});function Nj(r){let t=r.shape[r.shape.length-1],e=r.size/t,n;if(t<=2){let o=O(r,[e,t]);n=Gi(o)}else{let o=[e,2*(t-1)],s=O(Jl(r),[e,t]),i=O(tc(r),[e,t]),a=ir(Rt(s,[0,1],[e,t-2]),1),u=M(ir(Rt(i,[0,1],[e,t-2]),1),pt(-1)),l=se([s,a],1),c=se([i,u],1),p=O(zn(l,c),[o[0],o[1]]);n=Gi(p)}if(n=Jl(n),r.rank===3&&r.shape[0]!==0){let o=n,s=r.shape[0];n=O(n,[s,n.shape[0]/s,n.shape[1]]),o.dispose()}return n}var fc=N({irfft_:Nj});function Tj(r,t,e=0){let o={x:C(r,"x","split")},s={numOrSizeSplits:t,axis:e};return _.runKernel($i,o,s)}var ur=N({split_:Tj});function _j(r,t){A(r.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${r.dtype}`);let e=r.shape[r.shape.length-1],n=r.size/e,o;if(t!=null&&t<e){let d=r.shape.map(g=>0),h=r.shape.map(g=>g);h[r.shape.length-1]=t,o=Rt(r,d,h),e=t}else if(t!=null&&t>e){let d=r.shape.map(h=>h);d[r.shape.length-1]=t-e,o=se([r,ye(d)],r.shape.length-1),e=t}else o=r;let s=St(o),i=O(zn(o,s),[n,e]),a=ol(i),u=Math.floor(e/2)+1,l=Jl(a),c=tc(a),p=ur(l,[u,e-u],l.shape.length-1),m=ur(c,[u,e-u],c.shape.length-1),f=o.shape.slice();return f[o.shape.length-1]=u,O(zn(p[0],m[0]),f)}var sl=N({rfft_:_j});function Ej(r){let e={x:C(r,"x","sqrt","float32")};return _.runKernel(Ps,e)}var be=N({sqrt_:Ej});function Aj(r,t){let e=C(r,"a","squaredDifference"),n=C(t,"b","squaredDifference");[e,n]=jt(e,n),zt(e.shape,n.shape);let o={a:e,b:n},s={};return _.runKernel(Bs,o,s)}var dc=N({squaredDifference_:Aj});function $j(r,t){let e=C(r,"x","squeeze");return O(e,$C(e.shape,t).newShape)}var zr=N({squeeze_:$j});function Dj(r,t=0){let e=Wa(r,"tensors","stack","string_or_numeric");A(e.length>=1,()=>"Pass at least one tensor to tf.stack"),e.length>0&&A(t<=e[0].rank,()=>"Axis must be <= rank of the tensor");let n=e,o={axis:t};return _.runKernel(Ni,n,o)}var Je=N({stack_:Dj});function Rj(r,t=0){let n={x:C(r,"x","step")},o={alpha:t};return _.runKernel(uo,n,o)}var ri=N({step_:Rj});function Fj(r,t,e,n,o=0,s=0,i=0,a=0,u=0){let c={x:C(r,"x","stridedSlice","string_or_numeric")},p={begin:t,end:e,strides:n,beginMask:o,endMask:s,ellipsisMask:i,newAxisMask:a,shrinkAxisMask:u};return _.runKernel(La,c,p)}var Oh=N({stridedSlice_:Fj});function Oj(r){let e={x:C(r,"x","tan","float32")};return _.runKernel(Gs,e)}var Mh=N({tan_:Oj});function Re(r,t){jn(r);let e=Or(r,t);if(e.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return cn(r,null,e,t)}function Wi(r,t,e){if(jn(r),t!=null&&t.length!==2)throw new Error("tensor2d() requires shape to have two numbers");let n=Or(r,e);if(n.length!==2&&n.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(n.length===1&&t==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return cn(r,t,n,e)}function Mj(r,t,e){if(jn(r),t!=null&&t.length!==4)throw new Error("tensor4d() requires shape to have four numbers");let n=Or(r,e);if(n.length!==4&&n.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(n.length===1&&t==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return cn(r,t,n,e)}function Pj(r,t,e){if(jn(r),t!=null&&t.length!==5)throw new Error("tensor5d() requires shape to have five numbers");let n=Or(r,e);if(n.length!==5&&n.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(n.length===1&&t==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return cn(r,t,n,e)}function Lj(r,t,e){if(jn(r),t!=null&&t.length!==6)throw new Error("tensor6d() requires shape to have six numbers");let n=Or(r,e);if(n.length!==6&&n.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(n.length===1&&t==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return t=t||n,cn(r,t,n,e)}function zj(r,t=1,e=!0){let n=C(r,"x","topk");if(n.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");let o=n.shape[n.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>o)throw new Error(`'k' passed to topk() must be <= the last dimension (${o}) but got ${t}`);let s={x:n},i={k:t,sorted:e},[a,u]=_.runKernel(za,s,i);return{values:a,indices:u}}var Ph=N({topk_:zj});function Bj(r,t=0,e=1,n,o){if(n!=null&&n==="bool")throw new Error("Unsupported data type $ { dtype }");let s=new ic(t,e,n,!0,o),i=It(r,n);for(let a=0;a<i.values.length;a++)i.values[a]=s.nextValue();return i.toTensor()}var hc=N({truncatedNormal_:Bj});function Vj(r,t=0){let e=C(r,"x","unique","string_or_numeric");A(e.rank>0,()=>"The input tensor must be at least 1D");let n={x:e},o={axis:t},[s,i]=_.runKernel(rm,n,o);return{values:s,indices:i}}var bm=N({unique_:Vj});function Gj(r,t,e){let n=C(r,"x","unsortedSegmentSum"),o=C(t,"segmentIds","unsortedSegmentSum","int32");A(Qi(e),()=>"numSegments must be of dtype int");let s={x:n,segmentIds:o},i={numSegments:e};return _.runKernel(Ul,s,i)}var Lh=N({unsortedSegmentSum_:Gj});function Wj(r,t=0){let e=C(r,"x","unstack","string_or_numeric");A(t>=-e.shape.length&&t<e.shape.length,()=>`Axis = ${t} is not in [-${e.shape.length}, ${e.shape.length})`);let n={value:e},o={axis:t};return _.runKernel(Di,n,o)}var vr=N({unstack_:Wj});function lS(r,t=!0,e,n){return _.makeVariable(r,t,e,n)}function Wx(r,t){let e=[];for(let s=0;s<t.length;s++)t[s]&&e.push(s);let n=It(r,"int32"),o=It([e.length,r.length],"int32");for(let s=0;s<e.length;s++){let i=n.indexToLoc(e[s]),a=s*r.length;o.values.set(i,a)}return o.toTensor()}async function Uj(r){let t=C(r,"condition","whereAsync","bool"),e=await t.data(),n=Wx(t.shape,e);return r!==t&&t.dispose(),n}var zh=Uj;async function Hj(r,t,e){let n=C(r,"tensor","boolMask"),o=C(t,"mask","boolMask","bool"),s=e==null?0:e,i=o.rank,a=n.shape;A(i>0,()=>"mask cannot be scalar"),Me(a.slice(s,s+i),o.shape,"mask's shape must match the first K dimensions of tensor's shape,");let u=1;for(let h=s;h<s+i;h++)u*=a[h];let l=a.slice(0,s).concat([u],a.slice(s+i)),c=O(n,l),p=O(o,[-1]),m=await zh(p),f=zr(m,[1]),d=yo(c,f,s);return r!==n&&n.dispose(),t!==o&&o.dispose(),f.dispose(),c.dispose(),p.dispose(),m.dispose(),d}var QTt=Hj;function qj(r,t="euclidean",e=null,n=!1){r=C(r,"x","norm");let o=lE(r,t,e),s=o.shape;if(n){let i=mr(e,r.shape);s=wo(o.shape,i)}return O(o,s)}function lE(r,t,e=null){if(r.rank===0)return Ne(r);if(r.rank!==1&&e===null)return lE(O(r,[-1]),t,e);if(r.rank===1||typeof e=="number"||Array.isArray(e)&&e.length===1){if(t===1)return mt(Ne(r),e);if(t===1/0)return Dr(Ne(r),e);if(t===-1/0)return Zl(Ne(r),e);if(t==="euclidean"||t===2)return be(mt(Zr(Ne(r),pt(2,"int32")),e));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(e)&&e.length===2){if(t===1)return Dr(mt(Ne(r),e[0]),e[1]-1);if(t===1/0)return Dr(mt(Ne(r),e[1]),e[0]);if(t===-1/0)return Zl(mt(Ne(r),e[1]),e[0]);if(t==="fro"||t==="euclidean")return be(mt(Ut(r),e));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${e}`)}var wm=N({norm_:qj});function Kj(r,t,e,n,o=!0){let s=C(r,"v","movingAverage"),i=C(t,"x","movingAverage"),a=C(e,"decay","movingAverage");QC(s,i),A(Mn(s.shape,i.shape),()=>"Shape mismatch in v and x");let u=pt(1),l=lt(u,a),c=M(lt(i,s),l);if(o){A(n!=null,()=>"When using zeroDebias: true, step is required.");let p=C(n,"step","movingAverage");c=ct(c,lt(u,Zr(a,p)))}return J(s,c)}var I1t=N({movingAverage_:Kj});function jj(r,t,e){let n=C(r,"indices","scatterND","int32"),o=C(t,"updates","scatterND");$x(o,n,e);let s={indices:n,updates:o},i={shape:e};return _.runKernel(Da,s,i)}var uE=N({scatterND_:jj});function cE(r,t,e,n){if(r.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${r.dtype}.`);if(r.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${r.shape}.`);let o=r.rank>0?r.shape[0]:1,s=r.rank>1?r.shape[1]:1;if(e.length!==s)throw new Error(`outputShape has incorrect number of elements:, ${e.length}, should be: ${s}.`);let i=t.size;if(!(t.rank===0||t.rank===1&&i===o))throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${o}]`);if(t.dtype!==n.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}function Yj(r,t,e,n=0){let o=C(r,"sparseIndices","sparseToDense","int32"),s=C(t,"sparseValues","sparseToDense"),i=C(n,"defaultValue","sparseToDense",s.dtype);cE(o,s,e,i);let a={sparseIndices:o,sparseValues:s,defaultValue:i},u={outputShape:e};return _.runKernel(Jp,a,u)}var Ux=N({sparseToDense_:Yj});function Zj(r,t){let e=C(t,"indices","gatherND","int32"),o={params:C(r,"x","gatherND","string_or_numeric"),indices:e};return _.runKernel(ga,o)}var pE=N({gatherND_:Zj});function mE(r,t){if(t==null)return r.shape.slice();if(Mn(r.shape,t))return t;if(r.shape.length===t.length){let e=[];for(let n=0;n<r.shape.length;n++)t[n]==null&&r.shape[n]!=null?e.push(r.shape[n]):e.push(t[n]);return e}return t}function Jj(r,t,e,n){let o=C(r,"x","dropout");if(A(o.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${o.dtype} tensor instead.`),A(t>=0&&t<1,()=>`rate must be a float in the range [0, 1), but got ${t}.`),t===0)return r instanceof Pt?o.clone():o;let s=mE(o,e),i=1-t,a=ct(Qs(J(ei(s,0,1,"float32",n),i)),i);return M(o,a)}var fE=N({dropout_:Jj});function dE(r){return Math.floor(Math.pow(2,Math.ceil(Math.log(r)/Math.log(2))))}function Hx(r,t,e){let n=1-r%2,o=new Float32Array(r);for(let s=0;s<r;++s){let i=2*Math.PI*s/(r+n-1);o[s]=t-e*Math.cos(i)}return Re(o,"float32")}async function Qj(r,t,e=1){let n=C(r,"predictions","inTopK"),o=C(t,"targets","inTopK");A(n.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${n.rank}`),A(n.rank-1===o.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${n.rank} and targets rank ${o.rank}`),Me(n.shape.slice(0,n.shape.length-1),o.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");let s=n.shape[n.shape.length-1];A(e>0&&e<=s,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${s}), but got ${e}`);let i=await n.data(),a=await o.data(),[u,l]=[i.length/s,s],c=DC("bool",u);for(let p=0;p<u;p++){let m=p*l,f=i.subarray(m,m+l),d=[];for(let h=0;h<f.length;h++)d.push({value:f[h],index:h});d.sort((h,g)=>g.value-h.value),c[p]=0;for(let h=0;h<e;h++)if(d[h].index===a[p]){c[p]=1;break}}return r!==n&&n.dispose(),t!==o&&o.dispose(),Ar(c,o.shape,"bool")}var r_t=Qj;var Co={};Yt(Co,{conv2d:()=>hE,depthwiseConv2d:()=>gE,matMul:()=>xE});function t6(r,t,e,n,o,s="NHWC",i){let a=r;r.rank===3&&(a=O(r,[1,r.shape[0],r.shape[1],r.shape[2]]));let u=t;u.rank===3&&(u=O(t,[1,t.shape[0],t.shape[1],t.shape[2]])),A(a.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${a.shape}.`),A(u.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${u.shape}.`),A(e.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${e}.`);let l=s==="NHWC"?a.shape[3]:a.shape[1],c=s==="NHWC"?u.shape[3]:u.shape[1];A(l===e[2],()=>`Error in conv2dDerFilter: depth of input ${l}) must match input depth in filter (${e[2]}.`),A(c===e[3],()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${e[3]}).`),Te("conv2dDerFilter",o,i);let p={x:a,dy:u},m={strides:n,pad:o,dataFormat:s,dimRoundingMode:i,filterShape:e};return _.runKernel($p,p,m)}var vm=N({conv2DBackpropFilter_:t6});function gc(r,t,e){if(e==null||e==="linear")return r;if(e==="relu")return M(r,ri(t));throw new Error(`Cannot compute gradient for fused activation ${e}.`)}function xc(r,t){let e=t,n=ge(r.shape,t.shape);return n.length>0&&(e=mt(e,n)),O(e,r.shape)}function yc(r,t,e,n){if(t==="linear")return r;if(t==="relu")return Tr(r);if(t==="elu")return Zs(r);if(t==="relu6")return ac(r);if(t==="prelu")return el(r,e);if(t==="leakyrelu")return Ya(r,n);if(t==="sigmoid")return Lr(r);throw new Error(`Unknown fused activation ${t}.`)}var bc=(r,t)=>!(r>0)||t==="linear";function e6({x:r,filter:t,strides:e,pad:n,dataFormat:o="NHWC",dilations:s=[1,1],dimRoundingMode:i,bias:a,activation:u="linear",preluActivationWeights:l,leakyreluAlpha:c}){if(u=u||"linear",bc(_.state.gradientDepth,u)===!1){let k=pn(r,t,e,n,o,s,i);return a!=null&&(k=J(k,a)),yc(k,u,l,c)}let p=C(r,"x","conv2d","float32"),m=C(t,"filter","conv2d","float32"),f=p,d=!1;p.rank===3&&(d=!0,f=O(p,[1,p.shape[0],p.shape[1],p.shape[2]])),A(f.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${f.rank}.`),A(m.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${m.rank}.`),Te("fused conv2d",n,i),A(f.shape[3]===m.shape[2],()=>`Error in conv2d: depth of input (${f.shape[3]}) must match input depth for filter ${m.shape[2]}.`),A($r(e,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${s}'`),A(o==="NHWC",()=>`Error in conv2d: got dataFormat of ${o} but only NHWC is currently supported.`);let h=Xu(f.shape,m.shape,e,s,n,i),g;a!=null&&(g=C(a,"bias","fused conv2d"),[g]=jt(g,p),zt(h.outShape,g.shape));let y;l!=null&&(y=C(l,"prelu weights","fused conv2d"));let b=(k,E)=>{let[$,D,R,P]=E,W=gc(k,R,u);A(Zn(s),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);let U=hm(D.shape,W,$,e,n),q=vm(D,W,$.shape,e,n),K=[U,q];if(P!=null){let j=xc(P,W);K.push(j)}return K},w={x:f,filter:m,bias:g,preluActivationWeights:y},v={strides:e,pad:n,dataFormat:o,dilations:s,dimRoundingMode:i,activation:u,leakyreluAlpha:c};return a==null?mn((E,$,D)=>{let R=_.runKernel(Oi,w,v);return D([$,E,R]),d&&(R=O(R,[R.shape[1],R.shape[2],R.shape[3]])),{value:R,gradFunc:b}})(f,m):mn((E,$,D,R)=>{let P=_.runKernel(Oi,w,v);return R([$,E,P,D]),d&&(P=O(P,[P.shape[1],P.shape[2],P.shape[3]])),{value:P,gradFunc:b}})(f,m,g)}var hE=N({fusedConv2d_:e6});function r6(r,t,e,n,o,s=[1,1],i){let a=r;r.rank===3&&(a=O(r,[1,r.shape[0],r.shape[1],r.shape[2]]));let u=t;u.rank===3&&(u=O(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let l={x:a,dy:u},c={strides:n,pad:o,dimRoundingMode:i,dilations:s,filterShape:e};return _.runKernel(Op,l,c)}var qx=N({depthwiseConv2dNativeBackpropFilter_:r6});function n6(r,t,e,n,o,s=[1,1],i){let a=t,u=!1;t.rank===3&&(u=!0,a=O(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let l={dy:a,filter:e},c={strides:n,pad:o,dimRoundingMode:i,dilations:s,inputShape:r},p=_.runKernel(Mp,l,c);return u?O(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var Kx=N({depthwiseConv2dNativeBackpropInput_:n6});function o6({x:r,filter:t,strides:e,pad:n,dataFormat:o="NHWC",dilations:s=[1,1],dimRoundingMode:i,bias:a,activation:u="linear",preluActivationWeights:l,leakyreluAlpha:c}){if(bc(_.state.gradientDepth,u)===!1){let k=Ys(r,t,e,n,o,s,i);return a!=null&&(k=J(k,a)),yc(k,u,l,c)}let p=C(r,"x","depthwiseConv2d","float32"),m=C(t,"filter","depthwiseConv2d","float32"),f=p,d=!1;p.rank===3&&(d=!0,f=O(p,[1,p.shape[0],p.shape[1],p.shape[2]])),A(f.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${f.rank}.`),A(m.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${m.rank}.`),A(f.shape[3]===m.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${f.shape[3]}) must match the inChannels dimension in filter ${m.shape[2]}.`),s==null&&(s=[1,1]),A($r(e,s),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${e} and dilations '${s}'`),Te("fused depthwiseConv2d",n,i);let h=Xu(f.shape,m.shape,e,s,n,i,!0),g;a!=null&&(g=C(a,"bias","fused conv2d"),[g]=jt(g,p),zt(h.outShape,g.shape));let y;l!=null&&(y=C(l,"prelu weights","fused depthwiseConv2d"));let b=(k,E)=>{A(Zn(s),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${s}'`);let[$,D,R,P]=E,W=gc(k,R,u),U=Kx(D.shape,W,$,e,n,s,i),q=qx(D,W,$.shape,e,n,s,i);if(P!=null){let K=xc(g,W);return[U,q,K]}return[U,q]},w={x:f,filter:m,bias:g,preluActivationWeights:y},v={strides:e,pad:n,dataFormat:o,dilations:s,dimRoundingMode:i,activation:u,leakyreluAlpha:c};return a==null?mn((E,$,D)=>{let R=_.runKernel(Mi,w,v);return D([$,E,R]),d&&(R=O(R,[R.shape[1],R.shape[2],R.shape[3]])),{value:R,gradFunc:b}})(f,m):mn((E,$,D,R)=>{let P=_.runKernel(Mi,w,v);return R([$,E,P,D]),d&&(P=O(P,[P.shape[1],P.shape[2],P.shape[3]])),{value:P,gradFunc:b}})(f,m,g)}var gE=N({fusedDepthwiseConv2d_:o6});function s6({a:r,b:t,transposeA:e=!1,transposeB:n=!1,bias:o,activation:s="linear",preluActivationWeights:i,leakyreluAlpha:a}){if(bc(_.state.gradientDepth,s)===!1){let W=Lt(r,t,e,n);return o!=null&&(W=J(W,o)),yc(W,s,i,a)}let u=C(r,"a","fused matMul"),l=C(t,"b","fused matMul");[u,l]=jt(u,l);let c=e?u.shape[u.rank-2]:u.shape[u.rank-1],p=n?l.shape[l.rank-1]:l.shape[l.rank-2],m=e?u.shape[u.rank-1]:u.shape[u.rank-2],f=n?l.shape[l.rank-2]:l.shape[l.rank-1],d=u.shape.slice(0,-2),h=l.shape.slice(0,-2),g=re(d),y=re(h);A(c===p,()=>`Error in fused matMul: inner shapes (${c}) and (${p}) of Tensors with shapes ${u.shape} and ${l.shape} and transposeA=${e} and transposeB=${n} must match.`);let w=zt(u.shape.slice(0,-2),l.shape.slice(0,-2)).concat([m,f]),v=e?O(u,[g,c,m]):O(u,[g,m,c]),k=n?O(l,[y,f,p]):O(l,[y,p,f]),E;o!=null&&(E=C(o,"bias","fused matMul"),[E]=jt(E,u),zt(w,E.shape));let $;i!=null&&($=C(i,"prelu weights","fused matMul"));let D=(W,U)=>{let[q,K,j,Q]=U,rt=gc(O(W,j.shape),j,s),X,ot;if(!e&&!n?(X=Lt(rt,K,!1,!0),ot=Lt(q,rt,!0,!1)):!e&&n?(X=Lt(rt,K,!1,!1),ot=Lt(rt,q,!0,!1)):e&&!n?(X=Lt(K,rt,!1,!0),ot=Lt(q,rt,!1,!1)):(X=Lt(K,rt,!0,!0),ot=Lt(rt,q,!0,!0)),o!=null){let st=xc(Q,rt);return[X,ot,st]}else return[X,ot]},R={a:v,b:k,bias:E,preluActivationWeights:$},P={transposeA:e,transposeB:n,activation:s,leakyreluAlpha:a};return o==null?mn((U,q,K)=>{let j=_.runKernel(Fi,R,P);return K([U,q,j]),{value:O(j,w),gradFunc:D}})(v,k):mn((U,q,K,j)=>{let Q=_.runKernel(Fi,R,P);return j([U,q,Q,K]),{value:O(Q,w),gradFunc:D}})(v,k,E)}var xE=N({fusedMatMul_:s6});function i6(r){return Hx(r,.54,.46)}var yE=N({hammingWindow_:i6});function a6(r){return Hx(r,.5,.5)}var jx=N({hannWindow_:a6});function l6(r,t,e,n=!1,o=0){let s=0,i=[];for(;s+t<=r.size;)i.push(Rt(r,s,t)),s+=e;if(n)for(;s<r.size;){let a=s+t-r.size,u=se([Rt(r,s,t-a),Js([a],o)]);i.push(u),s+=e}return i.length===0?Wi([],[0,t]):O(se(i),[i.length,t])}var Xx=N({frame_:l6});function u6(r,t,e,n,o=jx){n==null&&(n=dE(t));let s=Xx(r,t,e),i=M(s,o(t));return sl(i,n)}var bE=N({stft_:u6});function c6(r,t,e,n,o="bilinear",s=0){let i=C(r,"image","cropAndResize"),a=C(t,"boxes","cropAndResize","float32"),u=C(e,"boxInd","cropAndResize","int32"),l=a.shape[0];A(i.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`),A(a.rank===2&&a.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${l},4] but had shape ${a.shape}.`),A(u.rank===1&&u.shape[0]===l,()=>`Error in cropAndResize: boxInd must be have size [${l}] but had shape ${a.shape}.`),A(n.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${n.length}.`),A(n[0]>=1&&n[1]>=1,()=>`cropSize must be atleast [1,1], but was ${n}`),A(o==="bilinear"||o==="nearest",()=>`method must be bilinear or nearest, but was ${o}`);let c={image:i,boxes:a,boxInd:u},p={method:o,extrapolationValue:s,cropSize:n};return _.runKernel(ca,c,p)}var wE=N({cropAndResize_:c6});function p6(r){let t=C(r,"image","flipLeftRight","float32");A(t.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`);let e={image:t};return _.runKernel(ha,e,{})}var vE=N({flipLeftRight_:p6});function m6(r){let t=C(r,"image","grayscaleToRGB"),e=t.rank-1,n=t.shape[e];A(t.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`),A(n===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${n}.`);let o=new Array(t.rank);return o.fill(1,0,e),o[e]=3,kr(t,o)}var CE=N({grayscaleToRGB_:m6});function f6(r,t,e=0,n=.5){let o=C(r,"image","rotateWithOffset","float32");A(o.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${o.rank}.`);let s={image:o},i={radians:t,fillValue:e,center:n};return _.runKernel(Va,s,i)}var IE=N({rotateWithOffset_:f6});function Io(r,t,e,n,o,s){n==null&&(n=.5),o==null&&(o=Number.NEGATIVE_INFINITY),s==null&&(s=0);let i=r.shape[0];return e=Math.min(e,i),A(0<=n&&n<=1,()=>`iouThreshold must be in [0, 1], but was '${n}'`),A(r.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${r.rank}'`),A(r.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${r.shape[1]}`),A(t.rank===1,()=>"scores must be a 1D tensor"),A(t.shape[0]===i,()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${t.shape[0]}`),A(0<=s&&s<=1,()=>`softNmsSigma must be in [0, 1], but was '${s}'`),{maxOutputSize:e,iouThreshold:n,scoreThreshold:o,softNmsSigma:s}}function d6(r,t,e,n=.5,o=Number.NEGATIVE_INFINITY){let s=C(r,"boxes","nonMaxSuppression","float32"),i=C(t,"scores","nonMaxSuppression","float32"),a=Io(s,i,e,n,o);e=a.maxOutputSize,n=a.iouThreshold,o=a.scoreThreshold;let u={maxOutputSize:e,iouThreshold:n,scoreThreshold:o};return _.runKernel(Ta,{boxes:s,scores:i},u)}var SE=N({nonMaxSuppression_:d6});function kE(r,t,e){let n=h6(r,t,e),o=n<0?-(n+1):n;r.splice(o,0,t)}function h6(r,t,e){return x6(r,t,e||g6)}function g6(r,t){return r>t?1:r<t?-1:0}function x6(r,t,e){let n=0,o=r.length,s=0,i=!1;for(;n<o;){s=n+(o-n>>>1);let a=e(t,r[s]);a>0?n=s+1:(o=s,i=!a)}return i?n:-n-1}function Yx(r,t,e,n,o){return uS(r,t,e,n,o,0)}function Zx(r,t,e,n,o,s){return uS(r,t,e,n,o,0,!1,s,!0)}function Jx(r,t,e,n,o,s){return uS(r,t,e,n,o,s,!0)}function uS(r,t,e,n,o,s,i=!1,a=!1,u=!1){let l=[];for(let g=0;g<t.length;g++)t[g]>o&&l.push({score:t[g],boxIndex:g,suppressBeginIndex:0});l.sort(NE);let c=s>0?-.5/s:0,p=[],m=[];for(;p.length<e&&l.length>0;){let g=l.pop(),{score:y,boxIndex:b,suppressBeginIndex:w}=g;if(y<o)break;let v=!1;for(let k=p.length-1;k>=w;--k){let E=y6(r,b,p[k]);if(E>=n){v=!0;break}if(g.score=g.score*b6(n,c,E),g.score<=o)break}g.suppressBeginIndex=p.length,v||(g.score===y?(p.push(b),m.push(g.score)):g.score>o&&kE(l,g,NE))}let f=p.length,d=e-f;a&&d>0&&(p.push(...new Array(d).fill(0)),m.push(...new Array(d).fill(0)));let h={selectedIndices:p};return i&&(h.selectedScores=m),u&&(h.validOutputs=f),h}function y6(r,t,e){let n=r.subarray(t*4,t*4+4),o=r.subarray(e*4,e*4+4),s=Math.min(n[0],n[2]),i=Math.min(n[1],n[3]),a=Math.max(n[0],n[2]),u=Math.max(n[1],n[3]),l=Math.min(o[0],o[2]),c=Math.min(o[1],o[3]),p=Math.max(o[0],o[2]),m=Math.max(o[1],o[3]),f=(a-s)*(u-i),d=(p-l)*(m-c);if(f<=0||d<=0)return 0;let h=Math.max(s,l),g=Math.max(i,c),y=Math.min(a,p),b=Math.min(u,m),w=Math.max(y-h,0)*Math.max(b-g,0);return w/(f+d-w)}function b6(r,t,e){let n=Math.exp(t*e*e);return e<=r?n:0}function NE(r,t){return r.score-t.score||r.score===t.score&&t.boxIndex-r.boxIndex}async function w6(r,t,e,n=.5,o=Number.NEGATIVE_INFINITY){let s=C(r,"boxes","nonMaxSuppressionAsync"),i=C(t,"scores","nonMaxSuppressionAsync"),a=Io(s,i,e,n,o);e=a.maxOutputSize,n=a.iouThreshold,o=a.scoreThreshold;let u=await Promise.all([s.data(),i.data()]),l=u[0],c=u[1],{selectedIndices:p}=Yx(l,c,e,n,o);return s!==r&&s.dispose(),i!==t&&i.dispose(),Re(p,"int32")}var TE=w6;function v6(r,t,e,n=.5,o=Number.NEGATIVE_INFINITY,s=0){let i=C(r,"boxes","nonMaxSuppression"),a=C(t,"scores","nonMaxSuppression"),u=Io(i,a,e,n,o,s);e=u.maxOutputSize,n=u.iouThreshold,o=u.scoreThreshold,s=u.softNmsSigma;let l={boxes:i,scores:a},c={maxOutputSize:e,iouThreshold:n,scoreThreshold:o,softNmsSigma:s},p=_.runKernel(Ea,l,c);return{selectedIndices:p[0],selectedScores:p[1]}}var _E=N({nonMaxSuppressionWithScore_:v6});async function C6(r,t,e,n=.5,o=Number.NEGATIVE_INFINITY,s=0){let i=C(r,"boxes","nonMaxSuppressionAsync"),a=C(t,"scores","nonMaxSuppressionAsync"),u=Io(i,a,e,n,o,s);e=u.maxOutputSize,n=u.iouThreshold,o=u.scoreThreshold,s=u.softNmsSigma;let l=await Promise.all([i.data(),a.data()]),c=l[0],p=l[1],{selectedIndices:m,selectedScores:f}=Jx(c,p,e,n,o,s);return i!==r&&i.dispose(),a!==t&&a.dispose(),{selectedIndices:Re(m,"int32"),selectedScores:Re(f)}}var EE=C6;function I6(r,t,e,n=.5,o=Number.NEGATIVE_INFINITY,s=!1){let i=C(r,"boxes","nonMaxSuppression"),a=C(t,"scores","nonMaxSuppression"),u=Io(i,a,e,n,o,null),l=u.maxOutputSize,c=u.iouThreshold,p=u.scoreThreshold,m={boxes:i,scores:a},f={maxOutputSize:l,iouThreshold:c,scoreThreshold:p,padToMaxOutputSize:s},d=_.runKernel(_a,m,f);return{selectedIndices:d[0],validOutputs:d[1]}}var AE=N({nonMaxSuppressionPadded_:I6});async function S6(r,t,e,n=.5,o=Number.NEGATIVE_INFINITY,s=!1){let i=C(r,"boxes","nonMaxSuppressionAsync"),a=C(t,"scores","nonMaxSuppressionAsync"),u=Io(i,a,e,n,o,null),l=u.maxOutputSize,c=u.iouThreshold,p=u.scoreThreshold,[m,f]=await Promise.all([i.data(),a.data()]),{selectedIndices:d,validOutputs:h}=Zx(m,f,l,c,p,s);return i!==r&&i.dispose(),a!==t&&a.dispose(),{selectedIndices:Re(d,"int32"),validOutputs:pt(h,"int32")}}var $E=S6;function k6(r,t,e=!1,n=!1){let o=C(r,"images","resizeBilinear");A(o.rank===3||o.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${o.rank}.`),A(t.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`),A(n===!1||e===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let s=o,i=!1;o.rank===3&&(i=!0,s=O(o,[1,o.shape[0],o.shape[1],o.shape[2]]));let[]=t,a={images:s},u={alignCorners:e,halfPixelCenters:n,size:t},l=_.runKernel(As,a,u);return i?O(l,[l.shape[1],l.shape[2],l.shape[3]]):l}var Qx=N({resizeBilinear_:k6});function N6(r,t,e=!1,n=!1){let o=C(r,"images","resizeNearestNeighbor");A(o.rank===3||o.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${o.rank}.`),A(t.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`),A(o.dtype==="float32"||o.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),A(n===!1||e===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let s=o,i=!1;o.rank===3&&(i=!0,s=O(o,[1,o.shape[0],o.shape[1],o.shape[2]]));let[]=t,a={images:s},u={alignCorners:e,halfPixelCenters:n,size:t},l=_.runKernel(zl,a,u);return i?O(l,[l.shape[1],l.shape[2],l.shape[3]]):l}var ty=N({resizeNearestNeighbor_:N6});function T6(r,t="binary",e=!1,n=.5){let o=C(r,"image","threshold"),s=.2989,i=.587,a=.114,u=o.shape[0]*o.shape[1],l=M(Re([n]),255),c,p,m,f;if(A(o.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${o.rank}.`),A(o.shape[2]===3||o.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${o.shape[2]}.`),A(o.dtype==="int32"||o.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${o.dtype}.`),A(t==="otsu"||t==="binary",()=>`Method must be binary or otsu, but was ${t}`),o.shape[2]===3){[c,p,m]=ur(o,[1,1,1],-1);let g=M(c,s),y=M(p,i),b=M(m,a);f=J(J(g,y),b)}else f=r;if(t==="otsu"){let g=dh(Z(lc(f),"int32"),Ar([]),256);l=_6(g,u)}let d=e?_n(f,l):Ge(f,l);return Z(M(d,255),"int32")}function _6(r,t){let e=Re([-1]),n=Re([0]),o=Re([0]),s,i,a,u,l,c;for(let p=0;p<r.size-1;p++){s=Rt(r,0,p+1),i=Rt(r,p+1),l=ct(mt(s),t),c=ct(mt(i),t);let m=mt(M(s,rl(0,s.size)));a=ct(m,mt(s));let f=Js(i.shape,s.size),d=J(rl(0,i.size),f),h=M(i,d);u=ct(mt(h),mt(i));let g=lt(a,u),y=lt(a,u),b=M(l,c);o=M(M(b,g),y);let w=Ge(o,n);n=_e(w,o,n),e=_e(w,Re([p]),e)}return e}var DE=N({threshold_:T6});function E6(r,t,e="nearest",n="constant",o=0,s){let i=C(r,"image","transform","float32"),a=C(t,"transforms","transform","float32");A(i.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`),A(a.rank===2&&(a.shape[0]===i.shape[0]||a.shape[0]===1)&&a.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),A(s==null||s.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${s}.`);let u={image:i,transforms:a},l={interpolation:e,fillMode:n,fillValue:o,outputShape:s};return _.runKernel(Ba,u,l)}var RE=N({transform_:E6});function A6(r,t,e){A(t%1===0,()=>`bandPart(): numLower must be an integer, got ${t}.`),A(e%1===0,()=>`bandPart(): numUpper must be an integer, got ${e}.`);let n=C(r,"a","bandPart");A(n.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${n.rank}.`);let o=n.shape,[s,i]=n.shape.slice(-2);if(!(t<=s))throw new Error(`bandPart(): numLower (${t}) must not be greater than the number of rows (${s}).`);if(!(e<=i))throw new Error(`bandPart(): numUpper (${e}) must not be greater than the number of columns (${i}).`);t<0&&(t=s),e<0&&(e=i);let a=O(rl(0,s,1,"int32"),[-1,1]),u=rl(0,i,1,"int32"),l=lt(a,u),c=Nr(_n(l,pt(+t,"int32")),Tn(l,pt(-e,"int32"))),p=ye([s,i],n.dtype);return O(Je(vr(O(n,[-1,s,i])).map(m=>_e(c,m,p))),o)}var FE=N({bandPart_:A6});function $6(r){let t;if(Array.isArray(r)){t=!1,A(r!=null&&r.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");let o=r[0].shape[0];for(let s=1;s<r.length;++s)A(r[s].shape[0]===o,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${r[s].shape[0]} vs. ${o})`)}else t=!0,r=ur(r,r.shape[0],0).map(o=>zr(o,[0]));A(r.length<=r[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${r.length}) exceeds number of dimensions (${r[0].shape[0]}).`);let e=[],n=r;for(let o=0;o<r.length;++o)e.push(_.tidy(()=>{let s=n[o];if(o>0)for(let i=0;i<o;++i){let a=M(mt(M(e[i],s)),e[i]);s=lt(s,a)}return ct(s,wm(s,"euclidean"))}));return t?Je(e,0):e}var OE=N({gramSchmidt_:$6});function D6(r,t=!1){if(A(r.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${r.rank}`),r.rank===2)return ME(r,t);{let e=r.shape.slice(0,r.shape.length-2).reduce((u,l)=>u*l),n=vr(O(r,[e,r.shape[r.shape.length-2],r.shape[r.shape.length-1]]),0),o=[],s=[];n.forEach(u=>{let[l,c]=ME(u,t);o.push(l),s.push(c)});let i=O(Je(o,0),r.shape),a=O(Je(s,0),r.shape);return[i,a]}}function ME(r,t=!1){return _.tidy(()=>{A(r.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${r.shape.length}D Tensor.`);let e=r.shape[0],n=r.shape[1],o=gm(e),s=kn(r),i=Wi([[1]],[1,1]),a=kn(i),u=e>=n?n:e;for(let l=0;l<u;++l){let c=s,p=a,m=o;[a,s,o]=_.tidy(()=>{let f=Rt(s,[l,l],[e-l,1]),d=wm(f),h=Rt(s,[l,l],[1,1]),g=_e(Ge(h,0),Wi([[-1]]),Wi([[1]])),y=lt(h,M(g,d)),b=ct(f,y);b.shape[0]===1?a=kn(i):a=se([i,Rt(b,[1,0],[b.shape[0]-1,b.shape[1]])],0);let w=Zt(ct(Lt(g,y),d)),v=Rt(s,[l,0],[e-l,n]),k=M(w,a),E=Wt(a);if(l===0)s=lt(v,Lt(k,Lt(E,v)));else{let R=lt(v,Lt(k,Lt(E,v)));s=se([Rt(s,[0,0],[l,n]),R],0)}let $=Wt(k),D=Rt(o,[0,l],[e,o.shape[1]-l]);if(l===0)o=lt(D,Lt(Lt(D,a),$));else{let R=lt(D,Lt(Lt(D,a),$));o=se([Rt(o,[0,0],[e,l]),R],1)}return[a,s,o]}),_t([c,p,m])}return!t&&e>n&&(o=Rt(o,[0,0],[e,n]),s=Rt(s,[0,0],[n,n])),[o,s]})}var PE=N({qr_:D6});var Qe;(function(r){r[r.NONE=0]="NONE",r[r.MEAN=1]="MEAN",r[r.SUM=2]="SUM",r[r.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(Qe||(Qe={}));function R6(r,t,e=Qe.SUM_BY_NONZERO_WEIGHTS){let n=C(r,"losses","computeWeightedLoss"),o=null;t!=null&&(o=C(t,"weights","computeWeightedLoss"));let s=o==null?n:M(n,o);if(e===Qe.NONE)return s;if(e===Qe.SUM)return mt(s);if(e===Qe.MEAN){if(o==null)return xe(s);{let i=n.size/o.size,a=ct(mt(s),mt(o));return i>1?ct(a,pt(i)):a}}if(e===Qe.SUM_BY_NONZERO_WEIGHTS){if(o==null)return ct(mt(s),pt(n.size));{let i=M(o,lr(n.shape)),a=Z(mt(vo(i,pt(0))),"float32");return ct(mt(s),a)}}throw Error(`Unknown reduction: ${e}`)}var Br=N({computeWeightedLoss_:R6});function F6(r,t,e,n=Qe.SUM_BY_NONZERO_WEIGHTS){let o=C(r,"labels","absoluteDifference"),s=C(t,"predictions","absoluteDifference"),i=null;e!=null&&(i=C(e,"weights","absoluteDifference")),Me(o.shape,s.shape,"Error in absoluteDifference: ");let a=Ne(lt(o,s));return Br(a,i,n)}var LE=N({absoluteDifference_:F6});function O6(r,t,e,n,o=Qe.SUM_BY_NONZERO_WEIGHTS){let s=C(r,"labels","cosineDistance"),i=C(t,"predictions","cosineDistance"),a=null;n!=null&&(a=C(n,"weights","cosineDistance")),Me(s.shape,i.shape,"Error in cosineDistance: ");let u=pt(1),l=lt(u,mt(M(s,i),e,!0));return Br(l,a,o)}var zE=N({cosineDistance_:O6});function M6(r,t,e,n=Qe.SUM_BY_NONZERO_WEIGHTS){let o=C(r,"labels","hingeLoss"),s=C(t,"predictions","hingeLoss"),i=null;e!=null&&(i=C(e,"weights","hingeLoss")),Me(o.shape,s.shape,"Error in hingeLoss: ");let a=pt(1);o=lt(M(pt(2),o),a);let u=Tr(lt(a,M(o,s)));return Br(u,i,n)}var BE=N({hingeLoss_:M6});function P6(r,t,e,n=1,o=Qe.SUM_BY_NONZERO_WEIGHTS){let s=C(r,"labels","huberLoss"),i=C(t,"predictions","huberLoss"),a=null;e!=null&&(a=C(e,"weights","huberLoss")),Me(s.shape,i.shape,"Error in huberLoss: ");let u=pt(n),l=Ne(lt(i,s)),c=ti(l,u),p=lt(l,c),m=J(M(pt(.5),Ut(c)),M(u,p));return Br(m,a,o)}var VE=N({huberLoss_:P6});function L6(r,t,e,n=1e-7,o=Qe.SUM_BY_NONZERO_WEIGHTS){let s=C(r,"labels","logLoss"),i=C(t,"predictions","logLoss"),a=null;e!=null&&(a=C(e,"weights","logLoss")),Me(s.shape,i.shape,"Error in logLoss: ");let u=pt(1),l=pt(n),c=Zt(M(s,wr(J(i,l)))),p=M(lt(u,s),wr(J(lt(u,i),l))),m=lt(c,p);return Br(m,a,o)}var GE=N({logLoss_:L6});function z6(r,t,e,n=Qe.SUM_BY_NONZERO_WEIGHTS){let o=C(r,"labels","meanSquaredError"),s=C(t,"predictions","meanSquaredError"),i=null;e!=null&&(i=C(e,"weights","meanSquaredError")),Me(o.shape,s.shape,"Error in meanSquaredError: ");let a=dc(o,s);return Br(a,i,n)}var WE=N({meanSquaredError_:z6});function B6(r,t){let e=C(r,"labels","sigmoidCrossEntropyWithLogits"),n=C(t,"logits","sigmoidCrossEntropyWithLogits");Me(e.shape,n.shape,"Error in sigmoidCrossEntropyWithLogits: ");let o=Tr(n),s=M(n,e),i=Za(Ze(Zt(Ne(n))));return J(lt(o,s),i)}function V6(r,t,e,n=0,o=Qe.SUM_BY_NONZERO_WEIGHTS){let s=C(r,"multiClassLabels","sigmoidCrossEntropy"),i=C(t,"logits","sigmoidCrossEntropy"),a=null;if(e!=null&&(a=C(e,"weights","sigmoidCrossEntropy")),Me(s.shape,i.shape,"Error in sigmoidCrossEntropy: "),n>0){let l=pt(n),c=pt(1),p=pt(.5);s=J(M(s,lt(c,l)),M(p,l))}let u=B6(s,i);return Br(u,a,o)}var UE=N({sigmoidCrossEntropy_:V6});function G6(r,t,e=-1){if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${e}`);return mn((o,s,i)=>{let u=Nh(s,[e],!0),l=lt(Z(s,"float32"),u);i([o,l]);let c=Zt(M(l,o));return{value:mt(c,[e]),gradFunc:(f,d)=>{let[h,g]=d,y=wo(f.shape,[e]);return[M(O(f,y),lt(Z(h,"float32"),Ze(g))),M(O(f,y),lt(Ze(g),Z(h,"float32")))]}}})(r,t)}function W6(r,t,e,n=0,o=Qe.SUM_BY_NONZERO_WEIGHTS){let s=C(r,"onehotLabels","softmaxCrossEntropy"),i=C(t,"logits","softmaxCrossEntropy"),a=null;if(e!=null&&(a=C(e,"weights","softmaxCrossEntropy")),Me(s.shape,i.shape,"Error in softmaxCrossEntropy: "),n>0){let l=pt(n),c=pt(1),p=pt(s.shape[1]);s=J(M(s,lt(c,l)),ct(l,p))}let u=G6(s,i);return Br(u,a,o)}var HE=N({softmaxCrossEntropy_:W6});function U6(r,t,e,n){let o=C(r,"indices","sparseFillEmptyRows","int32"),s=C(t,"values","sparseFillEmptyRows"),i=C(e,"denseShape","sparseFillEmptyRows","int32"),a=C(n,"defaultValue","sparseFillEmptyRows",s.dtype);if(o.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${o.shape}`);if(s.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${s.shape}`);if(i.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${i.shape}`);if(a.rank!==0)throw new Error(`Default value should be a scalar but received shape ${a.shape}`);let u={indices:o,values:s,denseShape:i,defaultValue:a},l=_.runKernel(Bl,u);return{outputIndices:l[0],outputValues:l[1],emptyRowIndicator:l[2],reverseIndexMap:l[3]}}var qE=N({sparseFillEmptyRows_:U6});function H6(r,t,e){let n=C(r,"inputIndices","sparseReshape","int32"),o=C(t,"inputShape","sparseReshape","int32"),s=C(e,"newShape","sparseReshape","int32");if(n.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${n.shape}`);if(o.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${o.shape}`);if(s.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${s.shape}`);let i={inputIndices:n,inputShape:o,newShape:s},a=_.runKernel(Pa,i);return{outputIndices:a[0],outputShape:a[1]}}var KE=N({sparseReshape_:H6});function q6(r,t,e){let n=C(r,"data","sparseSegmentMean"),o=C(t,"indices","sparseSegmentMean","int32"),s=C(e,"segmentIds","sparseSegmentMean","int32");if(n.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${o.shape}`);if(s.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${s.shape}`);let i={data:n,indices:o,segmentIds:s};return _.runKernel(Vl,i)}var jE=N({sparseSegmentMean_:q6});function K6(r,t,e){let n=C(r,"data","sparseSegmentSum"),o=C(t,"indices","sparseSegmentSum","int32"),s=C(e,"segmentIds","sparseSegmentSum","int32");if(n.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${o.shape}`);if(s.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${s.shape}`);let i={data:n,indices:o,segmentIds:s};return _.runKernel(Gl,i)}var XE=N({sparseSegmentSum_:K6});function j6(r,t,e,n,o,s,i,a){let u=C(r,"data","stringNGrams","string");if(u.dtype!=="string")throw new Error("Data must be of datatype string");if(u.shape.length!==1)throw new Error(`Data must be a vector, saw: ${u.shape}`);let l=C(t,"dataSplits","stringNGrams");if(l.dtype!=="int32")throw new Error("Data splits must be of datatype int32");let c={separator:e,nGramWidths:n,leftPad:o,rightPad:s,padWidth:i,preserveShortSequences:a},p={data:u,dataSplits:l},m=_.runKernel(Qp,p,c);return{nGrams:m[0],nGramsSplits:m[1]}}var YE=N({stringNGrams_:j6});function X6(r,t,e=!0){let n=C(r,"input","stringSplit","string"),o=C(t,"delimiter","stringSplit","string");if(n.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${n.shape}`);if(o.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${o.shape}`);let s={skipEmpty:e},i={input:n,delimiter:o},a=_.runKernel(tm,i,s);return{indices:a[0],values:a[1],shape:a[2]}}var ZE=N({stringSplit_:X6});function Y6(r,t){let e=C(r,"input","stringToHashBucketFast","string"),n={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");let o={input:e};return _.runKernel(em,o,n)}var JE=N({stringToHashBucketFast_:Y6});var eFt={fft:ol,ifft:Gi,rfft:sl,irfft:fc},iFt={hammingWindow:yE,hannWindow:jx,frame:Xx,stft:bE},dn={flipLeftRight:vE,grayscaleToRGB:CE,resizeNearestNeighbor:ty,resizeBilinear:Qx,rotateWithOffset:IE,cropAndResize:wE,nonMaxSuppression:SE,nonMaxSuppressionAsync:TE,nonMaxSuppressionWithScore:_E,nonMaxSuppressionWithScoreAsync:EE,nonMaxSuppressionPadded:AE,nonMaxSuppressionPaddedAsync:$E,threshold:DE,transform:RE},QE={bandPart:FE,gramSchmidt:OE,qr:PE},RFt={absoluteDifference:LE,computeWeightedLoss:Br,cosineDistance:zE,hingeLoss:BE,huberLoss:VE,logLoss:GE,meanSquaredError:WE,sigmoidCrossEntropy:UE,softmaxCrossEntropy:HE},Bh={sparseFillEmptyRows:qE,sparseReshape:KE,sparseSegmentMean:jE,sparseSegmentSum:XE},ey={stringNGrams:YE,stringSplit:ZE,stringToHashBucketFast:JE};var Vr=class extends nh{minimize(t,e=!1,n){let{value:o,grads:s}=this.computeGradients(t,n);if(n!=null){let i=n.map(a=>({name:a.name,tensor:s[a.name]}));this.applyGradients(i)}else this.applyGradients(s);return _t(s),e?o:(o.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(t,e){return Ox(t,e)}dispose(){this.iterations_!=null&&_t(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:pt(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(t){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(t){return this.iterations_=(await t[0].tensor.data())[0],t.slice(1)}};Object.defineProperty(Vr,Symbol.hasInstance,{value:r=>r.minimize!=null&&r.computeGradients!=null&&r.applyGradients!=null});var Ql=class extends Vr{constructor(t,e,n=null){super(),this.learningRate=t,this.rho=e,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],n==null&&(this.epsilon=_.backend.epsilon())}applyGradients(t){(Array.isArray(t)?t.map(n=>n.name):Object.keys(t)).forEach((n,o)=>{let s=_.registeredVariables[n],i=!1;this.accumulatedGrads[o]==null&&(this.accumulatedGrads[o]={originalName:`${n}/accum_grad`,variable:B(()=>St(s).variable(i))}),this.accumulatedUpdates[o]==null&&(this.accumulatedUpdates[o]={originalName:`${n}/accum_var`,variable:B(()=>St(s).variable(i))});let a=Array.isArray(t)?t[o].tensor:t[n];if(a==null)return;let u=this.accumulatedGrads[o].variable,l=this.accumulatedUpdates[o].variable;B(()=>{let c=J(M(u,this.rho),M(Ut(a),1-this.rho)),p=M(ct(be(J(l,this.epsilon)),be(J(u,this.epsilon))),a),m=J(M(l,this.rho),M(Ut(p),1-this.rho));u.assign(c),l.assign(m);let f=J(M(p,-this.learningRate),s);s.assign(f)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(_t(this.accumulatedGrads.map(t=>t.variable)),_t(this.accumulatedUpdates.map(t=>t.variable)))}async getWeights(){let t=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(t.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(t){t=await this.extractIterations(t);let e=t.length/2,n=!1;this.accumulatedGrads=t.slice(0,e).map(o=>({originalName:o.name,variable:o.tensor.variable(n)})),this.accumulatedUpdates=t.slice(e,e*2).map(o=>({originalName:o.name,variable:o.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.rho,e.epsilon)}};Ql.className="Adadelta";Nn(Ql);var tu=class extends Vr{constructor(t,e=.1){super(),this.learningRate=t,this.initialAccumulatorValue=e,this.accumulatedGrads=[]}applyGradients(t){(Array.isArray(t)?t.map(n=>n.name):Object.keys(t)).forEach((n,o)=>{let s=_.registeredVariables[n];this.accumulatedGrads[o]==null&&(this.accumulatedGrads[o]={originalName:`${n}/accumulator`,variable:B(()=>Js(s.shape,this.initialAccumulatorValue).variable(!1))});let i=Array.isArray(t)?t[o].tensor:t[n];if(i==null)return;let a=this.accumulatedGrads[o].variable;B(()=>{let u=J(a,Ut(i));a.assign(u);let l=J(M(ct(i,be(J(u,_.backend.epsilon()))),-this.learningRate),s);s.assign(l)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&_t(this.accumulatedGrads.map(t=>t.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t);let e=!1;this.accumulatedGrads=t.map(n=>({originalName:n.name,variable:n.tensor.variable(e)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(t,e){return new t(e.learningRate,e.initialAccumulatorValue)}};tu.className="Adagrad";Nn(tu);var eu=class extends Vr{constructor(t,e,n,o=null){super(),this.learningRate=t,this.beta1=e,this.beta2=n,this.epsilon=o,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],B(()=>{this.accBeta1=pt(e).variable(),this.accBeta2=pt(n).variable()}),o==null&&(this.epsilon=_.backend.epsilon())}applyGradients(t){let e=Array.isArray(t)?t.map(n=>n.name):Object.keys(t);B(()=>{let n=lt(1,this.accBeta1),o=lt(1,this.accBeta2);e.forEach((s,i)=>{let a=_.registeredVariables[s],u=!1;this.accumulatedFirstMoment[i]==null&&(this.accumulatedFirstMoment[i]={originalName:`${s}/m`,variable:B(()=>St(a).variable(u))}),this.accumulatedSecondMoment[i]==null&&(this.accumulatedSecondMoment[i]={originalName:`${s}/v`,variable:B(()=>St(a).variable(u))});let l=Array.isArray(t)?t[i].tensor:t[s];if(l==null)return;let c=this.accumulatedFirstMoment[i].variable,p=this.accumulatedSecondMoment[i].variable,m=J(M(c,this.beta1),M(l,1-this.beta1)),f=J(M(p,this.beta2),M(Ut(l),1-this.beta2)),d=ct(m,n),h=ct(f,o);c.assign(m),p.assign(f);let g=J(M(ct(d,J(be(h),this.epsilon)),-this.learningRate),a);a.assign(g)}),this.accBeta1.assign(M(this.accBeta1,this.beta1)),this.accBeta2.assign(M(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&_t(this.accumulatedFirstMoment.map(t=>t.variable)),this.accumulatedSecondMoment!=null&&_t(this.accumulatedSecondMoment.map(t=>t.variable))}async getWeights(){let t=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(t.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(t){t=await this.extractIterations(t),B(()=>{this.accBeta1.assign(Zr(this.beta1,this.iterations_+1)),this.accBeta2.assign(Zr(this.beta2,this.iterations_+1))});let e=t.length/2,n=!1;this.accumulatedFirstMoment=t.slice(0,e).map(o=>({originalName:o.name,variable:o.tensor.variable(n)})),this.accumulatedSecondMoment=t.slice(e,e*2).map(o=>({originalName:o.name,variable:o.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon)}};eu.className="Adam";Nn(eu);var ru=class extends Vr{constructor(t,e,n,o=null,s=0){super(),this.learningRate=t,this.beta1=e,this.beta2=n,this.epsilon=o,this.decay=s,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],B(()=>{this.iteration=pt(0).variable(),this.accBeta1=pt(e).variable()}),o==null&&(this.epsilon=_.backend.epsilon())}applyGradients(t){let e=Array.isArray(t)?t.map(n=>n.name):Object.keys(t);B(()=>{let n=lt(1,this.accBeta1),o=ct(-this.learningRate,J(M(this.iteration,this.decay),1));e.forEach((s,i)=>{let a=_.registeredVariables[s],u=!1;this.accumulatedFirstMoment[i]==null&&(this.accumulatedFirstMoment[i]={originalName:`${s}/m`,variable:St(a).variable(u)}),this.accumulatedWeightedInfNorm[i]==null&&(this.accumulatedWeightedInfNorm[i]={originalName:`${s}/v`,variable:St(a).variable(u)});let l=Array.isArray(t)?t[i].tensor:t[s];if(l==null)return;let c=this.accumulatedFirstMoment[i].variable,p=this.accumulatedWeightedInfNorm[i].variable,m=J(M(c,this.beta1),M(l,1-this.beta1)),f=M(p,this.beta2),d=Ne(l),h=fn(f,d);c.assign(m),p.assign(h);let g=J(M(ct(o,n),ct(m,J(h,this.epsilon))),a);a.assign(g)}),this.iteration.assign(J(this.iteration,1)),this.accBeta1.assign(M(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&_t(this.accumulatedFirstMoment.map(t=>t.variable)),this.accumulatedWeightedInfNorm!=null&&_t(this.accumulatedWeightedInfNorm.map(t=>t.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(t){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon,e.decay)}};ru.className="Adamax";Nn(ru);var Ui=class extends Vr{constructor(t){super(),this.learningRate=t,this.setLearningRate(t)}applyGradients(t){(Array.isArray(t)?t.map(n=>n.name):Object.keys(t)).forEach((n,o)=>{let s=Array.isArray(t)?t[o].tensor:t[n];if(s==null)return;let i=_.registeredVariables[n];B(()=>{let a=J(M(this.c,s),i);i.assign(a)})}),this.incrementIterations()}setLearningRate(t){this.learningRate=t,this.c!=null&&this.c.dispose(),this.c=Pe(pt(-t))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(t){if(t=await this.extractIterations(t),t.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(t,e){return new t(e.learningRate)}};Ui.className="SGD";Nn(Ui);var nu=class extends Ui{constructor(t,e,n=!1){super(t),this.learningRate=t,this.momentum=e,this.useNesterov=n,this.accumulations=[],this.m=pt(this.momentum)}applyGradients(t){(Array.isArray(t)?t.map(n=>n.name):Object.keys(t)).forEach((n,o)=>{let s=_.registeredVariables[n];this.accumulations[o]==null&&(this.accumulations[o]={originalName:`${n}/momentum`,variable:B(()=>St(s).variable(!1))});let i=this.accumulations[o].variable,a=Array.isArray(t)?t[o].tensor:t[n];a!=null&&B(()=>{let u,l=J(M(this.m,i),a);this.useNesterov?u=J(M(this.c,J(a,M(l,this.m))),s):u=J(M(this.c,l),s),i.assign(l),s.assign(u)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&_t(this.accumulations.map(t=>t.variable))}setMomentum(t){this.momentum=t}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t);let e=!1;this.accumulations=t.map(n=>({originalName:n.name,variable:n.tensor.variable(e)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(t,e){return new t(e.learningRate,e.momentum,e.useNesterov)}};nu.className="Momentum";Nn(nu);var ou=class extends Vr{constructor(t,e=.9,n=0,o=null,s=!1){if(super(),this.learningRate=t,this.decay=e,this.momentum=n,this.epsilon=o,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=s,o==null&&(this.epsilon=_.backend.epsilon()),t==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(t){(Array.isArray(t)?t.map(n=>n.name):Object.keys(t)).forEach((n,o)=>{let s=_.registeredVariables[n],i=!1;this.accumulatedMeanSquares[o]==null&&(this.accumulatedMeanSquares[o]={originalName:`${n}/rms`,variable:B(()=>St(s).variable(i))}),this.accumulatedMoments[o]==null&&(this.accumulatedMoments[o]={originalName:`${n}/momentum`,variable:B(()=>St(s).variable(i))}),this.accumulatedMeanGrads[o]==null&&this.centered&&(this.accumulatedMeanGrads[o]={originalName:`${n}/mg`,variable:B(()=>St(s).variable(i))});let a=Array.isArray(t)?t[o].tensor:t[n];if(a==null)return;let u=this.accumulatedMeanSquares[o].variable,l=this.accumulatedMoments[o].variable;B(()=>{let c=J(M(u,this.decay),M(Ut(a),1-this.decay));if(this.centered){let p=this.accumulatedMeanGrads[o].variable,m=J(M(p,this.decay),M(a,1-this.decay)),f=ct(M(a,this.learningRate),be(lt(c,J(Ut(m),this.epsilon)))),d=J(M(l,this.momentum),f);u.assign(c),p.assign(m),l.assign(d);let h=lt(s,d);s.assign(h)}else{let p=J(M(u,this.decay),M(Ut(a),1-this.decay)),m=J(M(l,this.momentum),ct(M(a,this.learningRate),be(J(p,this.epsilon))));u.assign(p),l.assign(m);let f=lt(s,m);s.assign(f)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&_t(this.accumulatedMeanSquares.map(t=>t.variable)),this.accumulatedMeanGrads!=null&&this.centered&&_t(this.accumulatedMeanGrads.map(t=>t.variable)),this.accumulatedMoments!=null&&_t(this.accumulatedMoments.map(t=>t.variable))}async getWeights(){let t=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&t.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(t.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(t){t=await this.extractIterations(t);let e=this.centered?t.length/3:t.length/2,n=!1;this.accumulatedMeanSquares=t.slice(0,e).map(o=>({originalName:o.name,variable:o.tensor.variable(n)})),this.accumulatedMoments=t.slice(e,e*2).map(o=>({originalName:o.name,variable:o.tensor.variable(n)})),this.centered&&(this.accumulatedMeanGrads=t.slice(e*2,e*3).map(o=>({originalName:o.name,variable:o.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(t,e){return new t(e.learningRate,e.decay,e.momentum,e.epsilon,e.centered)}};ou.className="RMSProp";Nn(ou);var ni=class{static sgd(t){return new Ui(t)}static momentum(t,e,n=!1){return new nu(t,e,n)}static rmsprop(t,e=.9,n=0,o=null,s=!1){return new ou(t,e,n,o,s)}static adam(t=.001,e=.9,n=.999,o=null){return new eu(t,e,n,o)}static adadelta(t=.001,e=.95,n=null){return new Ql(t,e,n)}static adamax(t=.002,e=.9,n=.999,o=null,s=0){return new ru(t,e,n,o,s)}static adagrad(t,e=.1){return new tu(t,e)}};var wc={sgd:ni.sgd,momentum:ni.momentum,adadelta:ni.adadelta,adagrad:ni.adagrad,rmsprop:ni.rmsprop,adamax:ni.adamax,adam:ni.adam};var Z6=(()=>typeof requestAnimationFrame!="undefined"?requestAnimationFrame:typeof setImmediate!="undefined"?setImmediate:r=>r())();function Vh(){return new Promise(r=>Z6(()=>r()))}var S={};Yt(S,{ERF_A1:()=>l5,ERF_A2:()=>u5,ERF_A3:()=>c5,ERF_A4:()=>p5,ERF_A5:()=>m5,ERF_P:()=>a5,PARALLELIZE_THRESHOLD:()=>ry,SELU_SCALE:()=>pS,SELU_SCALEALPHA:()=>cS,applyActivation:()=>yc,assertAndGetBroadcastShape:()=>zt,assertAxesAreInnerMostDims:()=>Jq,assertParamsConsistent:()=>J6,assignToTypedArray:()=>y5,axesAreInnerMostDims:()=>HI,calculateShapes:()=>__,checkEinsumDimSizes:()=>S5,checkPadOnDimRoundingMode:()=>Te,combineLocations:()=>K_,complexWithEvenIndex:()=>h5,complexWithOddIndex:()=>g5,computeConv2DInfo:()=>Xu,computeConv3DInfo:()=>U_,computeDefaultPad:()=>_I,computeDilation2DInfo:()=>CH,computeOptimalWindowSize:()=>t5,computeOutAndReduceShapes:()=>qI,computeOutShape:()=>Q6,computePool2DInfo:()=>TI,computePool3DInfo:()=>IH,convertConv2DDataFormat:()=>H_,decodeEinsumEquation:()=>C5,eitherStridesOrDilationsAreOne:()=>$r,expandShapeToKeepDim:()=>wo,exponent:()=>w5,exponents:()=>b5,fromStringArrayToUint8:()=>H5,fromUint8ToStringArray:()=>U5,getAxesPermutation:()=>KI,getBroadcastDims:()=>k_,getComplexWithIndex:()=>x5,getEinsumComputePath:()=>k5,getEinsumPermutation:()=>I5,getFusedBiasGradient:()=>xc,getFusedDyActivation:()=>gc,getImageCenter:()=>e5,getInnerMostAxes:()=>Qq,getPermuted:()=>n5,getReductionAxes:()=>ge,getReshaped:()=>r5,getReshapedPermuted:()=>o5,getSliceBeginCoords:()=>s5,getSliceSize:()=>i5,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>E5,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>A5,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>$5,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>F5,getSparseReshapeInputOutputMismatchErrorMessage:()=>M5,getSparseReshapeInputOutputMultipleErrorMessage:()=>O5,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>D5,getSparseReshapeNegativeOutputDimErrorMessage:()=>R5,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>B5,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>P5,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>L5,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>z5,getUndoAxesPermutation:()=>kh,isIdentityPermutation:()=>N5,log:()=>LU,mergeRealAndImagArrays:()=>f5,prepareAndValidate:()=>T_,prepareSplitSize:()=>_5,segment_util:()=>fS,shouldFuse:()=>bc,slice_util:()=>Ve,splitRealAndImagArrays:()=>d5,tupleValuesAreOne:()=>Zn,upcastType:()=>ar,validateInput:()=>$x,validateUpdateShape:()=>bI,warn:()=>Pi});function J6(r,t){let e=r[0].length;r.forEach((o,s)=>{A(o.length===e,()=>`Error in concat${e}D: rank of tensors[${s}] must be the same as the rank of the rest (${e})`)}),A(t>=0&&t<e,()=>`Error in concat${e}D: axis must be between 0 and ${e-1}.`);let n=r[0];r.forEach((o,s)=>{for(let i=0;i<e;i++)A(i===t||o[i]===n[i],()=>`Error in concat${e}D: Shape of tensors[${s}] (${o}) does not match the shape of the rest (${n}) along the non-concatenated axis ${s}.`)})}function Q6(r,t){let e=r[0].slice();for(let n=1;n<r.length;n++)e[t]+=r[n][t];return e}var ry=30;function t5(r){return r<=ry?r:Sp(r,Math.floor(Math.sqrt(r)))}function e5(r,t,e){let n=e*(typeof r=="number"?r:r[0]),o=t*(typeof r=="number"?r:r[1]);return[n,o]}function r5(r,t,e,n=!0){let o=[];if(n)o=o.concat(t.slice(0)),o.push(r[0]/e),o=o.concat(r.slice(1));else{o=o.concat(r[0]);let s=t.length;for(let i=0;i<s;++i)o=o.concat([r[i+1]/t[i],t[i]]);o=o.concat(r.slice(s+1))}return o}function n5(r,t,e=!0){let n=[];if(e){n.push(t);for(let o=t+1;o<r;++o)o<=2*t?(n.push(o),n.push(o-(t+1))):n.push(o)}else{let o=[],s=[];for(let i=1;i<r;++i)i>=t*2+1||i%2===1?s.push(i):o.push(i);n.push(...o),n.push(0),n.push(...s)}return n}function o5(r,t,e,n=!0){let o=[];n?o.push(r[0]/e):o.push(r[0]*e);for(let s=1;s<r.length;++s)s<=t.length?n?o.push(t[s-1]*r[s]):o.push(r[s]/t[s-1]):o.push(r[s]);return o}function s5(r,t){let e=[0];for(let n=0;n<t;++n)e.push(r[n][0]);return e}function i5(r,t,e){let n=r.slice(0,1);for(let o=0;o<e;++o)n.push(r[o+1]-t[o][0]-t[o][1]);return n}var cS=1.7580993408473768,pS=1.0507009873554805;var a5=.3275911,l5=.254829592,u5=-.284496736,c5=1.421413741,p5=-1.453152027,m5=1.061405429;function f5(r,t){if(r.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${r.length}, imag: ${t.length}.`);let e=new Float32Array(r.length*2);for(let n=0;n<e.length;n+=2)e[n]=r[n/2],e[n+1]=t[n/2];return e}function d5(r){let t=new Float32Array(r.length/2),e=new Float32Array(r.length/2);for(let n=0;n<r.length;n+=2)t[n/2]=r[n],e[n/2]=r[n+1];return{real:t,imag:e}}function h5(r){let t=Math.ceil(r.length/4),e=new Float32Array(t),n=new Float32Array(t);for(let o=0;o<r.length;o+=4)e[Math.floor(o/4)]=r[o],n[Math.floor(o/4)]=r[o+1];return{real:e,imag:n}}function g5(r){let t=Math.floor(r.length/4),e=new Float32Array(t),n=new Float32Array(t);for(let o=2;o<r.length;o+=4)e[Math.floor(o/4)]=r[o],n[Math.floor(o/4)]=r[o+1];return{real:e,imag:n}}function x5(r,t){let e=r[t*2],n=r[t*2+1];return{real:e,imag:n}}function y5(r,t,e,n){r[n*2]=t,r[n*2+1]=e}function b5(r,t){let e=new Float32Array(r/2),n=new Float32Array(r/2);for(let o=0;o<Math.ceil(r/2);o++){let s=(t?2:-2)*Math.PI*(o/r);e[o]=Math.cos(s),n[o]=Math.sin(s)}return{real:e,imag:n}}function w5(r,t,e){let n=(e?2:-2)*Math.PI*(r/t),o=Math.cos(n),s=Math.sin(n);return{real:o,imag:s}}var mS="->",v5=/->/g,tA=",",eA="...";function C5(r,t){r=r.replace(/\s/g,"");let e=(r.length-r.replace(v5,"").length)/mS.length;if(e<1)throw new Error("Equations without an arrow are not supported.");if(e>1)throw new Error(`Equation must contain exactly one arrow ("${mS}").`);let[n,o]=r.split(mS);A(n.indexOf(eA)===-1,()=>`The ellipsis notation ("${eA}") is not supported yet.`);let s=n.split(tA),i=s.length;if(t!==i)throw new Error(`Expected ${i} input tensors, received ${t}`);if(i>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");let a=[];for(let m=0;m<o.length;++m){let f=o[m];if(!s.some(d=>d.indexOf(f)!==-1))throw new Error(`Output subscripts contain the label ${f} not present in the input subscripts.`);a.indexOf(f)===-1&&a.push(f)}for(let m=0;m<n.length;++m){let f=n[m];a.indexOf(f)===-1&&f!==tA&&a.push(f)}let u=new Array(s.length);for(let m=0;m<i;++m){if(new Set(s[m].split("")).size!==s[m].length)throw new Error(`Found duplicate axes in input component ${s[m]}. Support for duplicate axes in input is not implemented yet.`);u[m]=[];for(let f=0;f<s[m].length;++f)u[m].push(a.indexOf(s[m][f]))}let l=a.length,c=o.length,p=[];for(let m=c;m<l;++m)p.push(m);return{allDims:a,summedDims:p,idDims:u}}function I5(r,t){let e=new Array(r);e.fill(-1);for(let o=0;o<t.length;++o)e[t[o]]=o;let n=[];for(let o=0;o<r;++o)e[o]===-1&&n.push(o);return e=e.filter(o=>o!==-1),{permutationIndices:e,expandDims:n}}function S5(r,t,e){let n=new Array(r);for(let o=0;o<e.length;++o){let s=e[o].shape;for(let i=0;i<t[o].length;++i)n[t[o][i]]===void 0?n[t[o][i]]=s[i]:A(n[t[o][i]]===s[i],()=>`Expected dimension ${n[t[o][i]]} at axis ${i} of input shaped ${JSON.stringify(s)}, but got dimension ${s[i]}`)}}function k5(r,t){let e=r,n=[],o=0;r.length===0&&e.push(-1),o=r.length+1;for(let i=0;i<o;++i)n.push([]);let s=[];for(let i=0;i<e.length;++i){let a=e[i],u=T5(t,a);for(let l of u)s.indexOf(l)===-1&&(n[i].push(l),s.push(l))}return{path:e,steps:n}}function N5(r){return r.every((t,e)=>t===e)}function T5(r,t){let e=[];for(let n=0;n<r.length;++n)(r[n].length===0||r[n].indexOf(t)!==-1||t===-1)&&e.push(n);return e}function _5(r,t,e=0){let n=[];if(typeof t=="number")A(r.shape[e]%t===0,()=>"Number of splits must evenly divide the axis."),n=new Array(t).fill(r.shape[e]/t);else{let o=t.reduce((i,a)=>(a===-1&&(i+=1),i),0);A(o<=1,()=>"There should be only one negative value in split array.");let s=t.indexOf(-1);if(s!==-1){let i=t.reduce((a,u)=>u>0?a+u:a);t[s]=r.shape[e]-i}A(r.shape[e]===t.reduce((i,a)=>i+a),()=>"The sum of sizes must match the size of the axis dimension."),n=t}return n}function E5(r){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${r}`}function A5(r,t){return`indices(${r}, 0) is invalid: ${t} < 0`}function $5(r,t,e){return`indices(${r}, 0) is invalid: ${t} >= ${e}`}function D5(r,t){return`only one output dimension may be -1, not both ${r} and ${t}`}function R5(r,t){return`size ${r} must be non-negative, not ${t}`}function F5(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function O5(r,t){let e=re(r),n=re(t);return`Input to reshape is a SparseTensor with ${e}
  dense values, but the requested shape requires a multiple of ${n}. inputShape=${r} outputShape= ${t}`}function M5(r,t){let e=re(r),n=re(t);return`Input to reshape is a tensor with ${e} dense values, but the requested shape has ${n}. inputShape=${r} outputShape=${t}`}function P5(){return"segment ids must be >= 0"}function L5(){return"segment ids are not increasing"}function z5(r,t){return`Segment id ${r} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function B5(r,t,e){return`Bad: indices[${r}] == ${t} out of range [0, ${e})`}var fS={};Yt(fS,{collectGatherOpShapeInfo:()=>W5,computeOutShape:()=>G5,segOpComputeOptimalWindowSize:()=>V5});function V5(r,t){let e=!1,n;for(r<=ry?(n=r,e=!0):n=Sp(r,Math.floor(Math.sqrt(r)));!e;)n>t||n===r?e=!0:n=Sp(r,n+1);return n}function G5(r,t,e){let n=[],o=r.length;for(let s=0;s<o;s++)s!==t?n.push(r[s]):n.push(e);return n}function W5(r,t,e,n){let o=t.shape.length,s=r.shape.length;if(n!==0&&(n<-o||n>o))throw new Error(`Expect batchDims in the range of [-${o}, ${o}], but got ${n}`);if(n<0&&(n+=o),n>s)throw new Error(`batchDims (${n}) must be less than rank(x) (
    ${s}).`);if(e<n)throw new Error(`batchDims (${n}) must be less than or equal to axis (${e}).`);for(let p=0;p<n;++p)if(r.shape[p]!==t.shape[p])throw new Error(`x.shape[${p}]: ${r.shape[p]} should be equal to indices.shape[${p}]: ${t.shape[p]}.`);let i=r.shape[e],a=[],u=1,l=1,c=1;for(let p=0;p<n;++p)a.push(r.shape[p]),u*=r.shape[p];for(let p=n;p<e;p++)a.push(r.shape[p]),l*=r.shape[p];for(let p=n;p<o;p++)a.push(t.shape[p]);for(let p=e+1;p<s;p++)a.push(r.shape[p]),c*=r.shape[p];return{batchSize:u,sliceSize:c,outerSize:l,dimSize:i,outputShape:a}}function U5(r){try{return r.map(t=>am(t))}catch(t){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`)}}function H5(r){return r.map(t=>ql(t))}var Gr={};Yt(Gr,{nonMaxSuppressionV3Impl:()=>Yx,nonMaxSuppressionV4Impl:()=>Zx,nonMaxSuppressionV5Impl:()=>Jx,whereImpl:()=>Wx});var ny={kernelName:bi,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>M(r,ri(Z(e,"float32"),-1))}}};var rA={kernelName:ta,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>{let n=Ut(Z(e,"float32")),o=be(lt(pt(1),n));return Zt(ct(r,o))}}}};var nA={kernelName:ea,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>{let n=be(lt(Ut(Z(e,"float32")),1));return ct(r,n)}}}};var oA={kernelName:Xn,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[e,n]=t,o=zt(e.shape,n.shape);return{a:()=>{let a=r,u=ge(e.shape,o);return u.length>0&&(a=mt(a,u)),O(a,e.shape)},b:()=>{let a=r,u=ge(n.shape,o);return u.length>0&&(a=mt(a,u)),O(a,n.shape)}}}};var sA={kernelName:Zo,saveAllInputs:!0,gradFunc:(r,t)=>{let e={};return t.forEach((n,o)=>{e[o]=()=>r.clone()}),e}};var iA={kernelName:Jo,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>St(e)}}};var aA={kernelName:Al,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>St(e)}}};var lA={kernelName:oa,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>ct(r,be(lt(pt(1),Ut(Z(e,"float32")))))}}};var uA={kernelName:sa,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>{let n=be(J(pt(1),Ut(Z(e,"float32"))));return ct(r,n)}}}};var cA={kernelName:la,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[e,n]=t,o=zt(e.shape,n.shape);return{a:()=>{let a=J(Ut(e),Ut(n)),u=M(r,ct(n,a)),l=ge(e.shape,o);return l.length>0&&(u=mt(u,l)),O(u,e.shape)},b:()=>{let a=J(Ut(e),Ut(n)),u=Zt(M(r,ct(e,a))),l=ge(n.shape,o);return l.length>0&&(u=mt(u,l)),O(u,n.shape)}}}};var pA={kernelName:ia,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>ct(r,J(Ut(Z(e,"float32")),1))}}};var mA={kernelName:aa,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>ct(r,lt(pt(1),Ut(Z(e,"float32"))))}}};function q5(r,t,e,n,o,s){let i=C(r,"dy","avgPool3dGrad"),a=C(t,"input","avgPool3dGrad"),u=i,l=a,c=!1;a.rank===4&&(c=!0,u=O(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),l=O(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),A(u.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${u.rank}.`),A(l.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${l.rank}.`),Te("avgPool3dGrad",o,s);let p={dy:u,input:l},m={filterSize:e,strides:n,pad:o,dimRoundingMode:s},f=_.runKernel(Tp,p,m);return c?O(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}var fA=N({avgPool3dGrad_:q5});var dA={kernelName:$l,inputsToSave:["x"],gradFunc:(r,t,e)=>{let[n]=t,{filterSize:o,strides:s,pad:i,dimRoundingMode:a}=e;return{x:()=>fA(r,n,o,s,i,a)}}};function K5(r,t,e,n,o){let s=C(r,"dy","avgPoolGrad"),i=C(t,"input","avgPoolGrad");A(i.rank===s.rank,()=>`Rank of input (${i.rank}) does not match rank of dy (${s.rank})`);let a=i,u=s,l=!1;i.rank===3&&(l=!0,a=O(i,[1,i.shape[0],i.shape[1],i.shape[2]]),u=O(s,[1,s.shape[0],s.shape[1],s.shape[2]])),A(u.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${u.rank}.`),A(a.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${a.rank}.`);let c={dy:u,input:a},p={filterSize:e,strides:n,pad:o},m=_.runKernel(Np,c,p);return l?O(m,[m.shape[1],m.shape[2],m.shape[3]]):m}var hA=N({avgPoolGrad_:K5});var gA={kernelName:Qo,inputsToSave:["x"],gradFunc:(r,t,e)=>{let[n]=t,{filterSize:o,strides:s,pad:i}=e;return{x:()=>hA(r,n,o,s,i)}}};var xA={kernelName:ts,inputsToSave:["a","b"],gradFunc:(r,t,e)=>{let[n,o]=t,{transposeA:s,transposeB:i}=e;return!s&&!i?{a:()=>Lt(r,o,!1,!0),b:()=>Lt(n,r,!0,!1)}:!s&&i?{a:()=>Lt(r,o,!1,!1),b:()=>Lt(r,n,!0,!1)}:s&&!i?{a:()=>Lt(o,r,!1,!0),b:()=>Lt(n,r,!1,!1)}:{a:()=>Lt(o,r,!0,!0),b:()=>Lt(r,n,!0,!0)}}};var yA={kernelName:wi,gradFunc:(r,t,e)=>{let{blockShape:n,crops:o}=e;return{x:()=>tl(r,n,o)}}};var bA={kernelName:b1,gradFunc:(r,t,e)=>{let n=e,o=n.inputShape,s=n.shape,i=Array.from(s);for(let u=o.length-1;u>=0;u--)if(o[u]===s[u])i[u]=1;else if(o[u]!==1)throw new Error(`broadcastTo(): [${o}] cannot be broadcast to [${s}].`);let a=[];for(let u=0;u<i.length;u++)i[u]>1&&a.push(u);return{x:()=>mt(r,a,!0)}}};var wA={kernelName:io,gradFunc:r=>({x:()=>r.clone()})};var vA={kernelName:es,gradFunc:r=>({x:()=>St(r)})};var CA={kernelName:ao,inputsToSave:["x"],gradFunc:(r,t,e)=>{let[n]=t,{clipValueMin:o,clipValueMax:s}=e;return{x:()=>_e(Nr(Tn(n,o),_n(n,s)),r,St(r))}}};var IA={kernelName:Dl,inputsToSave:["x"],gradFunc:ny.gradFunc};var SA={kernelName:vi,saveAllInputs:!0,gradFunc:(r,t,e)=>{let n=t.map(u=>u.shape),{axis:o}=e,s=mr(o,t[0].shape)[0],i=n.map(u=>u[s]);return ur(r,i,s).map(u=>()=>u)}};var kA={kernelName:rs,inputsToSave:["x","filter"],gradFunc:(r,t,e)=>{let[n,o]=t,{dilations:s,strides:i,pad:a,dataFormat:u}=e;return A(Zn(s),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`),{x:()=>hm(n.shape,r,o,i,a,u),filter:()=>vm(n,r,o.shape,i,a,u)}}};var NA={kernelName:ns,inputsToSave:["dy","filter"],gradFunc:(r,t,e)=>{let[n,o]=t,{strides:s,pad:i,dataFormat:a,dimRoundingMode:u}=e;return{dy:()=>pn(r,o,s,i,a,1,u),filter:()=>vm(r,n,o.shape,s,i,a,u)}}};function j5(r,t,e,n,o){let s=r;r.rank===4&&(s=O(r,[1,r.shape[0],r.shape[1],r.shape[2],r.shape[3]]));let i=t;i.rank===4&&(i=O(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),A(s.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${s.shape}.`),A(i.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${i.shape}.`),A(e.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${e}.`),A(s.shape[4]===e[3],()=>`Error in conv3dDerFilter: depth of input ${s.shape[4]}) must match input depth in filter (${e[3]}.`),A(i.shape[4]===e[4],()=>`Error in conv3dDerFilter: depth of dy (${i.shape[4]}) must match output depth for filter (${e[4]}).`);let a={x:s,dy:i},u={strides:n,pad:o,filterShape:e};return _.runKernel(Dp,a,u)}var TA=N({conv3DBackpropFilter_:j5});var _A={kernelName:Rl,inputsToSave:["x","filter"],gradFunc:(r,t,e)=>{let{dilations:n,strides:o,pad:s}=e;A(Zn(n),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${n}'`);let[i,a]=t;return{x:()=>Fx(i.shape,r,a,o,s),filter:()=>TA(i,r,a.shape,o,s)}}};var EA={kernelName:os,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>M(Zt(pc(Z(e,"float32"))),r)}}};var AA={kernelName:ss,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>M(mc(Z(e,"float32")),r)}}};var $A={kernelName:is,inputsToSave:["x"],gradFunc:(r,t,e)=>{let[n]=t,{axis:o,exclusive:s,reverse:i}=e;return{x:()=>{let a=KI([o],n.rank),u=Qu(r,o,s,!i);return a!=null&&(u=Wt(u,a)),u}}}};var DA={kernelName:as,inputsToSave:["x","filter"],gradFunc:(r,t,e)=>{let{dilations:n,strides:o,pad:s,dimRoundingMode:i}=e,a=n==null?[1,1]:n;A(Zn(a),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`);let[u,l]=t;return A(u.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${u.rank}.`),A(l.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${l.rank}.`),A(u.shape[3]===l.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${u.shape[3]}) must match the inChannels dimension in filter ${l.shape[2]}.`),A($r(o,a),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${o} and dilations '${a}'.`),Te("depthwiseConv2d",s,i),{x:()=>Kx(u.shape,r,l,o,s,a,i),filter:()=>qx(u,r,l.shape,o,s,a,i)}}};var RA={kernelName:Fl,inputsToSave:["x","filter"],gradFunc:(r,t,e)=>{let[n,o]=t,s={x:n,filter:o,dy:r},i={x:n,filter:o,dy:r};return{x:()=>_.runKernel(Wd,s,e),filter:()=>_.runKernel(Ud,i,e)}}};var FA={kernelName:us,outputsToSave:[!0],gradFunc:(r,t)=>{let[e]=t,n={dy:r,y:e};return{x:()=>_.runKernel(zp,n)}}};var OA={kernelName:ma,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t,n=M(Ze(Zt(Ut(e))),2/Math.sqrt(Math.PI));return{x:()=>M(r,n)}}};var MA={kernelName:cs,outputsToSave:[!0],gradFunc:(r,t)=>{let[e]=t;return{x:()=>M(r,e)}}};var PA={kernelName:Ci,inputsToSave:["input"],gradFunc:(r,t)=>{let[e]=t;return{input:()=>O(r,e.shape)}}};var LA={kernelName:da,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>M(r,Ze(e))}}};var zA={kernelName:ps,gradFunc:r=>({x:()=>St(r)})};var BA={kernelName:ms,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[e,n]=t,o=zt(e.shape,n.shape);return{a:()=>{let a=ct(r,Z(n,"float32")),u=ge(e.shape,o);return u.length>0?O(mt(a,u),e.shape):a},b:()=>{let a=M(r,Z(e,"float32")),u=ge(n.shape,o);u.length>0&&(a=O(mt(a,u),n.shape));let l=Ut(n);return Zt(ct(a,Z(l,"float32")))}}}};var VA={kernelName:fs,inputsToSave:["x","mean","variance","scale"],gradFunc:(r,t,e)=>{let{varianceEpsilon:n}=e,[o,s,i,a]=t,u=a==null?pt(1):a,l=ge(s.shape,o.shape),c=[];if(s.rank===1){for(let v=0;v<o.shape.length-1;++v)c.push(o.shape[v]);c.push(1)}let p=lt(o,s),m=M(r,u),f=uc(J(i,pt(n))),d=M(M(M(f,f),f),pt(-.5));return{x:()=>s.rank===1?O(M(M(r,kr(O(f,[1,1,1,s.shape[0]]),c)),u),o.shape):O(M(M(r,f),u),o.shape),mean:()=>{let v=M(M(f,pt(-1)),m);return s.rank===1&&(v=mt(v,l)),O(v,s.shape)},variance:()=>{let v=M(M(d,p),m);return s.rank===1&&(v=mt(v,l)),O(v,s.shape)},scale:()=>{let v=M(p,f),k=M(r,v);return s.rank===1&&(k=mt(k,l)),O(k,s.shape)},offset:()=>{let v=r;return s.rank===1&&(v=mt(v,l)),O(v,s.shape)}}}};var UA={kernelName:Ii,inputsToSave:["x","indices"],gradFunc:(r,t,e)=>{let[n,o]=t,{axis:s}=e,i=mr(s,n.shape)[0];return{x:()=>{let u=n.shape,l=o.size,c=u.slice(0,i),p=c.length,m=u.slice(s,u.length).slice(1),f=m.length,d=GA(0,p),h=GA(p+1,p+1+f),g=WA([c,[l],m]),y=O(r,g),b=O(o,[l]),w=WA([[p],d,h]),v=Wt(y,w),k=Lh(v,b,n.shape[i]),E=kh(w);return k=Wt(k,E),k},indices:()=>o}}};function GA(r,t){let e=[];for(let n=r;n<t;++n)e.push(n);return e}function WA(r){let t=[];for(let e=0;e<r.length;++e)for(let n=0;n<r[e].length;++n)t.push(r[e][n]);return t}var HA={kernelName:ds,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[e,n]=t;return{a:()=>St(e),b:()=>St(n)}}};var qA={kernelName:lo,gradFunc:r=>({x:()=>Z(r,"float32")})};var KA={kernelName:ya,gradFunc:r=>({x:()=>St(r)})};var jA={kernelName:ba,gradFunc:r=>({x:()=>St(r)})};var XA={kernelName:wa,gradFunc:r=>({x:()=>St(r)})};var YA={kernelName:hs,inputsToSave:["x"],gradFunc:(r,t,e)=>{let[n]=t,{alpha:o}=e,s=Ge(n,0);return{x:()=>_e(s,r,M(r,o))}}};var ZA={kernelName:Ia,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>ct(r,J(e,1))}}};var JA={kernelName:gs,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>ct(r,Z(e,"float32"))}}};var QA={kernelName:w1,inputsToSave:[],outputsToSave:[!0],gradFunc:(r,t,e)=>{let[n]=t,{axis:o}=e;return{logits:()=>{let i=Ze(n);return lt(r,M(mt(r,o,!0),i))}}}};function X5(r,t,e,n=5,o=1,s=1,i=.5){let a={x:r,y:t,dy:e},u={depthRadius:n,bias:o,alpha:s,beta:i};return _.runKernel(Up,a,u)}var t2=N({localResponseNormalizationBackprop_:X5});var e2={kernelName:Ml,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(r,t,e)=>{let[n,o]=t,{depthRadius:s,bias:i,alpha:a,beta:u}=e;return{x:()=>t2(n,o,r,s,i,a,u)}}};function oy(r,t,e,n){return t.rank<e.rank&&(t=O(t,wo(t.shape,n))),r.rank<e.rank&&(r=O(r,wo(r.shape,n))),{x:()=>M(r,Z(Sr(e,t),r.dtype))}}var dS={kernelName:xs,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(r,t,e)=>{let n=e,{reductionIndices:o}=n,s=t[0],i=t[1],a=mr(o,s.shape),u=oy(r,i,s,a);return{x:()=>u.x()}}};var r2={kernelName:ys,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[e,n]=t;return{a:()=>M(r,Z(Tn(e,n),"float32")),b:()=>M(r,Z(ec(e,n),"float32"))}}};function Y5(r,t,e,n,o,s,i){let a=C(r,"dy","maxPool3dGrad"),u=C(t,"input","maxPool3dGrad"),l=C(e,"output","maxPool3dGrad"),c=a,p=u,m=l,f=!1;u.rank===4&&(f=!0,c=O(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]),p=O(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]]),m=O(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]])),A(c.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`),A(p.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${p.rank}.`),A(m.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${m.rank}.`),Te("maxPool3dGrad",s,i);let d={dy:c,input:p,output:m},h={filterSize:n,strides:o,pad:s,dimRoundingMode:i},g=_.runKernel(qp,d,h);return f?O(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}var n2=N({maxPool3dGrad_:Y5});var o2={kernelName:Pl,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(r,t,e)=>{let[n,o]=t,{filterSize:s,strides:i,pad:a,dimRoundingMode:u}=e;return{x:()=>n2(r,n,o,s,i,a,u)}}};function Z5(r,t,e,n,o,s,i){let a=C(r,"dy","maxPoolGrad"),u=C(t,"input","maxPoolGrad"),l=C(e,"output","maxPoolGrad");A(u.rank===a.rank,()=>`Rank of input (${u.rank}) does not match rank of dy (${a.rank})`),A(a.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${a.rank}.`),A(u.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${u.rank}.`),Te("maxPoolGrad",s,i);let c={dy:a,input:u,output:l},p={filterSize:n,strides:o,pad:s,dimRoundingMode:i};return _.runKernel(Hp,c,p)}var s2=N({maxPoolGrad_:Z5});var i2={kernelName:bs,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(r,t,e)=>{let[n,o]=t,{filterSize:s,strides:i,pad:a}=e;return{x:()=>s2(r,n,o,s,i,a)}}};var a2={kernelName:ws,inputsToSave:["x"],gradFunc:(r,t,e)=>{let[n]=t,{axis:o}=e,s=mr(o,n.shape),a=qI(n.shape,s)[1],u=re(a);return{x:()=>{let c=n.shape.slice();s.forEach(f=>{c[f]=1});let p=O(r,c);return ct(M(p,lr(n.shape,"float32")),u)}}}};var l2={kernelName:vs,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(r,t,e)=>{let n=e,{axis:o}=n,[s,i]=t,a=mr(o,s.shape),u=oy(r,i,s,a);return{x:()=>u.x()}}};var u2={kernelName:Cs,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[e,n]=t;return{a:()=>M(r,Z(_n(e,n),"float32")),b:()=>M(r,Z(Ge(e,n),"float32"))}}};var c2={kernelName:Is,inputsToSave:["x"],gradFunc:(r,t,e)=>{let n=t[0],{paddings:o}=e,s=o.map(i=>i[0]);return{x:()=>Rt(r,s,n.shape)}}};var p2={kernelName:ka,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[e,n]=t,o=zt(e.shape,n.shape);return{a:()=>{let a=ge(e.shape,o);return a.length>0?O(mt(r,a),e.shape):r},b:()=>{let a=M(r,Zt(Qs(ct(e,n)))),u=ge(n.shape,o);return u.length>0?O(mt(a,u),n.shape):a}}}};var m2={kernelName:Ss,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[e,n]=t,o=zt(e.shape,n.shape);return{a:()=>{let a=M(r,Z(n,"float32")),u=ge(e.shape,o);return u.length>0?O(mt(a,u),e.shape):a},b:()=>{let a=M(r,Z(e,"float32")),u=ge(n.shape,o);return u.length>0?O(mt(a,u),n.shape):a}}}};var f2={kernelName:Si,gradFunc:r=>({x:()=>Zt(r)})};var d2={kernelName:ks,inputsToSave:["indices"],gradFunc:(r,t)=>{let e=t[0];return{indices:()=>ye(e.shape,"float32")}}};var h2={kernelName:ki,gradFunc:r=>({x:()=>St(r)})};var g2={kernelName:Ni,saveAllInputs:!0,gradFunc:(r,t,e)=>{let{axis:n}=e;return vr(r,n).map(s=>()=>s)}};var hS={kernelName:Ns,inputsToSave:["x"],gradFunc:(r,t,e)=>{let n=t[0],{paddings:o}=e,s=o.map(i=>i[0]);return{x:()=>Rt(r,s,n.shape)}}};var x2={kernelName:Ts,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(r,t)=>{let[e,n,o]=t,s=e,i=n,a=zt(s.shape,i.shape);return{a:()=>{let c=Z(i,"float32"),p=M(r,M(c,Zr(s,lt(c,pt(1))))),m=ge(s.shape,a);return m.length>0&&(p=mt(p,m)),O(p,s.shape)},b:()=>{let c=Ge(s,0),p=_e(c,wr(s),St(s)),m=M(r,M(o,p)),f=ge(i.shape,a);return f.length>0&&(m=mt(m,f)),O(m,i.shape)}}}};var y2={kernelName:_s,inputsToSave:["x","alpha"],gradFunc:(r,t)=>{let[e,n]=t,o=Ge(e,0);return{x:()=>_e(o,r,M(r,n)),alpha:()=>{let s=_e(o,St(r),M(r,e)),i=ge(n.shape,r.shape);return i.length>0&&(s=mt(s,i)),O(s,n.shape)}}}};var b2={kernelName:ls,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[e,n]=t,o=zt(e.shape,n.shape);return{a:()=>{let a=ct(r,Z(n,"float32")),u=ge(e.shape,o);return u.length>0?O(mt(a,u),e.shape):a},b:()=>{let a=M(r,Z(e,"float32")),u=ge(n.shape,o);u.length>0&&(a=O(mt(a,u),n.shape));let l=Ut(n);return Zt(ct(a,Z(l,"float32")))}}}};var w2={kernelName:$a,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>ct(r,Zt(Ut(e)))}}};var v2={kernelName:$s,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t,n=M(_n(e,6),ri(e));return{x:()=>M(r,Z(n,"float32"))}}};var C2={kernelName:Es,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>M(r,Z(ri(e),"float32"))}}};var I2={kernelName:Ti,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>O(r,e.shape)}}};var S2={kernelName:As,inputsToSave:["images"],gradFunc:(r,t,e)=>{let[n]=t,o={dy:r,images:n};return{images:()=>_.runKernel(Zp,o,e)}}};var k2={kernelName:zl,inputsToSave:["images"],gradFunc:(r,t,e)=>{let[n]=t,o={dy:r,images:n};return{images:()=>_.runKernel(Yp,o,e)}}};var N2={kernelName:Ds,gradFunc:(r,t,e)=>{let{dims:n}=e,o=mr(n,r.shape);return{x:()=>ir(r,o)}}};var T2={kernelName:Rs,gradFunc:r=>({x:()=>St(r)})};var _2={kernelName:Fs,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>Zt(ct(r,M(Zr(e,1.5),2)))}}};var E2={kernelName:_i,inputsToSave:["condition"],gradFunc:(r,t)=>{let[e]=t;return{condition:()=>Z(St(e),"float32"),t:()=>M(r,Z(e,r.dtype)),e:()=>M(r,Z(Ja(e),r.dtype))}}};var A2={kernelName:Ra,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>{let n=Ge(e,pt(0)),o=pt(cS),s=pt(pS),i=M(r,s),a=M(M(r,o),Ze(Z(e,"float32")));return _e(n,i,a)}}}};var $2={kernelName:Ms,outputsToSave:[!0],gradFunc:(r,t)=>{let[e]=t;return{x:()=>M(r,M(e,lt(pt(1),e)))}}};var D2={kernelName:Oa,gradFunc:r=>({x:()=>St(r)})};var R2={kernelName:Os,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>M(Xa(Z(e,"float32")),r)}}};var F2={kernelName:Fa,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>M(Ju(Z(e,"float32")),r)}}};var O2={kernelName:Ei,inputsToSave:["x"],gradFunc:(r,t,e)=>{let[n]=t,{begin:o,size:s}=e,i=n.shape,[a,u]=vI(n,o,s),l=[];for(let c=0;c<r.rank;c++)l.push([a[c],i[c]-a[c]-u[c]]);return{x:()=>Yr(r,l)}}};var M2={kernelName:zs,outputsToSave:[!0],gradFunc:(r,t,e)=>{let[n]=t,{dim:o}=e,s=!0,i=M(r,n);return{logits:()=>lt(i,M(mt(i,[o],s),n))}}};var P2={kernelName:Ma,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>M(r,Lr(e))}}};var gS={kernelName:Ai,gradFunc:(r,t,e)=>{let{blockShape:n,paddings:o}=e;return{x:()=>Ka(r,n,o)}}};var xS={kernelName:$i,gradFunc:(r,t,e)=>{let{axis:n}=e;return{x:()=>se(r,n)}}};var L2={kernelName:Ps,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>ct(r,M(be(Z(e,"float32")),2))}}};var z2={kernelName:Wl,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>M(r,M(Z(e,"float32"),2))}}};var B2={kernelName:Bs,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[e,n]=t,o=pt(2);return{a:()=>M(r,M(o,lt(e,n))),b:()=>M(r,M(o,lt(n,e)))}}};var V2={kernelName:uo,gradFunc:r=>({x:()=>St(r)})};var G2={kernelName:Vs,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[e,n]=t,o=zt(e.shape,n.shape);return{a:()=>{let a=r,u=ge(e.shape,o);return u.length>0&&(a=mt(a,u)),O(a,e.shape)},b:()=>{let a=r,u=ge(n.shape,o);return u.length>0&&(a=mt(a,u)),O(Zt(a),n.shape)}}}};var W2={kernelName:Ls,inputsToSave:["x"],gradFunc:(r,t,e)=>{let[n]=t,o=n.shape.slice(),{axis:s}=e;mr(s,n.shape).forEach(l=>{o[l]=1});let a=O(r,o),u=M(a,lr(n.shape,"float32"));return{x:()=>u}}};var U2={kernelName:Gs,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>ct(r,Ut(Xa(e)))}}};var H2={kernelName:Ws,outputsToSave:[!0],gradFunc:(r,t)=>{let[e]=t;return{x:()=>M(lt(pt(1),Ut(e)),r)}}};var q2={kernelName:Yn,inputsToSave:["x"],gradFunc:(r,t,e)=>{let[n]=t,{reps:o}=e;return{x:()=>{let i=St(n);if(n.rank===1)for(let a=0;a<o[0];++a)i=J(i,Rt(r,[a*n.shape[0]],[n.shape[0]]));else if(n.rank===2)for(let a=0;a<o[0];++a)for(let u=0;u<o[1];++u)i=J(i,Rt(r,[a*n.shape[0],u*n.shape[1]],[n.shape[0],n.shape[1]]));else if(n.rank===3)for(let a=0;a<o[0];++a)for(let u=0;u<o[1];++u)for(let l=0;l<o[2];++l)i=J(i,Rt(r,[a*n.shape[0],u*n.shape[1],l*n.shape[2]],[n.shape[0],n.shape[1],n.shape[2]]));else if(n.rank===4)for(let a=0;a<o[0];++a)for(let u=0;u<o[1];++u)for(let l=0;l<o[2];++l)for(let c=0;c<o[3];++c)i=J(i,Rt(r,[a*n.shape[0],u*n.shape[1],l*n.shape[2],c*n.shape[3]],[n.shape[0],n.shape[1],n.shape[2],n.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${n.rank} tensors yet.`);return i}}}};var K2={kernelName:Us,gradFunc:(r,t,e)=>{let n=e,{perm:o}=n,s=kh(o);return{x:()=>Wt(r,s)}}};var j2={kernelName:Di,gradFunc:(r,t,e)=>{let n=e,{axis:o}=n;return{value:()=>Je(r,o)}}};var X2={kernelName:Ul,inputsToSave:["segmentIds"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>J5(r,e)}}};function J5(r,t){let e=fn(t,St(t)),n=yo(r,e),o=Tn(t,pt(0,"int32")),s=n.rank-o.rank;for(let a=0;a<s;++a)o=fr(o,a+1);o=Nr(o,lr(n.shape,"bool"));let i=St(n);return _e(o,n,i)}var Y2={kernelName:Ri,gradFunc:r=>({x:()=>St(r)})};var Q5=[ny,rA,nA,oA,sA,iA,aA,lA,uA,cA,pA,mA,dA,gA,xA,yA,bA,wA,vA,CA,IA,SA,NA,kA,_A,EA,AA,$A,DA,RA,b2,FA,OA,MA,PA,LA,BA,zA,VA,UA,HA,qA,KA,jA,XA,YA,ZA,JA,QA,e2,dS,dS,r2,o2,i2,a2,l2,u2,c2,p2,m2,f2,d2,h2,g2,hS,hS,x2,y2,w2,v2,C2,I2,S2,k2,N2,T2,_2,E2,A2,$2,D2,R2,F2,O2,M2,P2,gS,gS,xS,xS,L2,B2,z2,V2,G2,W2,U2,H2,q2,K2,j2,X2,Y2];for(let r of Q5)C1(r);L().prototype.abs=function(){return this.throwIfDisposed(),Ne(this)};L().prototype.acos=function(){return this.throwIfDisposed(),sh(this)};L().prototype.acosh=function(){return this.throwIfDisposed(),ih(this)};L().prototype.add=function(r){return this.throwIfDisposed(),J(this,r)};L().prototype.all=function(r,t){return this.throwIfDisposed(),Ku(this,r,t)};L().prototype.any=function(r,t){return this.throwIfDisposed(),Yl(this,r,t)};L().prototype.argMax=function(r){return this.throwIfDisposed(),js(this,r)};L().prototype.argMin=function(r){return this.throwIfDisposed(),ah(this,r)};L().prototype.asScalar=function(){return this.throwIfDisposed(),A(this.size===1,()=>"The array must have only 1 element."),O(this,[])};L().prototype.asType=function(r){return this.throwIfDisposed(),Z(this,r)};L().prototype.as1D=function(){return this.throwIfDisposed(),O(this,[this.size])};L().prototype.as2D=function(r,t){return this.throwIfDisposed(),O(this,[r,t])};L().prototype.as3D=function(r,t,e){return this.throwIfDisposed(),O(this,[r,t,e])};L().prototype.as4D=function(r,t,e,n){return this.throwIfDisposed(),O(this,[r,t,e,n])};L().prototype.as5D=function(r,t,e,n,o){return this.throwIfDisposed(),O(this,[r,t,e,n,o])};L().prototype.asin=function(){return this.throwIfDisposed(),lh(this)};L().prototype.asinh=function(){return this.throwIfDisposed(),uh(this)};L().prototype.atan=function(){return this.throwIfDisposed(),ch(this)};L().prototype.atan2=function(r){return this.throwIfDisposed(),ph(this,r)};L().prototype.atanh=function(){return this.throwIfDisposed(),mh(this)};L().prototype.avgPool=function(r,t,e,n){return this.throwIfDisposed(),qa(this,r,t,e,n)};L().prototype.batchToSpaceND=function(r,t){return this.throwIfDisposed(),Ka(this,r,t)};L().prototype.batchNorm=function(r,t,e,n,o){return this.throwIfDisposed(),xo(this,r,t,e,n,o)};L().prototype.broadcastTo=function(r){return this.throwIfDisposed(),ja(this,r)};L().prototype.cast=function(r){return this.throwIfDisposed(),Z(this,r)};L().prototype.ceil=function(){return this.throwIfDisposed(),hh(this)};L().prototype.clipByValue=function(r,t){return this.throwIfDisposed(),br(this,r,t)};L().prototype.concat=function(r,t){return this.throwIfDisposed(),r instanceof Pt&&(r=[r]),se([this,...r],t)};L().prototype.conv1d=function(r,t,e,n,o,s){return this.throwIfDisposed(),Yu(this,r,t,e,n,o,s)};L().prototype.conv2dTranspose=function(r,t,e,n,o){return this.throwIfDisposed(),Zu(this,r,t,e,n,o)};L().prototype.conv2d=function(r,t,e,n,o,s){return this.throwIfDisposed(),pn(this,r,t,e,n,o,s)};L().prototype.cos=function(){return this.throwIfDisposed(),Xa(this)};L().prototype.cosh=function(){return this.throwIfDisposed(),Ju(this)};L().prototype.cumprod=function(r,t,e){return this.throwIfDisposed(),xh(this,r,t,e)};L().prototype.cumsum=function(r,t,e){return this.throwIfDisposed(),Qu(this,r,t,e)};L().prototype.depthToSpace=function(r,t){return this.throwIfDisposed(),yh(this,r,t)};L().prototype.depthwiseConv2d=function(r,t,e,n,o,s){return this.throwIfDisposed(),Ys(this,r,t,e,n,o,s)};L().prototype.dilation2d=function(r,t,e,n,o){return this.throwIfDisposed(),bh(this,r,t,e,n,o)};L().prototype.divNoNan=function(r){return this.throwIfDisposed(),wh(this,r)};L().prototype.div=function(r){return this.throwIfDisposed(),ct(this,r)};L().prototype.dot=function(r){return this.throwIfDisposed(),zI(this,r)};L().prototype.elu=function(){return this.throwIfDisposed(),Zs(this)};L().prototype.equal=function(r){return this.throwIfDisposed(),Sr(this,r)};L().prototype.erf=function(){return this.throwIfDisposed(),vh(this)};L().prototype.exp=function(){return this.throwIfDisposed(),Ze(this)};L().prototype.expandDims=function(r){return this.throwIfDisposed(),fr(this,r)};L().prototype.expm1=function(){return this.throwIfDisposed(),Ch(this)};L().prototype.fft=function(){return this.throwIfDisposed(),ol(this)};L().prototype.flatten=function(){return this.throwIfDisposed(),O(this,[this.size])};L().prototype.floor=function(){return this.throwIfDisposed(),Qs(this)};L().prototype.floorDiv=function(r){return this.throwIfDisposed(),qu(this,r)};L().prototype.gather=function(r,t){return this.throwIfDisposed(),yo(this,r,t)};L().prototype.greaterEqual=function(r){return this.throwIfDisposed(),Tn(this,r)};L().prototype.greater=function(r){return this.throwIfDisposed(),Ge(this,r)};L().prototype.ifft=function(){return this.throwIfDisposed(),Gi(this)};L().prototype.irfft=function(){return this.throwIfDisposed(),fc(this)};L().prototype.isFinite=function(){return this.throwIfDisposed(),VI(this)};L().prototype.isInf=function(){return this.throwIfDisposed(),GI(this)};L().prototype.isNaN=function(){return this.throwIfDisposed(),Ih(this)};L().prototype.leakyRelu=function(r){return this.throwIfDisposed(),Ya(this,r)};L().prototype.lessEqual=function(r){return this.throwIfDisposed(),_n(this,r)};L().prototype.less=function(r){return this.throwIfDisposed(),ec(this,r)};L().prototype.localResponseNormalization=function(r,t,e,n){return this.throwIfDisposed(),Sh(this,r,t,e,n)};L().prototype.logSigmoid=function(){return this.throwIfDisposed(),UI(this)};L().prototype.logSoftmax=function(r){return this.throwIfDisposed(),rc(this,r)};L().prototype.logSumExp=function(r,t){return this.throwIfDisposed(),Nh(this,r,t)};L().prototype.log=function(){return this.throwIfDisposed(),wr(this)};L().prototype.log1p=function(){return this.throwIfDisposed(),Za(this)};L().prototype.logicalAnd=function(r){return this.throwIfDisposed(),Nr(this,r)};L().prototype.logicalNot=function(){return this.throwIfDisposed(),Ja(this)};L().prototype.logicalOr=function(r){return this.throwIfDisposed(),nc(this,r)};L().prototype.logicalXor=function(r){return this.throwIfDisposed(),XI(this,r)};L().prototype.matMul=function(r,t,e){return this.throwIfDisposed(),Lt(this,r,t,e)};L().prototype.maxPool=function(r,t,e,n){return this.throwIfDisposed(),Qa(this,r,t,e,n)};L().prototype.max=function(r,t){return this.throwIfDisposed(),Dr(this,r,t)};L().prototype.maximum=function(r){return this.throwIfDisposed(),fn(this,r)};L().prototype.mean=function(r,t){return this.throwIfDisposed(),xe(this,r,t)};L().prototype.min=function(r,t){return this.throwIfDisposed(),Zl(this,r,t)};L().prototype.minimum=function(r){return this.throwIfDisposed(),ti(this,r)};L().prototype.mirrorPad=function(r,t){return this.throwIfDisposed(),_h(this,r,t)};L().prototype.mod=function(r){return this.throwIfDisposed(),Eh(this,r)};L().prototype.mul=function(r){return this.throwIfDisposed(),M(this,r)};L().prototype.neg=function(){return this.throwIfDisposed(),Zt(this)};L().prototype.norm=function(r,t,e){return this.throwIfDisposed(),wm(this,r,t,e)};L().prototype.notEqual=function(r){return this.throwIfDisposed(),vo(this,r)};L().prototype.oneHot=function(r,t=1,e=0){return this.throwIfDisposed(),Ks(this,r,t,e)};L().prototype.onesLike=function(){return this.throwIfDisposed(),dr(this)};L().prototype.pad=function(r,t){return this.throwIfDisposed(),Yr(this,r,t)};L().prototype.pool=function(r,t,e,n,o,s){return this.throwIfDisposed(),JI(this,r,t,e,n,o,s)};L().prototype.pow=function(r){return this.throwIfDisposed(),Zr(this,r)};L().prototype.prelu=function(r){return this.throwIfDisposed(),el(this,r)};L().prototype.prod=function(r,t){return this.throwIfDisposed(),oc(this,r,t)};L().prototype.reciprocal=function(){return this.throwIfDisposed(),Ah(this)};L().prototype.relu=function(){return this.throwIfDisposed(),Tr(this)};L().prototype.relu6=function(){return this.throwIfDisposed(),ac(this)};L().prototype.reshapeAs=function(r){return this.throwIfDisposed(),O(this,r.shape)};L().prototype.reshape=function(r){return this.throwIfDisposed(),O(this,r)};L().prototype.resizeBilinear=function(r,t,e){return this.throwIfDisposed(),Qx(this,r,t,e)};L().prototype.resizeNearestNeighbor=function(r,t,e){return this.throwIfDisposed(),ty(this,r,t,e)};L().prototype.reverse=function(r){return this.throwIfDisposed(),ir(this,r)};L().prototype.rfft=function(){return this.throwIfDisposed(),sl(this)};L().prototype.round=function(){return this.throwIfDisposed(),lc(this)};L().prototype.rsqrt=function(){return this.throwIfDisposed(),uc(this)};L().prototype.selu=function(){return this.throwIfDisposed(),cc(this)};L().prototype.separableConv2d=function(r,t,e,n,o,s){return this.throwIfDisposed(),$h(this,r,t,e,n,o,s)};L().prototype.sigmoid=function(){return this.throwIfDisposed(),Lr(this)};L().prototype.sign=function(){return this.throwIfDisposed(),Dh(this)};L().prototype.sin=function(){return this.throwIfDisposed(),pc(this)};L().prototype.sinh=function(){return this.throwIfDisposed(),mc(this)};L().prototype.slice=function(r,t){return this.throwIfDisposed(),Rt(this,r,t)};L().prototype.softmax=function(r){return this.throwIfDisposed(),nl(this,r)};L().prototype.softplus=function(){return this.throwIfDisposed(),bo(this)};L().prototype.spaceToBatchND=function(r,t){return this.throwIfDisposed(),tl(this,r,t)};L().prototype.split=function(r,t){return this.throwIfDisposed(),ur(this,r,t)};L().prototype.sqrt=function(){return this.throwIfDisposed(),be(this)};L().prototype.square=function(){return this.throwIfDisposed(),Ut(this)};L().prototype.squaredDifference=function(r){return this.throwIfDisposed(),dc(this,r)};L().prototype.squeeze=function(r){return this.throwIfDisposed(),zr(this,r)};L().prototype.stack=function(r,t){this.throwIfDisposed();let e=r instanceof Pt?[this,r]:[this,...r];return Je(e,t)};L().prototype.step=function(r){return this.throwIfDisposed(),ri(this,r)};L().prototype.stridedSlice=function(r,t,e,n,o,s,i,a){return this.throwIfDisposed(),Oh(this,r,t,e,n,o,s,i,a)};L().prototype.sub=function(r){return this.throwIfDisposed(),lt(this,r)};L().prototype.sum=function(r,t){return this.throwIfDisposed(),mt(this,r,t)};L().prototype.tan=function(){return this.throwIfDisposed(),Mh(this)};L().prototype.tanh=function(){return this.throwIfDisposed(),Xs(this)};L().prototype.tile=function(r){return this.throwIfDisposed(),kr(this,r)};L().prototype.toBool=function(){return this.throwIfDisposed(),Z(this,"bool")};L().prototype.toFloat=function(){return this.throwIfDisposed(),Z(this,"float32")};L().prototype.toInt=function(){return this.throwIfDisposed(),Z(this,"int32")};L().prototype.topk=function(r,t){return this.throwIfDisposed(),Ph(this,r,t)};L().prototype.transpose=function(r){return this.throwIfDisposed(),Wt(this,r)};L().prototype.unique=function(r){return this.throwIfDisposed(),bm(this,r)};L().prototype.unsortedSegmentSum=function(r,t){return this.throwIfDisposed(),Lh(this,r,t)};L().prototype.unstack=function(r){return this.throwIfDisposed(),vr(this,r)};L().prototype.where=function(r,t){return this.throwIfDisposed(),_e(r,this,t)};L().prototype.zerosLike=function(){return this.throwIfDisposed(),St(this)};var r$={};Yt(r$,{maxNorm:()=>eX,minMaxNorm:()=>oX,nonNeg:()=>nX,unitNorm:()=>rX});var yS;function cr(){return yS==null&&(yS=W_().epsilon()),yS}function hn(){return"channelsLast"}var En=class extends Error{constructor(t){super(t),Object.setPrototypeOf(this,En.prototype)}},Wr=class extends Error{constructor(t){super(t),Object.setPrototypeOf(this,Wr.prototype)}},z=class extends Error{constructor(t){super(t),Object.setPrototypeOf(this,z.prototype)}},Nt=class extends Error{constructor(t){super(t),Object.setPrototypeOf(this,Nt.prototype)}},Cm=class extends Error{constructor(t){super(t),Object.setPrototypeOf(this,Cm.prototype)}};function ko(r,t){if(Array.isArray(r)){let e=[];for(let n=0;n<t;n++)e=e.concat(r);return e}else{let e=new Array(t);return e.fill(r),e}}function Qn(r,t){if(!r)throw new Cm(t)}function wS(r,t){let e=0;for(let n of r)n===t&&e++;return e}function _r(r){return r.length===1?r[0]:r}function we(r){return Array.isArray(r)?r:[r]}function No(r){let e=r.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return e[0]!=="_"?e:"private"+e}function il(r){return r.length<=1||r.indexOf("_")===-1?r:r.replace(/[_]+(\w|$)/g,(t,e)=>e.toUpperCase())}var So={};function Im(r){if(r==null)return null;let t={};return t.className=r.getClassName(),t.config=r.getConfig(),t}function bS(r){if(!(r==null||typeof r!="object"))if(Array.isArray(r))r.forEach(t=>bS(t));else{let t=Object.keys(r);for(let e of t){let n=r[e];n!=null&&typeof n=="object"&&(!Array.isArray(n)&&n.type==="ndarray"&&typeof n.value=="number"?r[e]=n.value:bS(n))}}}function Hi(r,t={},e={},n="object",o=!1){if(typeof r=="string"){let s=r,i;if(s in e)i=e[s];else if(s in So)i=So[s];else if(i=t[s],i==null)throw new z(`Unknown ${n}: ${r}. This may be due to one of the following reasons:
1. The ${n} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${n} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return i}else{let s=r;if(s.className==null||s.config==null)throw new z(`${n}: Improper config format: ${JSON.stringify(s)}.
'className' and 'config' must set.`);let i=s.className,a,u;if(i in e?[a,u]=e[i]:i in So?[a,u]=So.className:i in t&&([a,u]=t[i]),a==null)throw new z(`Unknown ${n}: ${i}. This may be due to one of the following reasons:
1. The ${n} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${n} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(u!=null){let l={};for(let f of Object.keys(So))l[f]=So[f];for(let f of Object.keys(e))l[f]=e[f];let c=s.config;c.customObjects=l;let p=Object.assign({},So);for(let f of Object.keys(e))So[f]=e[f];bS(s.config);let m=u(a,s.config,e,o);return So=Object.assign({},p),m}else{let l=Object.assign({},So);for(let p of Object.keys(e))So[p]=e[p];let c=new a(s.config);return So=Object.assign({},l),c}}}function tX(r,t){return r<t?-1:r>t?1:0}function Gh(r,t){return-1*tX(r,t)}function To(r){if(r==null)return r;let t=[];for(let e of r)t.indexOf(e)===-1&&t.push(e);return t}function Z2(r){if(r==null)throw new z(`Invalid value in obj: ${JSON.stringify(r)}`);for(let t in r)if(r.hasOwnProperty(t))return!1;return!0}function qi(r,t,e){if(e!=null&&r.indexOf(e)<0)throw new z(`${e} is not a valid ${t}.  Valid values are ${r} or null/undefined.`)}function sy(r,t,e=0,n=1/0){return Qn(e>=0),Qn(n>=e),Array.isArray(r)&&r.length>=e&&r.length<=n&&r.every(o=>typeof o===t)}function er(r,t){Array.isArray(r)?(x.assert(r.length>0,()=>`${t} is unexpectedly an empty array.`),r.forEach((e,n)=>er(e,`element ${n+1} of ${t}`))):x.assert(Number.isInteger(r)&&r>0,()=>`Expected ${t} to be a positive integer, but got ${J2(r)}.`)}function J2(r){return r===null?"null":Array.isArray(r)?"["+r.map(t=>J2(t)).join(",")+"]":typeof r=="string"?`"${r}"`:`${r}`}function Q2(r,t,e){let n=e!=null?e():x.now(),o;return(...i)=>{let a=e!=null?e():x.now();return a-n<t||(n=a,o=r(...i)),o}}function iy(r){return r==="relu"?"relu":r==="linear"?"linear":r==="elu"?"elu":null}function vS(r,t){return B(()=>be(mt(M(r,r),t,!0)))}var vc=class extends et.Serializable{getConfig(){return{}}},Sm=class extends vc{constructor(t){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=t.maxValue!=null?t.maxValue:this.defaultMaxValue,this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return B(()=>{let e=vS(t,this.axis),n=br(e,0,this.maxValue);return M(t,ct(n,J(cr(),e)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}};Sm.className="MaxNorm";et.registerClass(Sm);var km=class extends vc{constructor(t){super(),this.defaultAxis=0,this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return B(()=>ct(t,J(cr(),vS(t,this.axis))))}getConfig(){return{axis:this.axis}}};km.className="UnitNorm";et.registerClass(km);var Nm=class extends vc{apply(t){return Tr(t)}};Nm.className="NonNeg";et.registerClass(Nm);var Tm=class extends vc{constructor(t){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=t.minValue!=null?t.minValue:this.defaultMinValue,this.maxValue=t.maxValue!=null?t.maxValue:this.defaultMaxValue,this.rate=t.rate!=null?t.rate:this.defaultRate,this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return B(()=>{let e=vS(t,this.axis),n=J(M(this.rate,br(e,this.minValue,this.maxValue)),M(1-this.rate,e));return M(t,ct(n,J(cr(),e)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}};Tm.className="MinMaxNorm";et.registerClass(Tm);var t$={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function We(r){return Im(r)}function e$(r,t={}){return Hi(r,et.SerializationMap.getMap().classNameMap,t,"constraint")}function Ue(r){if(r==null)return null;if(typeof r=="string"){let e={className:r in t$?t$[r]:r,config:{}};return e$(e)}else return r instanceof vc?r:e$(r)}function eX(r){return new Sm(r)}function rX(r){return new km(r)}function nX(){return new Nm}function oX(r){return new Tm(r)}var C$={};Yt(C$,{constant:()=>mX,glorotNormal:()=>bX,glorotUniform:()=>yX,heNormal:()=>wX,heUniform:()=>vX,identity:()=>gX,leCunNormal:()=>CX,leCunUniform:()=>IX,ones:()=>pX,orthogonal:()=>SX,randomNormal:()=>dX,randomUniform:()=>fX,truncatedNormal:()=>hX,varianceScaling:()=>xX,zeros:()=>cX});var n$=["channelsFirst","channelsLast"],o$=["nearest","bilinear"],s$=["valid","same","causal"],i$=["max","avg"],a$=["sum","mul","concat","ave"];var _m=new Map;function Le(r){qi(n$,"DataFormat",r)}function u$(r){qi(o$,"InterpolationFormat",r)}function gn(r){qi(s$,"PaddingMode",r)}function CS(r){qi(i$,"PoolMode",r)}var Wh=[],l$="/";function si(r,t){Wh.push(r);try{let e=t();return Wh.pop(),e}catch(e){throw Wh.pop(),e}}function sX(){return Wh.length===0?"":Wh.join(l$)+l$}function ay(r){if(!c$(r))throw new Error("Not a valid tensor name: '"+r+"'");return sX()+r}function ly(r){if(!c$(r))throw new Error("Not a valid tensor name: '"+r+"'");_m.has(r)||_m.set(r,0);let t=_m.get(r);if(_m.set(r,_m.get(r)+1),t>0){let e=`${r}_${t}`;return _m.set(e,1),e}else return r}var iX=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function c$(r){return!!r.match(iX)}function p$(r){return r===parseInt(r.toString(),10)}function _o(r,t,e){t==null&&(t=0),e==null&&(e=r.length);let n=1;for(let o=t;o<e;++o)n*=r[o];return n}function Cc(r){if(r.length===0)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let e=0;e<r.length;e++){let n=r[e];n<t&&(t=n)}return t}function ii(r){if(r.length===0)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let e=0;e<r.length;e++){let n=r[e];n>t&&(t=n)}return t}function Jr(r,t){if(t<r)throw new z(`end (${t}) < begin (${r}) is forbidden.`);let e=[];for(let n=r;n<t;++n)e.push(n);return e}function Ic(r,t){return Z(r,t)}function ll(r,t=-1){let e=r.shape.slice();return t<0&&(t=e.length+t+1),e.splice(t,0,1),O(r,e)}function m$(r,t){return B(()=>{if(r.shape.length!==2)throw new z(`repeat() expects a rank-2 tensor, but received a rank-${r.shape.length} tensor.`);let e=ll(r,1);return cy(e,[1,t,1])})}function f$(r){let t=[_o(r.shape)];return O(r,t)}function d$(r){if(r.rank<=1)throw new z(`batchFlatten requires a minimum rank of 2. Got rank: ${r.rank}.`);let t=[r.shape[0],_o(r.shape,1)];return O(r,t)}function al(r,t,e){return B(()=>{switch(r.rank){case 1:return Rh(r,t,e);case 2:return Gx(r,[t,0],[e,r.shape[1]]);case 3:return Fh(r,[t,0,0],[e,r.shape[1],r.shape[2]]);case 4:return ym(r,[t,0,0,0],[e,r.shape[1],r.shape[2],r.shape[3]]);case 5:return Rt(r,[t,0,0,0,0],[e,r.shape[1],r.shape[2],r.shape[3],r.shape[4]]);case 6:return Rt(r,[t,0,0,0,0,0],[e,r.shape[1],r.shape[2],r.shape[3],r.shape[4],r.shape[5]]);default:throw new z(`sliceAlongFirstAxis() received an unsupported tensor rank: ${r.rank}`)}})}function IS(r,t,e){return B(()=>{switch(r.rank){case 1:return Rh(r,t,e);case 2:return Gx(r,[0,t],[r.shape[0],e]);case 3:return Fh(r,[0,0,t],[r.shape[0],r.shape[1],e]);case 4:return ym(r,[0,0,0,t],[r.shape[0],r.shape[1],r.shape[2],e]);default:throw new z(`sliceAlongLastAxis() received an unsupported tensor rank: ${r.rank}`)}})}function Uh(r,t,e,n){return B(()=>{switch(r.rank){case 1:return Rh(r,t,e);case 2:switch(n){case 1:return al(r,t,e);case 2:return IS(r,t,e);default:throw new z(`The axis is not within the rank of the tensor ${n}`)}case 3:switch(n){case 1:return al(r,t,e);case 2:return Fh(r,[0,t,0],[r.shape[0],e,r.shape[2]]);case 3:return IS(r,t,e);default:throw new z(`The axis is not within the rank of the tensor ${n}`)}case 4:switch(n){case 1:return al(r,t,e);case 2:return ym(r,[0,t,0,0],[r.shape[0],e,r.shape[2],r.shape[3]]);case 3:return ym(r,[0,0,t,0],[r.shape[0],r.shape[1],e,r.shape[3]]);case 4:return IS(r,t,e);default:throw new z(`The axis is not within the rank of the tensor ${n}`)}default:throw new z(`sliceAlongLastAxis() received an unsupported tensor rank: ${r.rank}`)}})}function Em(r,t=-1){let e;return t<0&&(e=r[0].rank,e!==0?t=e:t=0),t===r[0].rank&&(t=-1),se(r,t)}function kS(r,t){switch(r.rank){case 1:return RI([r,t]);case 2:return FI([r,t],0);case 3:return OI([r,t],0);case 4:return MI([r,t],0);default:throw new z(`concatAlongFirstAxis() received an unsupported tensor rank: ${r.rank}`)}}function cy(r,t){if(Array.isArray(t)||(t=[t]),r.rank!==t.length)throw new z(`The length of input n (${t.length}) does not match the number of dimensions in input x (${r.rank})`);return kr(r,t)}function Am(r,t=0,e=1,n,o){return Vx(r,t,e,n,o)}function Eo(r,t,e,n){if(r.rank<2||t.rank<2)throw new Nt(`dot requires both inputs to be rank >= 2 but got x shape = ${r.shape} and y shape = ${t.shape}`);if(t.rank>=3){let o=r.shape.slice(-1)[0],s=t.shape.slice(-2)[0];if(o!==s)throw new Nt(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${r.shape} and  y shape = ${t.shape}`)}if(r.rank===2&&t.rank===2)return Co.matMul({a:r,b:t,transposeA:!1,transposeB:!1,bias:n?SS(r.rank,n,hn()):null,activation:e});{let o=r.shape.slice(),s=o.pop();r=O(r,[-1,s]);let i=t.shape.slice(),a=i.pop(),u=i.pop(),l=[...i,a],c=Array.from({length:t.rank},(d,h)=>h===0?t.rank-2:h<=t.rank-2?h-1:h);t=O(Wt(t,c),[u,-1]);let p=[...o,...l],m=!1,f=!1;return O(Co.matMul({a:r,b:t,transposeA:m,transposeB:f,bias:n?SS(r.rank,n,hn()):null,activation:e}),p)}}function py(r,t,e){return B(()=>(Array.isArray(t)?t=Re(t,"int32"):t=Z(t,"int32"),yo(r,t,e)))}function Sc(r){return M(r,r)}function SS(r,t,e){let n=t.shape;if(t.rank!==1&&t.rank!==r)throw new z(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${r}`);if(r===5){if(e==="channelsFirst")return n.length===1?O(t,[1,n[0],1,1,1]):O(t,[1,n[3],n[0],n[1],n[2]]);if(e==="channelsLast")return n.length===1?O(t,[1,1,1,1,n[0]]):O(t,[1].concat(n))}else if(r===4){if(e==="channelsFirst")return n.length===1?O(t,[1,n[0],1,1]):O(t,[1,n[2],n[0],n[1]]);if(e==="channelsLast")return n.length===1?O(t,[1,1,1,n[0]]):O(t,[1].concat(n))}else if(r===3){if(e==="channelsFirst")return n.length===1?O(t,[1,n[0],1]):O(t,[1,n[1],n[0]]);if(e==="channelsLast")return n.length===1?O(t,[1,1,n[0]]):O(t,[1].concat(n))}else if(r<3)return t;throw new z(`Unsupported input rank by biasAdd: ${t.rank}`)}function xn(r,t,e){return B(()=>(e==null&&(e=hn()),Le(e),J(r,SS(r.rank,t,e))))}function h$(r,t=1){if(t!==1)throw new Nt(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return Zs(r)}function g$(r){return B(()=>ct(r,J(Ne(r),1)))}function my(r,t,e,n){return B(()=>fE(r,t,e,n))}function x$(r){return B(()=>{let t=J(.5,M(.2,r));return br(t,0,1)})}function su(r,t,e=!1){return e?r():t()}var y$=["fanIn","fanOut","fanAvg"],b$=["normal","uniform","truncatedNormal"];function aX(r){qi(y$,"FanMode",r)}function lX(r){qi(b$,"Distribution",r)}var bn=class extends et.Serializable{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}},$m=class extends bn{apply(t,e){return ye(t,e)}};$m.className="Zeros";et.registerClass($m);var iu=class extends bn{apply(t,e){return lr(t,e)}};iu.className="Ones";et.registerClass(iu);var Dm=class extends bn{constructor(t){if(super(),typeof t!="object")throw new z(`Expected argument of type ConstantConfig but got ${t}`);if(t.value===void 0)throw new z(`config must have value set but got ${t}`);this.value=t.value}apply(t,e){return B(()=>M(pt(this.value),lr(t,e)))}getConfig(){return{value:this.value}}};Dm.className="Constant";et.registerClass(Dm);var Rm=class extends bn{constructor(t){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=t.minval||this.DEFAULT_MINVAL,this.maxval=t.maxval||this.DEFAULT_MAXVAL,this.seed=t.seed}apply(t,e){return ei(t,this.minval,this.maxval,e)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}};Rm.className="RandomUniform";et.registerClass(Rm);var Fm=class extends bn{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,e){if(e=e||"float32",e!=="float32"&&e!=="int32")throw new Nt(`randomNormal does not support dType ${e}.`);return Am(t,this.mean,this.stddev,e,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};Fm.className="RandomNormal";et.registerClass(Fm);var Om=class extends bn{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,e){if(e=e||"float32",e!=="float32"&&e!=="int32")throw new Nt(`truncatedNormal does not support dType ${e}.`);return hc(t,this.mean,this.stddev,e,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};Om.className="TruncatedNormal";et.registerClass(Om);var Mm=class extends bn{constructor(t){super(),this.gain=t.gain!=null?t.gain:1}apply(t,e){return B(()=>{if(t.length!==2||t[0]!==t[1])throw new z("Identity matrix initializer can only be used for 2D square matrices.");return M(this.gain,gm(t[0]))})}getConfig(){return{gain:this.gain}}};Mm.className="Identity";et.registerClass(Mm);function uX(r,t="channelsLast"){let e,n;if(Le(t),r.length===2)e=r[0],n=r[1];else if([3,4,5].indexOf(r.length)!==-1){if(t==="channelsFirst"){let o=_o(r,2);e=r[1]*o,n=r[0]*o}else if(t==="channelsLast"){let o=_o(r,0,r.length-2);e=r[r.length-2]*o,n=r[r.length-1]*o}}else{let o=_o(r);e=Math.sqrt(o),n=Math.sqrt(o)}return[e,n]}var Ur=class extends bn{constructor(t){if(super(),t.scale<0)throw new z(`scale must be a positive float. Got: ${t.scale}`);this.scale=t.scale==null?1:t.scale,this.mode=t.mode==null?"fanIn":t.mode,aX(this.mode),this.distribution=t.distribution==null?"normal":t.distribution,lX(this.distribution),this.seed=t.seed}apply(t,e){let n=uX(t),o=n[0],s=n[1],i=this.scale;if(this.mode==="fanIn"?i/=Math.max(1,o):this.mode==="fanOut"?i/=Math.max(1,s):i/=Math.max(1,(o+s)/2),this.distribution==="normal"){let a=Math.sqrt(i);if(e=e||"float32",e!=="float32"&&e!=="int32")throw new Nt(`${this.getClassName()} does not support dType ${e}.`);return hc(t,0,a,e,this.seed)}else{let a=Math.sqrt(3*i);return ei(t,-a,a,e)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}};Ur.className="VarianceScaling";et.registerClass(Ur);var kc=class extends Ur{constructor(t){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return Ur.className}};kc.className="GlorotUniform";et.registerClass(kc);var Nc=class extends Ur{constructor(t){super({scale:1,mode:"fanAvg",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return Ur.className}};Nc.className="GlorotNormal";et.registerClass(Nc);var Tc=class extends Ur{constructor(t){super({scale:2,mode:"fanIn",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return Ur.className}};Tc.className="HeNormal";et.registerClass(Tc);var _c=class extends Ur{constructor(t){super({scale:2,mode:"fanIn",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return Ur.className}};_c.className="HeUniform";et.registerClass(_c);var Ec=class extends Ur{constructor(t){super({scale:1,mode:"fanIn",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return Ur.className}};Ec.className="LeCunNormal";et.registerClass(Ec);var Ac=class extends Ur{constructor(t){super({scale:1,mode:"fanIn",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return Ur.className}};Ac.className="LeCunNormal";et.registerClass(Ac);var Pm=class extends bn{constructor(t){if(super(),this.DEFAULT_GAIN=1,this.gain=t.gain==null?this.DEFAULT_GAIN:t.gain,this.seed=t.seed,this.seed!=null)throw new Nt("Random seed is not implemented for Orthogonal Initializer yet.")}apply(t,e){return B(()=>{if(t.length<2)throw new Nt("Shape must be at least 2D.");t[0]*t[1]>2e3&&console.warn(`Orthogonal initializer is being called on a matrix with more than 2000 (${t[0]*t[1]}) elements: Slowness may result.`);let n=t[0]>t[1]?[t[1],t[0]]:t,o=Am(n,0,1,"float32"),s=QE.gramSchmidt(o);return t[0]>t[1]&&(s=Wt(s)),M(this.gain,s)})}getConfig(){return{gain:this.gain,seed:this.seed}}};Pm.className="Orthogonal";et.registerClass(Pm);var w$={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function v$(r,t={}){return Hi(r,et.SerializationMap.getMap().classNameMap,t,"initializer")}function Ee(r){return Im(r)}function de(r){if(typeof r=="string"){let t=r in w$?w$[r]:r;if(t==="GlorotNormal")return new Nc;if(t==="GlorotUniform")return new kc;if(t==="HeNormal")return new Tc;if(t==="HeUniform")return new _c;if(t==="LeCunNormal")return new Ec;if(t==="LeCunUniform")return new Ac;{let e={};return e.className=t,e.config={},v$(e)}}else return r instanceof bn?r:v$(r)}function cX(){return new $m}function pX(){return new iu}function mX(r){return new Dm(r)}function fX(r){return new Rm(r)}function dX(r){return new Fm(r)}function hX(r){return new Om(r)}function gX(r){return new Mm(r)}function xX(r){return new Ur(r)}function yX(r){return new kc(r)}function bX(r){return new Nc(r)}function wX(r){return new Tc(r)}function vX(r){return new _c(r)}function CX(r){return new Ec(r)}function IX(r){return new Ac(r)}function SX(r){return new Pm(r)}var oD={};Yt(oD,{Layer:()=>Bt,RNN:()=>$n,RNNCell:()=>fl,activation:()=>Y8,add:()=>sY,alphaDropout:()=>GY,average:()=>iY,averagePooling1d:()=>VS,averagePooling2d:()=>GS,averagePooling3d:()=>WS,avgPool1d:()=>hY,avgPool2d:()=>xY,avgPool3d:()=>bY,avgPooling1d:()=>gY,avgPooling2d:()=>yY,avgPooling3d:()=>wY,batchNormalization:()=>mY,bidirectional:()=>FY,concatenate:()=>aY,conv1d:()=>V8,conv2d:()=>G8,conv2dTranspose:()=>W8,conv3d:()=>U8,conv3dTranspose:()=>H8,convLstm2d:()=>AY,convLstm2dCell:()=>$Y,cropping2D:()=>K8,dense:()=>Z8,depthwiseConv2d:()=>X8,dot:()=>pY,dropout:()=>J8,elu:()=>O8,embedding:()=>oY,flatten:()=>tY,gaussianDropout:()=>VY,gaussianNoise:()=>BY,globalAveragePooling1d:()=>vY,globalAveragePooling2d:()=>CY,globalMaxPool1d:()=>MY,globalMaxPool2d:()=>PY,globalMaxPooling1d:()=>tD,globalMaxPooling2d:()=>eD,gru:()=>SY,gruCell:()=>kY,input:()=>OS,inputLayer:()=>F8,layerNormalization:()=>fY,leakyReLU:()=>P8,lstm:()=>NY,lstmCell:()=>TY,masking:()=>WY,maxPool1d:()=>LY,maxPool2d:()=>zY,maxPooling1d:()=>rD,maxPooling2d:()=>nD,maxPooling3d:()=>IY,maximum:()=>lY,minimum:()=>uY,multiply:()=>cY,permute:()=>nY,prelu:()=>L8,reLU:()=>M8,repeatVector:()=>eY,reshape:()=>rY,rnn:()=>DY,separableConv2d:()=>q8,simpleRNN:()=>_Y,simpleRNNCell:()=>EY,softmax:()=>z8,spatialDropout1d:()=>Q8,stackedRNNCells:()=>RY,thresholdedReLU:()=>B8,timeDistributed:()=>OY,upSampling2d:()=>j8,zeroPadding2d:()=>dY});var kX=0;function dy(){return kX++}var fy={};function au(r=""){return r in fy||(fy[r]=0),fy[r]+=1,r+fy[r].toString()}function hy(r){return Array.isArray(r)&&Array.isArray(r[0])}function Lm(r){return r.length===0?[]:Array.isArray(r[0])?r:[r]}function Mt(r){let t;if(Array.isArray(r)){if(r.length!==1)throw new z(`Expected Tensor length to be 1; got ${r.length}`);t=r[0]}else t=r;return t}function Jt(r){if(Array.isArray(r)&&Array.isArray(r[0])){if(r.length===1)return r=r,r[0];throw new z(`Expected exactly 1 Shape; got ${r.length}`)}else return r}function zm(r){let t=0;for(let e of r)e.shape.length===0?t+=1:t+=e.shape.reduce((n,o)=>n*o);return t}var S$="Variable",Hh=class{constructor(t,e="float32",n=S$,o=!0,s=null){this.dtype=e==null?"float32":e,this.shape=t.shape,this.id=dy(),n=n==null?S$:n,this.originalName=ay(n),this.name=ly(this.originalName),this.trainable_=o,this.constraint=s,this.val=lS(t,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(t){return this.assertNotDisposed(),TX(this.val,t),this.val.id!==t.id&&(this.val.assign(t),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(t){this.trainable_=t,this.val.trainable=t}};function TX(r,t){if(r.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(r.shape)+" vs. "+JSON.stringify(t.shape))}function qh(r){return r.map(t=>t.read())}function Bm(r){r.forEach(t=>{t[0].write(t[1])})}var ve=class{constructor(t){this.dtype=t.dtype,this.shape=t.shape,t.shape!=null?this.ndim=t.shape.length:this.ndim=t.ndim,this.maxNDim=t.maxNDim,this.minNDim=t.minNDim,this.axes=t.axes||{}}},Qr=class{constructor(t,e,n,o,s,i,a){this.dtype=t,this.shape=e,this.sourceLayer=n,this.inputs=o,this.callArgs=s,this.outputTensorIndex=a,this.id=dy(),i!=null&&(this.originalName=ay(i),this.name=ly(this.originalName)),this.rank=e.length}},_X=0,ul=class{constructor(t,e){this.callArgs=e,this.id=_X++,this.outboundLayer=t.outboundLayer,this.inboundLayers=t.inboundLayers,this.nodeIndices=t.nodeIndices,this.tensorIndices=t.tensorIndices,this.inputTensors=t.inputTensors,this.outputTensors=t.outputTensors,this.inputMasks=t.inputMasks,this.outputMasks=t.outputMasks,this.inputShapes=t.inputShapes,this.outputShapes=t.outputShapes;for(let n of t.inboundLayers)n!=null&&n.outboundNodes.push(this);t.outboundLayer.inboundNodes.push(this)}getConfig(){let t=[];for(let e of this.inboundLayers)e!=null?t.push(e.name):t.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:t,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}},EX=0,Bt=class extends et.Serializable{constructor(t={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=EX++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let e=t.name;if(!e){let n=this.getClassName();e=No(n)+"_"+au(n)}if(this.name=e,this.trainable_=t.trainable==null?!0:t.trainable,t.inputShape!=null||t.batchInputShape!=null){let n;if(t.batchInputShape!=null)n=t.batchInputShape;else if(t.inputShape!=null){let s=null;t.batchSize!=null&&(s=t.batchSize),n=[s].concat(t.inputShape)}this.batchInputShape=n;let o=t.dtype;o==null&&(o=t.inputDType),o==null&&(o="float32"),this.dtype=o}t.weights!=null?this.initialWeights=t.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(t,e){return t.name+"_ib-"+e.toString()}getNodeAtIndex(t,e){if(this.inboundNodes.length===0)throw new Wr(`The layer has never been called and thus has no defined ${e}.`);if(this.inboundNodes.length<=t)throw new z(`Asked to get ${e} at node ${t}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[t]}getInputAt(t){return _r(this.getNodeAtIndex(t,"input").inputTensors)}getOutputAt(t){return _r(this.getNodeAtIndex(t,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new En(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new En(`Layer ${this.name} is not connected, no input to return.`);return _r(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new En(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new En(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return _r(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(t=>t())}get updates(){return this._updates}get built(){return this._built}set built(t){this._built=t}get trainable(){return this.trainable_}set trainable(t){this._trainableWeights.forEach(e=>e.trainable=t),this.trainable_=t}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(t=>t.trainable):[]}set trainableWeights(t){this._trainableWeights=t}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(t=>!t.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(t){this._nonTrainableWeights=t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(t){if(t=we(t),this.inputSpec==null||this.inputSpec.length===0)return;let e=we(this.inputSpec);if(t.length!==e.length)throw new z(`Layer ${this.name} expects ${e.length} inputs, but it received ${t.length} input tensors. Input received: ${t}`);for(let n=0;n<t.length;n++){let o=t[n],s=e[n];if(s==null)continue;let i=o.rank;if(s.ndim!=null&&i!==s.ndim)throw new z(`Input ${n} is incompatible with layer ${this.name}: expected ndim=${s.ndim}, found ndim=${i}`);if(s.maxNDim!=null&&i>s.maxNDim)throw new z(`Input ${n} is incompatible with layer ${this.name}: expected max_ndim=${s.maxNDim}, found ndim=${i}`);if(s.minNDim!=null&&i<s.minNDim)throw new z(`Input ${n} is incompatible with layer ${this.name}: expected min_ndim=${s.minNDim}, found ndim=${i}.`);if(s.dtype!=null&&o.dtype!==s.dtype)throw new z(`Input ${n} is incompatible with layer ${this.name} : expected dtype=${s.dtype}, found dtype=${o.dtype}.`);if(s.axes){let a=o.shape;for(let u in s.axes){let l=Number(u),c=s.axes[u],p=l>=0?a[l]:a[a.length+l];if(c!=null&&[c,null].indexOf(p)===-1)throw new z(`Input ${n} is incompatible with layer ${this.name}: expected axis ${l} of input shape to have value ${c} but got shape ${a}.`)}}if(s.shape!=null)for(let a=0;a<s.shape.length;++a){let u=s.shape[a],l=o.shape[a];if(u!=null&&l!=null&&u!==l)throw new z(`Input ${n} is incompatible with layer ${this.name}: expected shape=${s.shape}, found shape=${o.shape}.`)}}}call(t,e){return t}invokeCallHook(t,e){this._callHook!=null&&this._callHook(t,e)}setCallHook(t){this._callHook=t}clearCallHook(){this._callHook=null}apply(t,e){e=e||{},this.assertNotDisposed();let n=we(t),o=!0;for(let i of n)if(!(i instanceof Qr)){o=!1;break}let s=!0;for(let i of n)if(i instanceof Qr){s=!1;break}if(o===s)throw new z("Arguments to apply() must be all SymbolicTensors or all Tensors");return si(this.name,()=>{if(!this.built){this.assertInputCompatibility(t);let i=[];for(let a of we(t))i.push(a.shape);this.build(_r(i)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&s&&(this._refCount=1)}if(this.assertInputCompatibility(t),s){let i=this.call(t,e),a=we(i),u=[];for(let l of a)n.indexOf(l)!==-1&&(l=l.clone()),u.push(l);if(i=_r(u),this.activityRegularizer!=null)throw new Nt("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return i}else{let i=AX(t),a=this.computeOutputShape(i),u,l=$X(t);if(this.warnOnIncompatibleInputShape(Array.isArray(t)?i[0]:i),a!=null&&a.length>0&&Array.isArray(a[0])?u=a.map((c,p)=>new Qr(l,c,this,we(t),e,this.name,p)):u=new Qr(l,a,this,we(t),e,this.name),this.addInboundNode(t,u,null,null,i,a,e),this._refCount++,this.activityRegularizer!=null)throw new Nt("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return u}})}warnOnIncompatibleInputShape(t){if(this.batchInputShape!=null)if(t.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(t)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let e=!1;this.batchInputShape.forEach((n,o)=>{n!=null&&t[o]!=null&&t[o]!==n&&(e=!0)}),e&&console.warn(`The shape of the input tensor (${JSON.stringify(t)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new En(`The layer ${this.name} has never been called and thus has no defined output shape.`);let t=[];for(let e of this.inboundNodes){let n=JSON.stringify(e.outputShapes);t.indexOf(n)===-1&&t.push(n)}if(t.length===1){let e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&e.length===1?e[0]:e}else throw new En(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new Wr(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return zm(this.weights)}build(t){this.built=!0}getWeights(t=!1){return qh(t?this.trainableWeights:this.weights)}setWeights(t){B(()=>{let e=this.weights;if(e.length!==t.length)throw new z(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${t.length}, but the layer was expecting ${e.length} weights. Provided weights: ${t}...`);if(e.length===0)return;let n=[],o=qh(e);for(let s=0;s<o.length;++s){let i=o[s],a=e[s],u=t[s];if(!x.arraysEqual(i.shape,u.shape))throw new z(`Layer weight shape ${i.shape} not compatible with provided weight shape ${u.shape}`);n.push([a,u])}Bm(n)})}addWeight(t,e,n,o,s,i,a,u){if(this._addedWeightNames.indexOf(t)!==-1)throw new z(`Duplicate weight name ${t} for layer ${this.name}`);this._addedWeightNames.push(t),n==null&&(n="float32"),this.fastWeightInitDuringBuild&&(o=u!=null?u():de("zeros"));let l=o.apply(e,n),c=new Hh(l,n,t,i,a);return l.dispose(),s!=null&&this.addLoss(()=>s.apply(c.read())),i==null&&(i=!0),i?this._trainableWeights.push(c):this._nonTrainableWeights.push(c),c}setFastWeightInitDuringBuild(t){this.fastWeightInitDuringBuild=t}addLoss(t){t==null||Array.isArray(t)&&t.length===0||(t=we(t),this._losses!==void 0&&this._losses!==null&&this.losses.push(...t))}computeOutputShape(t){return t}computeMask(t,e){if(!this.supportsMasking){if(e!=null)if(Array.isArray(e))e.forEach(n=>{if(n!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return e}addInboundNode(t,e,n,o,s,i,a=null){let u=we(t);e=we(e),n=we(n),o=we(o),s=Lm(s),i=Lm(i);let l=[],c=[],p=[];for(let m of u)l.push(m.sourceLayer),c.push(m.nodeIndex),p.push(m.tensorIndex);new ul({outboundLayer:this,inboundLayers:l,nodeIndices:c,tensorIndices:p,inputTensors:u,outputTensors:e,inputMasks:n,outputMasks:o,inputShapes:s,outputShapes:i},a);for(let m=0;m<e.length;m++)e[m].sourceLayer=this,e[m].nodeIndex=this.inboundNodes.length-1,e[m].tensorIndex=m}getConfig(){let t={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(t.batchInputShape=this.batchInputShape),this.dtype!=null&&(t.dtype=this.dtype),t}disposeWeights(){return this.weights.forEach(t=>t.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let t=0;return--this._refCount===0&&(t=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:t}}};function AX(r){r=we(r);let t=[];for(let e of r)t.push(e.shape);return _r(t)}function $X(r){return"float32"}function NS(r,t,e){if((t==null||e!=null&&e>0)&&(t=r.sourceLayer,e=r.nodeIndex),t.inboundNodes.length===0)return[r];{let n=t.inboundNodes[e];if(n.inboundLayers.length===0)return n.inputTensors;{let o=[];for(let s=0;s<n.inboundLayers.length;s++){let i=n.inputTensors[s],a=n.inboundLayers[s],u=n.nodeIndices[s],l=NS(i,a,u);for(let c of l)o.indexOf(c)===-1&&o.push(c)}return o}}}var ai=class extends Bt{constructor(t){if(super({dtype:t.dtype,name:t.name!=null?t.name:au("input").toString()}),t.batchSize==null&&(t.batchSize=null),t.sparse==null&&(t.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=t.sparse,t.inputShape!=null&&t.batchInputShape!=null)throw new z("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let e=t.batchInputShape;if(e==null){if(t.inputShape==null)throw new z("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");e=[t.batchSize].concat(t.inputShape)}else if(t.batchSize!=null)throw new z("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");let n=t.dtype||"float32";this.batchInputShape=e,this.dtype=n,this.inputSpec=[{shape:e}];let o=new Qr(this.dtype,this.batchInputShape,this,[],{},this.name);o.nodeIndex=0,o.tensorIndex=0,new ul({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[o],outputTensors:[o],inputMasks:[null],outputMasks:[null],inputShapes:[e],outputShapes:[e]})}apply(t,e){throw new z(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}};ai.className="InputLayer";et.registerClass(ai);function gy(r){if(r.batchShape==null&&r.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(r.batchShape!=null&&r.shape!=null)throw new z("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=r.batchShape;r.shape!=null&&t==null&&(t=[null].concat(r.shape));let e=r.dtype;return e==null&&(e="float32"),new ai({batchInputShape:t,name:r.name,dtype:e,sparse:r.sparse}).inboundNodes[0].outputTensors[0]}async function Ki(r){if(r==null)return;let t=[],e=[],n=[];for(let o in r){let s=r[o];if(typeof s!="number"){let i=s;t.push(i.data()),e.push(o),n.push(i)}}if(t.length>0){let o=await Promise.all(t);for(let s=0;s<o.length;++s)r[e[s]]=o[s][0];_t(n)}}function xy(r){if(r!=null)for(let t in r){let e=r[t];typeof e!="number"&&e.dispose()}}var k$;(function(r){r[r.SILENT=0]="SILENT",r[r.VERBOSE=1]="VERBOSE"})(k$||(k$={}));var DX=125,cl=class{constructor(){this.validationData=null}setParams(t){this.params=t}async onEpochBegin(t,e){}async onEpochEnd(t,e){}async onBatchBegin(t,e){}async onBatchEnd(t,e){}async onTrainBegin(t){}async onTrainEnd(t){}setModel(t){}},yy=class{constructor(t,e=10){t==null&&(t=[]),this.callbacks=t,this.queueLength=e}append(t){this.callbacks.push(t)}setParams(t){for(let e of this.callbacks)e.setParams(t)}setModel(t){for(let e of this.callbacks)e.setModel(t)}async onEpochBegin(t,e){e==null&&(e={});for(let n of this.callbacks)await n.onEpochBegin(t,e)}async onEpochEnd(t,e){e==null&&(e={});for(let n of this.callbacks)await n.onEpochEnd(t,e)}async onBatchBegin(t,e){e==null&&(e={});for(let n of this.callbacks)await n.onBatchBegin(t,e)}async onBatchEnd(t,e){e==null&&(e={});for(let n of this.callbacks)await n.onBatchEnd(t,e)}async onTrainBegin(t){t==null&&(t={});for(let e of this.callbacks)await e.onTrainBegin(t)}async onTrainEnd(t){t==null&&(t={});for(let e of this.callbacks)await e.onTrainEnd(t)}},TS=class extends cl{constructor(){super()}async onEpochBegin(t){this.seen=0,this.totals={}}async onBatchEnd(t,e){e==null&&(e={});let n=e.size==null?0:e.size;this.seen+=n;for(let o in e){let s=e[o];if(typeof s=="number")this.totals.hasOwnProperty(o)||(this.totals[o]=0),this.totals[o]=this.totals[o]+s*n;else{let i;o in this.totals?i=this.totals[o]:this.totals[o]=0;let a=B(()=>J(this.totals[o],M(s,n)));this.totals[o]=a,i!=null&&i.dispose()}}}async onEpochEnd(t,e){if(e!=null)for(let n of this.params.metrics)this.totals[n]!=null&&(typeof this.totals[n]=="number"?e[n]=this.totals[n]/this.seen:B(()=>{let o=M(ct(1,this.seen),this.totals[n]);e[n]=o,this.totals[n].dispose(),Pe(e[n])}))}},by=class extends cl{async onTrainBegin(t){this.epoch=[],this.history={}}async onEpochEnd(t,e){e==null&&(e={}),this.epoch.push(t);for(let n in e)this.history[n]==null&&(this.history[n]=[]),this.history[n].push(e[n])}async syncData(){let t=[],e=[],n=[];for(let s in this.history){let i=this.history[s];for(let a=0;a<i.length;++a)if(typeof i[a]!="number"){let u=i[a];t.push(u.data()),e.push(s),n.push(a)}}let o=await Promise.all(t);for(let s=0;s<o.length;++s)this.history[e[s]][n[s]].dispose(),this.history[e[s]][n[s]]=o[s][0]}},wy=class extends cl{constructor(t,e){if(super(),this.currentEpoch=0,this.nowFunc=t.nowFunc,this.nextFrameFunc=t.nextFrameFunc||Vh,this.yieldEvery=e||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=DX),this.yieldEvery==="never"&&t.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");x.isNumber(this.yieldEvery)&&(this.maybeWait=Q2(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=t.onTrainBegin,this.trainEnd=t.onTrainEnd,this.epochBegin=t.onEpochBegin,this.epochEnd=t.onEpochEnd,this.batchBegin=t.onBatchBegin,this.batchEnd=t.onBatchEnd,this.yield=t.onYield}async maybeWait(t,e,n){let o=[];this.yield!=null&&(await Ki(n),o.push(this.yield(t,e,n))),o.push(this.nextFrameFunc()),await Promise.all(o)}async onEpochBegin(t,e){this.currentEpoch=t,this.epochBegin!=null&&(await Ki(e),await this.epochBegin(t,e))}async onEpochEnd(t,e){let n=[];this.epochEnd!=null&&(await Ki(e),n.push(this.epochEnd(t,e))),this.yieldEvery==="epoch"&&n.push(this.nextFrameFunc()),await Promise.all(n)}async onBatchBegin(t,e){this.batchBegin!=null&&(await Ki(e),await this.batchBegin(t,e))}async onBatchEnd(t,e){let n=[];this.batchEnd!=null&&(await Ki(e),n.push(this.batchEnd(t,e))),this.yieldEvery==="batch"?n.push(this.nextFrameFunc()):x.isNumber(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,t,e)),await Promise.all(n)}async onTrainBegin(t){this.trainBegin!=null&&(await Ki(t),await this.trainBegin(t))}async onTrainEnd(t){this.trainEnd!=null&&(await Ki(t),await this.trainEnd(t))}};function vy(r,t){return r==null&&(r={}),r instanceof cl?[r]:Array.isArray(r)&&r[0]instanceof cl?r:we(r).map(n=>new wy(n,t))}var wn=class{constructor(){}static registerCallbackConstructor(t,e){x.assert(t>=0&&Number.isInteger(t),()=>`Verbosity level is expected to be an integer >= 0, but got ${t}`),wn.checkForDuplicate(e),wn.constructors[t]==null&&(wn.constructors[t]=[]),wn.constructors[t].push(e)}static checkForDuplicate(t){for(let e in wn.constructors)wn.constructors[+e].forEach(o=>{if(o===t)throw new z("Duplicate callback constructor.")})}static clear(){wn.constructors={}}static createCallbacks(t){let e=[];for(let n in wn.constructors){let o=+n;t>=o&&e.push(...wn.constructors[o])}return e.map(n=>new n)}};wn.constructors={};function Cy(r,t,e,n,o,s,i,a,u){let l=new by,c=[new TS,...wn.createCallbacks(t)];r!=null&&c.push(...r),c.push(l);let p=new yy(c);return p.setParams({epochs:e,initialEpoch:n,samples:o,steps:s,batchSize:i,verbose:t,doValidation:a,metrics:u}),{callbackList:p,history:l}}function vn(r,t={},e=!1){return Hi(r,et.SerializationMap.getMap().classNameMap,t,"layer",e)}function Kh(r,t){return B(()=>{r.dtype!=="float32"&&(r=Z(r,"float32"));let e=mt(Sc(r),t,!0),n=Js(e.shape,cr()),o=be(fn(e,n));return ct(r,o)})}function ji(r,t){return B(()=>xe(Sc(lt(t,r)),-1))}function Vm(r,t){return B(()=>xe(Ne(lt(t,r)),-1))}function lu(r,t){return B(()=>{let e=lt(r,t),n=br(Ne(r),cr(),Number.MAX_VALUE),o=Ne(ct(e,n));return M(100,xe(o,-1))})}function RX(r,t){return B(()=>{let e=br(t,cr(),Number.MAX_VALUE),n=wr(J(1,e)),o=br(r,cr(),Number.MAX_VALUE),s=wr(J(1,o));return xe(Sc(lt(n,s)),-1)})}function FX(r,t){return B(()=>{let e=fn(0,lt(1,M(r,t)));return xe(Sc(e),-1)})}function OX(r,t){return B(()=>{let e=fn(0,lt(1,M(r,t)));return xe(e,-1)})}function MX(r,t){return B(()=>{let e=mt(M(r,t),-1),n=Dr(M(lt(1,r),t),-1);return fn(0,J(1,lt(n,e)))})}function PX(r,t){return B(()=>{let e=Math.log(2),n=lt(t,r),o=lt(J(n,bo(M(-2,n))),e);return xe(o,-1)})}function $c(r,t,e=!1){return B(()=>{if(e)t=nl(t);else{let n=mt(t,t.shape.length-1,!0);t=ct(t,n)}return t=br(t,cr(),1-cr()),Zt(mt(M(Z(r,"float32"),wr(t)),t.shape.length-1))})}function Gm(r,t,e=!1){return B(()=>{let n=Z(Qs(f$(r)),"int32");t=br(t,cr(),1-cr());let o=t.shape,s=O(Ks(n,o[o.length-1]),o);return $c(s,t,e)})}function LX(r,t){if(!x.arraysEqual(r.shape,t.shape))throw new z(`logits and labels must have the same shape, but got shapes ${JSON.stringify(r.shape)} and ${JSON.stringify(t.shape)}`);return B(()=>{let e=Tr(t),n=Zt(Ne(t));return J(lt(e,M(t,r)),Za(Ze(n)))})}function Wm(r,t){return B(()=>{let e;return e=br(t,cr(),1-cr()),e=wr(ct(e,lt(1,e))),xe(LX(r,e),-1)})}function zX(r,t){return B(()=>{let e=br(r,cr(),1),n=br(t,cr(),1);return mt(M(r,wr(ct(e,n))),-1)})}function BX(r,t){return B(()=>{let e=wr(J(cr(),t));return xe(lt(t,M(r,e)),-1)})}function Xh(r,t){return B(()=>{let e=Kh(r,-1),n=Kh(t,-1),o=M(e,n);return Zt(mt(o,-1))})}var jh={meanSquaredError:ji,meanAbsoluteError:Vm,meanAbsolutePercentageError:lu,meanSquaredLogarithmicError:RX,squaredHinge:FX,hinge:OX,categoricalHinge:MX,logcosh:PX,categoricalCrossentropy:$c,sparseCategoricalCrossentropy:Gm,binaryCrossentropy:Wm,kullbackLeiblerDivergence:zX,poisson:BX,cosineProximity:Xh};function Iy(r){if(typeof r=="string"){if(r in jh)return jh[r];let t=`Unknown loss ${r}`;throw r.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${r}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new z(t)}else return r}function Yh(r,t){return B(()=>{let e=M(.5,dr(t)),n=Ic(Ge(t,e),r.dtype);return xe(Sr(r,n),-1)})}function Zh(r,t){return B(()=>Ic(Sr(js(r,-1),js(t,-1)),"float32"))}function T$(r,t){return B(()=>Z(mt(Nr(Sr(r,1),Sr(t,1))),"float32"))}function VX(r,t){return B(()=>Z(mt(Nr(Sr(r,1),Sr(t,0))),"float32"))}function GX(r,t){return B(()=>Z(mt(Nr(Sr(r,0),Sr(t,1))),"float32"))}function _S(r,t){return B(()=>{let e=T$(r,t),n=GX(r,t),o=J(e,n);return Z(_e(Ge(o,0),ct(e,o),0),"float32")})}function _$(r,t){return B(()=>{let e=T$(r,t),n=VX(r,t),o=J(e,n);return Z(_e(Ge(o,0),ct(e,o),0),"float32")})}function ky(r,t){return Wm(r,t)}function Ny(r,t){return r.rank===t.rank&&(r=zr(r,[r.rank-1])),t=js(t,-1),t.dtype!==r.dtype&&(t=Z(t,r.dtype)),Z(Sr(r,t),"float32")}var WX=ji,UX=ji,HX=Vm,qX=Vm,KX=lu,jX=lu,Jh=$c,XX=Xh,ES=Gm,Sy={binaryAccuracy:Yh,categoricalAccuracy:Zh,precision:_S,categoricalCrossentropy:Jh,sparseCategoricalCrossentropy:ES,mse:WX,MSE:UX,mae:HX,MAE:qX,mape:KX,MAPE:jX,cosine:XX};function E$(r){if(typeof r=="string"&&r in Sy)return Sy[r];if(typeof r!="string"&&r!=null)return r;throw new z(`Unknown metric ${r}`)}function Qh(r){if(Qn(r!==null,`Unknown LossOrMetricFn ${r}`),typeof r=="string")return r;{let t;for(let e of Object.keys(jh))if(jh[e]===r){t=e;break}if(t!==void 0)return t;for(let e of Object.keys(Sy))if(Sy[e]===r){t=e;break}return t!==void 0?t:r.name}}function $$(r){let t={Adagrad:()=>wc.adagrad(.01),Adadelta:()=>wc.adadelta(1,.95,cr()),Adam:()=>wc.adam(.001,.9,.999,cr()),Adamax:()=>wc.adamax(.002,.9,.999,cr(),0),RMSProp:()=>wc.rmsprop(.001,.9,0,cr()),SGD:()=>wc.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,r in t)return t[r]();throw new z(`Unknown Optimizer ${r}`)}function $S(r,t,e=!1){if(r==null||typeof r!="object"||Object.getPrototypeOf(r)!==Object.prototype||!AS(r))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(e){let n=JSON.stringify(r);n.length>1048576&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${n.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${1048576}.`)}}function AS(r){if(r===null)return!0;if(typeof r=="object")if(Object.getPrototypeOf(r)===Object.prototype){let t=Object.keys(r);for(let e of t)if(typeof e!="string"||!AS(r[e]))return!1;return!0}else if(Array.isArray(r)){for(let t of r)if(!AS(t))return!1;return!0}else return!1;else{let t=typeof r;return t==="string"||t==="number"||t==="boolean"}}function D$(r,t,e,n=console.log){let o=JX(r),s=["Layer (type)","Input Shape","Output shape","Param #"];o?(t=t||90,e=e||[.32,.61,.89,1]):(t=t||115,e=e||[.24,.48,.7,.8,1]),e[e.length-1]<=1&&(e=e.map(c=>Math.floor(t*c)));let i;if(!o){s.push("Receives inputs"),i=[];for(let c in r.nodesByDepth)i.push(...r.nodesByDepth[c])}n("_".repeat(t)),Ty(s,e,n),n("=".repeat(t));let a=r.layers;for(let c=0;c<a.length;++c)o?QX(a[c],e,n):t8(a[c],e,i,n),n((c===a.length-1?"=":"_").repeat(t));r.checkTrainableWeightsConsistency();let u=ZX(r),l=zm(r.nonTrainableWeights);n(`Total params: ${u+l}`),n(`Trainable params: ${u}`),n(`Non-trainable params: ${l}`),n("_".repeat(t))}function ZX(r){let t;return r.collectedTrainableWeights!=null?t=zm(r.collectedTrainableWeights):t=zm(r.trainableWeights),t}function JX(r){let t=!0,e=[],n=[];for(let o in r.nodesByDepth)e.push(r.nodesByDepth[o]);for(let o of e){if(o.length>1||o.length===1&&o[0].inboundLayers.length>1){t=!1;break}n.push(...o)}if(t)for(let o of r.layers){let s=!1;for(let i of o.inboundNodes)if(n.indexOf(i)!==-1)if(s){t=!1;break}else s=!0;if(!t)break}return t}function Ty(r,t,e=console.log){let n="";for(let o=0;o<r.length;++o)o>0&&(n=n.slice(0,n.length-1)+" "),n+=r[o],n=n.slice(0,t[o]),n+=" ".repeat(t[o]-n.length);e(n)}function QX(r,t,e){let n,o;try{o=r.inboundNodes.map(u=>JSON.stringify(u.inputShapes)).join(",")}catch(u){o="multiple"}try{n=JSON.stringify(r.outputShape)}catch(u){n="multiple"}let s=r.name,i=r.getClassName(),a=[`${s} (${i})`,o,n,r.countParams().toString()];Ty(a,t,e)}function t8(r,t,e,n){let o,s;try{s=r.inboundNodes.map(p=>JSON.stringify(p.inputShapes)).join(",")}catch(p){s="multiple"}try{o=JSON.stringify(r.outputShape)}catch(p){o="multiple"}let i=[];for(let p of r.inboundNodes)if(!(e!=null&&e.length>0&&e.indexOf(p)===-1))for(let m=0;m<p.inboundLayers.length;++m){let f=p.inboundLayers[m].name,d=p.nodeIndices[m],h=p.tensorIndices[m];i.push(`${f}[${d}][${h}]`)}let a=r.name,u=r.getClassName(),l=i.length===0?"":i[0],c=[`${a} (${u})`,s,o,r.countParams().toString(),l];Ty(c,t,n);for(let p=1;p<i.length;++p)Ty(["","","","",i[p]],t,n)}function R$(r,t,e){return(r==="inboundNodes"||r==="outputLayers"||r==="inputLayers")&&t===0&&typeof e=="string"}function Dc(r,t){if(r===null)return null;if(typeof r=="string")return il(r);if(typeof r=="number"||typeof r=="boolean")return r;if(r instanceof Array){let e=[],n=r.length;for(let o=0;o<n;++o){let s=r[o];R$(t,o,s)?e.push(s):e.push(Dc(s,t))}return e}else{let e={};for(let n of Object.keys(r)){let o=r[n];if(n==="name"&&typeof o=="string")e[n]=o;else{let s=il(n);e[s]=Dc(o,s)}}return e}}function _y(r,t){if(r==null)return null;if(typeof r=="string")return No(r);if(typeof r=="number"||typeof r=="boolean")return r;if(r instanceof Array){let e=[],n=r.length;for(let o=0;o<n;++o){let s=r[o];R$(t,o,s)?e.push(s):e.push(_y(s,t))}return e}else{let e={};for(let n of Object.keys(r)){let o=r[n],s=No(n);(n==="name"||n==="className")&&typeof o=="string"?e[s]=o:e[s]=_y(o,n)}return e}}var Um="3.15.0";function e8(r,t){if(r.dtype==null||r.dtype===t.dtype)return t;try{return Z(t,r.dtype)}catch(e){throw new z(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${r.name}' (${r.dtype}).`)}}var Ao=class{constructor(t){if(this.id2Value={},this.id2Mask={},this.name2Id={},t instanceof Ao)for(let e in t.id2Value)this.id2Value[e]=t.id2Value[e],e in t.id2Mask&&(this.id2Mask[e]=t.id2Mask[e]);else{if(t==null)return;for(let e of t)this.add(e.key,e.value)}}add(t,e,n){if(this.id2Value[t.id]==null)this.id2Value[t.id]=e8(t,e),this.name2Id[t.name]=t.id,n!=null&&(this.id2Mask[t.id]=n);else throw new z(`Duplicate key: name=${t.name}, id=${t.id}`);return this}addFeed(t){this.add(t.key,t.value)}hasKey(t){return this.id2Value[t.id]!=null}names(){return Object.keys(this.name2Id)}getValue(t){if(t instanceof Qr){if(this.id2Value[t.id]==null)throw new z(`Nonexistent key: ${t.name}`);return this.id2Value[t.id]}else{let e=this.name2Id[t];if(e==null)throw new z(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Value[e]}}getMask(t){if(t instanceof Qr){if(this.id2Value[t.id]==null)throw new z(`Nonexistent key: ${t.name}`);return this.id2Mask[t.id]}else{let e=this.name2Id[t];if(e==null)throw new z(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Mask[e]}}disposeMasks(){this.id2Mask!=null&&_t(this.id2Mask)}},DS={},F$={};function Rc(r,t,e,n){let o=e==null?!1:e.training,s=Array.isArray(r),i=s?r:[r],a=i.map(d=>d.name),u=[],l=t.names();for(let d of a)l.indexOf(d)!==-1?u.push(t.getValue(d)):u.push(null);n!=null&&(n.maxNumTensors=-1/0,n.minNumTensors=1/0);let c=a.join(",")+"|"+t.names().join(","),p,m;if(DS[c]==null){let d=r8(i,t);p=d.sorted,m=d.recipientCounts,DS[c]=p,F$[c]=m}p=DS[c],m={},o||Object.assign(m,F$[c]);let f=new Ao(t);for(let d=0;d<p.length;++d){if(n!=null){let R=oh().numTensors;R>n.maxNumTensors&&(n.maxNumTensors=R),R<n.minNumTensors&&(n.minNumTensors=R)}let h=p[d],g=h.sourceLayer;if(g instanceof ai)continue;let y=[],b=[],w=[],v=!1;for(let R of h.inputs){let P=f.getValue(R),W=f.getMask(R);y.push(P),b.push(W),W!=null&&(v=!0),o||(m[R.name]--,m[R.name]===0&&!t.hasKey(R)&&a.indexOf(R.name)===-1&&!P.isDisposed&&R.sourceLayer.stateful!==!0&&w.push(P))}v&&(e=e||{},e.mask=b[0]);let k=we(g.apply(y,e)),E=null;g.supportsMasking&&(E=g.computeMask(y,b));let $=o8(h),D=Array.isArray($)?$:[$];for(let R=0;R<D.length;++R){f.hasKey(D[R])||f.add(D[R],k[R],Array.isArray(E)?E[0]:E);let P=a.indexOf(D[R].name);P!==-1&&(u[P]=k[R])}o||_t(w)}return f.disposeMasks(),s?u:u[0]}function r8(r,t){x.assert(r!=null&&r.length>0,()=>"Expected at least one fetch, got none");let e=[],n={};if(r.length===1){let o=O$(r[0],t);e=o.sorted,n=o.recipientMap}else{let o=new Set;for(let s of r){let{sorted:i,recipientMap:a}=O$(s,t);for(let u of i)o.has(u.name)||(e.push(u),o.add(u.name));for(let u in a)n[u]==null&&(n[u]=new Set),a[u].forEach(l=>n[u].add(l))}}return{sorted:e,recipientCounts:n8(n)}}function n8(r){let t={};for(let e in r)t[e]=r[e].size;return t}function O$(r,t){let e=new Set,n=[],o={};for(let a of t.names())e.add(a);let s=[],i=[];for(s.push(r);s.length>0;){let a=s[s.length-1];if(e.has(a.name)){s.pop();continue}let u=i[i.length-1]===s.length-1;if(a.inputs.length===0||u)s.pop(),n.push(a),e.add(a.name),u&&i.pop();else{i.push(s.length-1);for(let l of a.inputs)o[l.name]==null&&(o[l.name]=new Set),o[l.name].add(a.name),!e.has(l.name)&&s.push(l)}}return{sorted:n,recipientMap:o}}function o8(r){let t;if(r.sourceLayer.inboundNodes.length===1)t=r.sourceLayer.output;else{let e=null;for(let n=0;n<r.sourceLayer.inboundNodes.length;++n)for(let o of r.sourceLayer.inboundNodes[n].outputTensors)if(o.id===r.id){e=n;break}t=r.sourceLayer.getOutputAt(e)}return t}var Bn=class extends Bt{constructor(t){if(super({}),this.containerNodes=new Set,this.name=t.name,this.name==null){let b=this.getClassName().toLowerCase();this.name=au(b)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(t.inputs)?this.inputs=t.inputs.slice():this.inputs=[t.inputs],Array.isArray(t.outputs)?this.outputs=t.outputs.slice():this.outputs=[t.outputs],To(this.inputs).length!==this.inputs.length)throw new z(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(b=>b.name)}`);To(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(b=>b.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(let b of this.outputs){let w=b.sourceLayer,v=b.nodeIndex,k=b.tensorIndex;this.outputLayers.push(w),this.outputLayersNodeIndices.push(v),this.outputLayersTensorIndices.push(k)}for(let b of this.inputs){let w=b.sourceLayer,v=b.nodeIndex,k=b.tensorIndex;Qn(v===0,"input layer has >1 nodes"),Qn(k===0,"input layer has >1 tensors"),this.inputLayers.push(w),this.inputLayersNodeIndices.push(v),this.inputLayersTensorIndices.push(k)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let b=0;b<this.inputLayers.length;b++){let w=this.inputLayers[b];if(!(w instanceof ai))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${t.inputs}. Input ${b} (0-based) originates from layer type ${w.getClassName()}.`);this.inputNames.push(w.name),this.feedInputShapes.push(w.batchInputShape),this.feedInputNames.push(w.name)}for(let b of this.outputLayers)this.outputNames.push(b.name);this.internalInputShapes=this.inputs.map(b=>b.shape),this.internalOutputShapes=this.outputs.map(b=>b.shape);let e={},n={},o={},s={},i={},a=[],u=(b,w,v,k,E,$)=>{(k==null||E==null||$==null)&&(k=b.sourceLayer,E=b.nodeIndex,$=b.tensorIndex);let D=k.inboundNodes[E];if(v.indexOf(D)!==-1)throw new Wr(`The tensor ${b.name} at layer "${k.name}" is part of a cycle.`);if(w.indexOf(D)!==-1)return;this.containerNodes.add(Bn.nodeKey(k,E)),k.id in i||(i[k.id]=Object.keys(i).length),v.indexOf(D)===-1&&v.push(D);let R=D.inboundLayers.length;for(let P=0;P<R;P++){let W=D.inputTensors[P],U=D.inboundLayers[P],q=D.nodeIndices[P],K=D.tensorIndices[P];u(W,w,v,U,q,K)}for(w.push(D);v.indexOf(D)>=0;)v.splice(v.indexOf(D),1);a.push(D)},l=[],c=[];for(let b of this.outputs)u(b,l,c);let p=a.slice().reverse();for(let b of p){n[b.id]=b,b.id in e||(e[b.id]=0);let w=e[b.id],v=o[b.outboundLayer.id]==null?0:o[b.outboundLayer.id];w=Math.max(w,v),o[b.outboundLayer.id]=w,s[b.outboundLayer.id]=b.outboundLayer,e[b.id]=w;for(let k=0;k<b.inboundLayers.length;k++){let E=b.inboundLayers[k],$=b.nodeIndices[k],D=E.inboundNodes[$],R=e[D.id]==null?0:e[D.id];e[D.id]=Math.max(w+1,R),n[D.id]=D}}let m={};for(let b in e){let w=e[b];w in m||(m[w]=[]),m[w].push(n[b])}let f={};for(let b in o){let w=o[b];w in f||(f[w]=[]),f[w].push(s[b])}let d=Object.keys(f).map(b=>parseInt(b,10)).sort(Gh);this.layers=[];for(let b of d){let w=f[b];w.sort((v,k)=>{let E=i[v.id],$=i[k.id];return E<$?-1:E>$?1:0});for(let v of w)v instanceof Bn&&this.internalContainerRefs.push(v),this.layers.push(v)}this.layersByDepth=f,d=Object.keys(m).map(b=>parseInt(b,10)).sort(Gh);let h=this.inputs.slice(),g=[];for(let b of d)for(let w of m[b]){let v=w.outboundLayer;if(v!=null){for(let k of w.inputTensors)if(h.indexOf(k)===-1)throw new Wr(`Graph disconnected: cannot obtain value for tensor ${k} at layer "${v.name}". The following previous layers were accessed without issue: ${g}`);for(let k of w.outputTensors)h.push(k);g.push(v.name)}}this.nodesByDepth=m;let y=this.layers.map(b=>b.name);for(let b of y){let w=y.filter(v=>v===b).length;if(w!==1)throw new Wr(`The name "${b}" is used ${w} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(y))}this.outboundNodes=[],this.inboundNodes=[],new ul({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(b=>null),outputMasks:this.outputs.map(b=>null),inputShapes:this.inputs.map(b=>b.shape),outputShapes:this.outputs.map(b=>b.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();let t={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(let e of this.layers)t.numDisposedVariables+=e.dispose().numDisposedVariables;for(let e of this.internalContainerRefs)t.numDisposedVariables+=e.dispose().numDisposedVariables}return t.refCountAfterDispose=this._refCount,t}get trainable(){return this.trainable_}set trainable(t){this.layers.forEach(e=>{e._trainableWeights.forEach(n=>n.trainable=t)}),this.trainable_=t}get trainableWeights(){if(this._trainableWeights.length>0)throw new z("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let t=[];for(let e of this.layers)t=t.concat(e.trainableWeights);return t}get nonTrainableWeights(){let t=[];for(let e of this.layers)t.push(...e.nonTrainableWeights);if(!this.trainable){let e=[];for(let n of this.layers)e.push(...n.trainableWeights);return e.concat(t)}return t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(t,e=!0){let n={},o=0;for(let i of this.layers)for(let a of i.weights){if(n[a.originalName]!=null)throw new z(`Duplicate weight name: ${a.originalName}`);n[a.originalName]=a,o++}let s=[];for(let i in t){let a=i;if(n[i]==null){let u=i.split("/");a=u.slice(0,-2).concat([u[u.length-1]]).join("/")}if(n[a]!=null)s.push([n[a],t[i]]);else if(e)throw new z(`Provided weight data has no target variable: ${i}`);delete n[a]}if(e){let i=[];for(let a in n)i.push(a);if(i.length>0)throw new z(`${i.length} of ${o} weights are not set: ${i}`)}Bm(s)}updatedConfig(){let t=this.getConfig(),e={};return e.className=this.getClassName(),e.config=t,e.kerasVersion=`tfjs-layers ${Um}`,e.backend="TensorFlow.js",e}toJSON(t,e=!0){let n=_y(this.updatedConfig());return e?JSON.stringify(n):n}call(t,e){return B(()=>{t=we(t);let n=new Ao;for(let o=0;o<this.inputs.length;++o)n.add(this.inputs[o],t[o]);return Rc(this.outputs,n,e)})}computeMask(t,e){return B(()=>{t=we(t);let n;return e==null?n=ko(null,t.length):n=we(e),this.runInternalGraph(t,n)[1]})}computeOutputShape(t){let e=Lm(t);if(e.length!==this.inputLayers.length)throw new z(`Invalid inputShape argument ${t}: model has ${this.inputLayers.length} tensor inputs.`);let n={};for(let a=0;a<e.length;a++){let u=this.inputLayers[a],l=e[a],c=u.name+"_0_0";n[c]=l}let o=Object.keys(this.nodesByDepth).map(a=>parseInt(a,10)).sort(Gh);if(o.length>1)for(let a of o){let u=this.nodesByDepth[a];for(let l of u){let c=l.outboundLayer;if(this.inputLayers.map(h=>h.id).indexOf(c.id)!==-1)continue;let p=[];for(let h=0;h<l.inboundLayers.length;h++){let g=l.inboundLayers[h],y=l.nodeIndices[h],b=l.tensorIndices[h],w=`${g.name}_${y}_${b}`,v=n[w];p.push(v)}let m=c.computeOutputShape(_r(p)),f=Lm(m),d=c.inboundNodes.indexOf(l);for(let h=0;h<f.length;h++){let g=`${c.name}_${d}_${h}`;n[g]=f[h]}}}let s=[],i=[];for(let a=0;a<this.outputLayers.length;a++){let u=this.outputLayers[a],l=this.outputLayersNodeIndices[a],c=this.outputLayersTensorIndices[a],p=`${u.name}_${l}_${c}`;i.push(p)}for(let a=0;a<i.length;a++){let u=i[a];Qn(u in n),s.push(n[u])}return _r(s)}runInternalGraph(t,e){e==null&&(e=ko(null,t.length));let n={};for(let u=0;u<this.inputs.length;++u){let l=this.inputs[u],c=t[u],p=e[u];n[l.id]=[c,p]}let o=Object.keys(this.nodesByDepth).map(u=>parseInt(u,10)).sort(Gh);for(let u of o){let l=this.nodesByDepth[u];for(let c of l){let p=c.outboundLayer,m=c.inputTensors,f=c.outputTensors,d=new Array;for(let h of m)h.id in n&&d.push(n[h.id]);if(d.length===m.length){let h={},g,y,b,w;if(c.callArgs!=null&&(h=c.callArgs),d.length===1){let[v,k]=d[0];h.mask==null&&(h.mask=k),b=we(p.call(v,h)),w=we(p.computeMask(v,k)),g=[v],y=[k]}else g=d.map(v=>v[0]),y=d.map(v=>v[1]),h.mask==null&&(h.mask=y),b=we(p.call(g,h)),w=we(p.computeMask(g,y));if(p.activityRegularizer)throw new Nt("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let v=0;v<f.length;++v){let k=f[v],E=b[v],$=w[v];n[k.id]=[E,$]}}}}let s=[],i=[],a=[];for(let u of this.outputs){Qn(u.id in n,`Could not compute output ${u.name} : ${u.id}`);let[l,c]=n[u.id];a.push(l.shape),s.push(l),i.push(c)}return[s,i,a]}buildNodeConversionMap(t){let e={},n;for(let o of this.layers){n=o instanceof Bn?1:0;for(let s=0;s<o.inboundNodes.length;s++){let i=Bn.nodeKey(o,s);this.containerNodes.has(i)&&(e[i]=n,n+=1)}}return e}getLayer(t,e){if(e!=null){if(this.layers.length<=e)throw new z(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);return this.layers[e]}else if(t==null)throw new z("Provide either a layer name or layer index");for(let n of this.layers)if(n.name===t)return n;throw new z(`No such layer: ${t}`)}calculateLosses(){return B(()=>{let t=[];for(let e of this.layers)for(let n=0;n<e.inboundNodes.length;++n){let o=Bn.nodeKey(e,n);this.containerNodes.has(o)&&t.push(...e.calculateLosses())}return t})}getConfig(){let t={name:this.name},e=this.buildNodeConversionMap(this.layers),n=[];for(let i of this.layers){let a=i.getClassName(),u=i.getConfig(),l=[];for(let p=0;p<i.inboundNodes.length;p++){let m=i.inboundNodes[p],f=Bn.nodeKey(i,p),d={};if(this.containerNodes.has(f)){if(m.callArgs)try{JSON.stringify(m.callArgs),d=m.callArgs}catch(h){console.warn(`Layer ${i.name} was passed non-serializable keyword arguments: ${m.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),d={}}if(m.inboundLayers.length>0){let h=[];for(let g=0;g<m.inboundLayers.length;g++){let y=m.inboundLayers[g],b=m.nodeIndices[g],w=m.tensorIndices[g],v=Bn.nodeKey(y,b),k=e[v];k==null&&(k=0),h.push([y.name,k,w,d])}l.push(h)}}}let c={};c.name=i.name,c.className=a,c.config=u,c.inboundNodes=l,n.push(c)}t.layers=n;let o=[];for(let i=0;i<this.inputLayers.length;i++){let a=this.inputLayers[i],u=this.inputLayersNodeIndices[i],l=Bn.nodeKey(a,u);if(!this.containerNodes.has(l))continue;let c=e[l];c==null&&(c=0);let p=this.inputLayersTensorIndices[i];o.push([a.name,c,p])}t.inputLayers=o;let s=[];for(let i=0;i<this.outputLayers.length;i++){let a=this.outputLayers[i],u=this.outputLayersNodeIndices[i],l=Bn.nodeKey(a,u);if(!this.containerNodes.has(l))continue;let c=e[l];c==null&&(c=0);let p=this.outputLayersTensorIndices[i];s.push([a.name,c,p])}return t.outputLayers=s,t}static fromConfig(t,e,n={},o=!1){let s={},i={};function a(g,y){g.name in i?i[g.name].push(y):i[g.name]=[y]}function u(g,y){let b=[],w;for(let v of y){let k=v[0],E=v[1],$=v[2];if(w=v[3]==null?{}:v[3],!(k in s)){a(g,y);return}let D=s[k];if(D.inboundNodes.length<=E){a(g,y);return}let R=D.inboundNodes[E];b.push(R.outputTensors[$])}b.length>0&&g.apply(_r(b),w)}function l(g){let y=g.name,b=vn(g,e.customObjects!=null?e.customObjects:{});b.setFastWeightInitDuringBuild(o),s[y]=b,g.inboundNodes.forEach(v=>{if(!(v instanceof Array))throw new z(`Corrupted configuration, expected array for nodeData: ${v}`);a(b,v)})}let c=e.name,p=e.layers;for(let g of p)l(g);for(;!Z2(i);)for(let g of p){let y=s[g.name];if(y.name in i){let b=i[y.name];delete i[y.name];for(let w of b)u(y,w)}}let m=[],f=[],d=e.inputLayers;for(let g of d){let y=g[0],b=g[1],w=g[2];Qn(y in s);let k=s[y].inboundNodes[b].outputTensors;m.push(k[w])}let h=e.outputLayers;for(let g of h){let y=g[0],b=g[1],w=g[2];Qn(y in s);let k=s[y].inboundNodes[b].outputTensors;f.push(k[w])}return new t({inputs:m,outputs:f,name:c})}get stateful(){if(this._stateful)throw new z("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(let t of this.layers)if(t.stateful)return!0;return!1}resetStates(){B(()=>{this.layers.forEach(t=>{t.stateful&&t.resetStates()})})}};function s8(r,t,e){let n=t.length;if(r==null||Array.isArray(r)&&r.length===0)return t.map(o=>null);if(n===1)return Array.isArray(r)&&r.length===1?r:typeof r=="object"&&t[0]in r?[r[t[0]]]:[r];if(Array.isArray(r)){if(r.length!==n)throw new Error(`Provided ${e} is an array of ${r.length} element(s), but the model has ${n} outputs. Make sure a set of weights is provided for each model output.`);return r}else if(typeof r=="object"&&Object.keys(r).length>0&&typeof r[Object.keys(r)[0]]=="object"){let o=[];return t.forEach(s=>{s in r?o.push(r[s]):o.push(null)}),o}else throw new Error(`The model has multiple (${n}) outputs, so ${e} must be either an array with ${n} elements or an object with ${t} keys. Provided ${e} not understood: ${JSON.stringify(r)}`)}function Ey(r,t){return s8(r,t,"classWeight")}async function Ay(r,t,e,n){if(t!=null||n!=null)throw new Error("Support sampleWeight is not implemented yet");if(e!=null){let o=B(()=>{if(r.shape.length===1)return kn(r);if(r.shape.length===2){if(r.shape[1]>1)return js(r,1);if(r.shape[1]===1)return O(r,[r.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${r.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${r.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),s=Array.from(await o.data());_t(o);let i=[];return s.forEach(a=>{if(e[a]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${a} exists in the data but not in classWeight`);i.push(e[a])}),Re(i,"float32")}else return null}function M$(r,t){return M(r,t)}var i8=32;function z$(r,t){let e,n,o=t;e=o.xs,n=o.ys,x.assert(e!=null&&n!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`);let s=P$("input",r.inputNames,e),i=P$("output",r.outputNames,n),a=s[0].shape[0];x.assert(s.length===r.inputs.length,()=>`LayersModel has ${r.inputs.length} inputs, but the dataset provides ${s.length} inputs.  (Expected input keys: ${JSON.stringify(r.inputNames)})`),x.assert(i.length===r.outputs.length,()=>`LayersModel has ${r.outputs.length} outputs, but the dataset provides ${i.length} outputs.  (Expected output keys: ${JSON.stringify(r.outputNames)})`);for(let u=0;u<s.length;u++)x.assert(s[u].shape[0]===a,()=>`Batch size mismatch: input ${r.inputNames[u]} has ${s[u].shape[0]}; expected  ${a} based on input ${r.inputNames[0]}.`);for(let u=0;u<i.length;u++)x.assert(i[u].shape[0]===a,()=>`Batch size mismatch: output ${r.outputNames[u]} has ${i[u].shape[0]}; expected  ${a} based on input ${r.inputNames[0]}.`);return{xs:s,ys:i}}function P$(r,t,e){if(e instanceof Pt)return[e];if(Array.isArray(e))return x.assert(e.length===t.length,()=>`Received an array of ${e.length} Tensors, but expected ${t.length} to match the ${r} keys ${t}.`),e;{let n=[];for(let o of t){if(e[o]==null)throw new z(`The feature data generated by the dataset lacks the required ${r} key '${o}'.`);n.push(e[o])}return n}}function a8(r){if(r.length===3)throw new Nt("Validation with sample weights is not implemented yet.");return{xs:r[0],ys:r[1]}}async function B$(r,t,e){let n=e.batchesPerEpoch!=null;if(x.assert(r.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),x.assert(e!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),x.assert(e.epochs!=null&&e.epochs>0&&Number.isInteger(e.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${e.epochs}`),x.assert(!n||e.batchesPerEpoch>0&&Number.isInteger(e.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${e.batchesPerEpoch}`),x.assert(e.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),r.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");r.isTraining=!0;try{let o=e.validationData!=null,s,i;if(o)if(L$(e.validationData))x.assert(e.validationBatches==null||e.validationBatches>0&&Number.isInteger(e.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${e.validationBatches}`);else{let g=a8(e.validationData);s=g.xs,i=g.ys}let a=r.makeTrainFunction(),u=r.getDedupedMetricsNames(),l;o?l=u.slice().concat(u.map(g=>"val_"+g)):l=u.slice();let c=vy(e.callbacks,e.yieldEvery),p=e.verbose==null?1:e.verbose,{callbackList:m,history:f}=Cy(c,p,e.epochs,null,null,l8(t,e),null,o,l);m.setModel(r),r.history=f,await m.onTrainBegin(),r.stopTraining_=!1;let d=e.initialEpoch==null?0:e.initialEpoch,h=await t.iterator();for(;d<e.epochs;){let g={};await m.onEpochBegin(d);let y=0,b=0;for(n||(h=await t.iterator());!n||y<e.batchesPerEpoch;){let w=await h.next();if(n&&w.done){console.warn(`You provided \`batchesPerEpoch\` as ${e.batchesPerEpoch}, but your dataset iterator ran out of data after ${y} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${e.batchesPerEpoch*e.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(w.value!=null){let{xs:v,ys:k}=z$(r,w.value),E={};E.batch=b,E.size=v[0].shape[0],await m.onBatchBegin(b,E);let $=[];if(e.classWeight!=null){let P=Ey(e.classWeight,r.outputNames);for(let W=0;W<P.length;++W)$.push(await Ay(k[W],null,P[W]))}let D=v.concat(k).concat($),R=a(D);_t(D);for(let P=0;P<u.length;++P){let W=u[P],U=R[P];E[W]=U,Pe(U)}await m.onBatchEnd(b,E),xy(E),b++,y++}if(n?y>=e.batchesPerEpoch:w.done){if(o){let v;L$(e.validationData)?v=we(await r.evaluateDataset(e.validationData,{batches:e.validationBatches})):v=we(r.evaluate(s,i,{batchSize:e.validationBatchSize==null?i8:e.validationBatchSize,verbose:0}));for(let k=0;k<r.metricsNames.length;++k)g[`val_${r.metricsNames[k]}`]=v[k]}break}if(r.stopTraining_)break}if(await m.onEpochEnd(d,g),d++,r.stopTraining_)break}return await m.onTrainEnd(),await r.history.syncData(),r.history}finally{r.isTraining=!1}}function l8(r,t){let e=null;return t.batchesPerEpoch!=null?e=t.batchesPerEpoch:Number.isFinite(r.size)&&(e=r.size),e}function L$(r){return typeof r.iterator=="function"}function u8(r){return typeof r.next=="function"}async function V$(r,t,e){e=e||{};let n=e.batches!=null,o=r.testFunction,s=[];if(e.verbose>0)throw new Nt("Verbose mode is not implemented yet.");x.assert(!n||e.batches>0&&Number.isInteger(e.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(e.batches)}`);let i=u8(t)?t:await t.iterator(),a=0,u=0;for(;!n||u<e.batches;){let l=await i.next();if(s=B(()=>{if(l.value){let{xs:c,ys:p}=z$(r,l.value),m=c.concat(p),f=B(()=>o(m));if(_t(m),u===0)for(let h=0;h<f.length;++h)s.push(pt(0));let d=m[0].shape[0];for(let h=0;h<f.length;++h){let g=f[h],y=s[h];s[h]=B(()=>J(s[h],M(d,g))),u>0&&_t(y)}_t(f),a+=d,++u}return s}),l.done){n&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${e.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let l=0;l<s.length;++l){let c=s[l];s[l]=ct(s[l],a),_t(c)}return _r(s)}function $y(r){x.assert(r>0&&Number.isInteger(r),()=>`batchSize is required to be a positive integer, but got ${r}`)}function Hm(r,t,e){return r==null?[null]:Array.isArray(r)?r.map(n=>al(n,t,e-t)):al(r,t,e-t)}function Dy(r,t){return B(()=>r==null?null:Array.isArray(r)?r.map(e=>Dy(e,t)):py(r,t.dtype==="int32"?t:Z(t,"int32")))}function Ry(r,t){let e=[],n=0,o=null;for(;n<r;)o=n+t,o>=r&&(o=r),e.push([n,o]),n=o;return e}async function c8(r,t,e,n,o,s,i,a,u,l,c,p,m,f,d){o==null&&(o=32),s==null&&(s=1),c==null&&(c=!0),m==null&&(m=0);let h=!1;if(u!=null&&l!=null&&(h=!0),d!=null&&(h=!0,f==null))throw new z("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");let g=r.checkNumSamples(e,o,f,"steps_per_epoch"),y;g!=null&&(y=Jr(0,g)),i==null&&(i=1);let{callbackList:b,history:w}=Cy(a,i,s,m,g,f,o,h,p);b.setModel(r),r.history=w,await b.onTrainBegin(),r.stopTraining_=!1;for(let v=m;v<s;++v){await b.onEpochBegin(v);let k={};if(f!=null)throw new Nt("stepsPerEpoch mode is not implemented yet.");{if(c==="batch")throw new Nt("batch shuffling is not implemneted yet");c&&x.shuffle(y);let E=Re(y),$=Ry(g,o);for(let D=0;D<$.length;++D){let R={};if(await b.onBatchBegin(D,R),B(()=>{let P=$[D][0],W=$[D][1],U=al(E,P,W-P);R.batch=D,R.size=W-P;let q=Dy(e,U),K=t(q);for(let j=0;j<n.length;++j){let Q=n[j],rt=K[j];R[Q]=rt,Pe(rt)}if(D===$.length-1&&h){let j=r.testLoop(u,l,o);for(let Q=0;Q<n.length;++Q){let rt=n[Q],X=j[Q];Pe(X),k["val_"+rt]=X}}}),await b.onBatchEnd(D,R),xy(R),r.stopTraining_)break}E.dispose()}if(await b.onEpochEnd(v,k),r.stopTraining_)break}return await b.onTrainEnd(),await r.history.syncData(),r.history}async function G$(r,t,e,n={}){if(r.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");r.isTraining=!0;let o,s,i,a,u,l,c,p,m;try{let f=n.batchSize==null?32:n.batchSize;$y(f);let d=!1,h=await r.standardizeUserData(t,e,n.sampleWeight,n.classWeight,d,f);o=h[0],s=h[1],m=h[2];let g=!1,y;if(n.validationData!=null&&n.validationData.length>0){if(g=!0,n.validationData.length===2)u=n.validationData[0],l=n.validationData[1];else throw n.validationData.length===3?new Nt("validationData including sample weights is not supported yet."):new z(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${n.validationData} is invalid.`);let R=!0,P=await r.standardizeUserData(u,l,null,null,R,f);c=P[0],p=P[1],y=c.concat(p)}else if(n.validationSplit!=null&&n.validationSplit>0&&n.validationSplit<1){g=!0;let R=Math.floor(o[0].shape[0]*(1-n.validationSplit)),P=o[0].shape[0];c=Hm(o,R,P),i=o,o=Hm(o,0,R),p=Hm(s,R,P),a=s,s=Hm(s,0,R),y=c.concat(p)}else n.validationSteps!=null&&(g=!0);let b=o.concat(s).concat(m);r.checkTrainableWeightsConsistency();let w=r.makeTrainFunction(),v=r.getDedupedMetricsNames(),k,E;g?(r.makeTestFunction(),k=r.testFunction,E=v.slice().concat(v.map(R=>"val_"+R))):(k=null,y=[],E=v.slice());let $=vy(n.callbacks,n.yieldEvery);return await c8(r,w,b,v,f,n.epochs,n.verbose,$,k,y,n.shuffle,E,n.initialEpoch,null,null)}finally{r.isTraining=!1,$o(o,t),$o(s,e),$o(i,t),$o(a,e),$o(c,u),$o(p,l),m!=null&&_t(m)}}function RS(r){let t=[];r instanceof Pt&&(r=[r]);for(let e=0;e<r.length;++e){let n=r[e];if(n.rank===1)t.push(ll(n,1));else{if(n.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(n)}}return t}function $o(r,t){if(r==null)return;let e=[];if(t instanceof Pt)e.push(t.id);else if(Array.isArray(t))t.forEach(o=>e.push(o.id));else if(t!=null)for(let o in t){let s=t[o];e.push(s.id)}let n=[];if(r instanceof Pt)e.indexOf(r.id)===-1&&n.push(r);else if(Array.isArray(r))r.forEach(o=>{e.indexOf(o.id)===-1&&n.push(o)});else if(r!=null)for(let o in r){let s=r[o];e.indexOf(s.id)===-1&&n.push(s)}n.forEach(o=>{o.isDisposed||o.dispose()})}function p8(r){return r instanceof Pt}function FS(r){return Array.isArray(r)}function W$(r){return!p8(r)&&!FS(r)}function U$(r,t,e,n=!0,o=""){if(t==null||t.length===0){if(r!=null){let i=!1;if(FS(r)&&r.length>0)i=!0;else if(W$(r)){for(let a in r)if(r.hasOwnProperty(a)){i=!0;break}}else i=!0;if(i)throw new z(`Error when checking model ${o} expected no data, but got ${r}`)}return[]}if(r==null)return t.map(i=>null);let s;if(W$(r)){r=r,s=[];for(let i of t){if(r[i]==null)throw new z(`No data provided for "${i}". Need data for each key in: ${t}`);s.push(r[i])}}else if(FS(r)){if(r=r,r.length!==t.length)throw new z(`Error when checking model ${o}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${r}`);s=r}else{if(r=r,t.length>1)throw new z(`The model ${o} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${r.shape}`);s=[r]}if(s=RS(s),e!=null)for(let i=0;i<t.length;++i){if(e[i]==null)continue;let a=s[i];if(a.shape.length!==e[i].length)throw new z(`Error when checking ${o}: expected ${t[i]} to have ${e[i].length} dimension(s). but got array with shape ${a.shape}`);for(let u=0;u<e[i].length;++u){if(u===0&&!n)continue;let l=a.shape[u],c=e[i][u];if(c!=null&&c>=0&&l!==c)throw new z(`${o} expected a batch of elements where each example has shape [${e[i].slice(1,e[i].length)}] (i.e.,tensor shape [*,${e[i].slice(1,e[i].length)}]) but the ${o} received an input with ${a.shape[0]} examples, each with shape [${a.shape.slice(1,a.shape.length)}] (tensor shape [${a.shape}])`)}}return s}function m8(r,t,e){let n=To(r.map(s=>s.shape[0]));n.sort();let o=To(t.map(s=>s.shape[0]));if(o.sort(),n.length>1)throw new z(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(r.map(s=>s.shape))}`);if(o.length>1)throw new z(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(s=>s.shape))}`);if(n.length>0&&o.length>0&&!x.arraysEqual(n,o))throw new z(`Input Tensors should have the same number of samples as target Tensors. Found ${n[0]} input sample(s) and ${o[0]} target sample(s).`)}function f8(r,t,e){let n=[ji,Wm,$c];for(let o=0;o<r.length;++o){let s=r[o],i=t[o],a=e[o];if(i!=null){if(i===$c&&s.shape[s.shape.length-1]===1)throw new z(`You are passing a target array of shape ${s.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(n.indexOf(i)!==-1){let u=s.shape.slice(1),l=a.slice(1);for(let c=0;c<u.length;++c){let p=u[c],m=l[c];if(m!=null&&p!==m)throw new z(`A target Tensor with shape ${s.shape} was passed for an output of shape ${a}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function H$(r,t,e,n=!0,o=""){let s;if(Array.isArray(r)){if(r.length!==t.length)throw new z(`Error when checking model ${o}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${r.length} Tensors(s).`);s=r}else{if(t.length>1)throw new z(`The model expects ${t.length} ${o} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(r.shape)}.`);s=[r]}if(e!=null)for(let i=0;i<t.length;++i){if(e[i]==null)continue;let a=s[i];if(a.shape.length!==e[i].length)throw new z(`Error when checking ${o}: expected ${t[i]} to have ${e[i].length} dimension(s), but got array with shape ${JSON.stringify(a.shape)}`);for(let u=0;u<e[i].length;++u){if(u===0&&!n)continue;let l=a.shape[u],c=e[i][u];if(c!=null&&c!==l)throw new z(`Error when checking ${o}: expected ${t[i]} to have shape ${JSON.stringify(e[i])} but got array with shape ${JSON.stringify(a.shape)}.`)}}}function d8(r,t){if(r==null||Array.isArray(r)&&r.length===0)return t.map(n=>[]);let e;if(typeof r=="string"||typeof r=="function")e=[r];else if(Array.isArray(r)||typeof r=="object")e=r;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${r}`);if(Array.isArray(e))return t.map(n=>e);{let n=[];for(let o of t){let s=e.hasOwnProperty(o)?e[o]:[];Array.isArray(s)||(s=[s]),n.push(s)}return n}}var h8="layers-model",Vn=class extends Bn{constructor(t){super(t),this.isTraining=!1}summary(t,e,n=console.log){if(!this.built)throw new z("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");D$(this,t,e,n)}compile(t){if(t.loss==null&&(t.loss=[]),this.loss=t.loss,typeof t.optimizer=="string")this.optimizer_=$$(t.optimizer),this.isOptimizerOwned=!0;else{if(!(t.optimizer instanceof Vr))throw new z("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=t.optimizer,this.isOptimizerOwned=!1}let e=[];if(!Array.isArray(t.loss)&&typeof t.loss!="string"&&typeof t.loss!="function"){t.loss=t.loss;for(let i in t.loss)if(this.outputNames.indexOf(i)===-1)throw new z(`Unknown entry in loss dictionary: "${i}". Only expected the following keys: ${this.outputNames}`);for(let i of this.outputNames)t.loss[i]==null&&console.warn(`Output "${i}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${i} during training`),e.push(Iy(t.loss[i]))}else if(Array.isArray(t.loss)){if(t.loss.length!==this.outputs.length)throw new z(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${t.loss}.`);e=t.loss.map(a=>Iy(a))}else{let i=Iy(t.loss);this.outputs.forEach(a=>{e.push(i)})}this.lossFunctions=e,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let i=0;i<this.outputs.length;++i){let a=this.internalOutputShapes[i],u=this.outputNames[i];this.feedOutputNames.push(u),this.feedOutputShapes.push(a),this.feedLossFns.push(this.lossFunctions[i])}let n=[];this.metrics=t.metrics,this.metricsNames=["loss"],this.metricsTensors=[],si("loss",()=>{for(let i=0;i<this.outputs.length;++i){if(n.indexOf(i)!==-1)continue;let a=this.lossFunctions[i];this.outputs.length>1&&(this.metricsTensors.push([a,i]),this.metricsNames.push(this.outputNames[i]+"_loss"))}});let o=d8(t.metrics,this.outputNames),s=(i,a,u)=>{this.outputNames.length>1&&(a=this.outputNames[i]+"_"+a),this.metricsNames.push(a),this.metricsTensors.push([u,i])};si("metric",()=>{for(let i=0;i<this.outputs.length;++i){if(n.indexOf(i)!==-1)continue;let a=o[i];(l=>{let c="",p,m,f;for(let d of l){if(typeof d=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(d)!==-1){let g=this.internalOutputShapes[i];g[g.length-1]===1||this.lossFunctions[i]===Wm?["accuracy","acc"].indexOf(d)!==-1?m=Yh:["crossentropy","ce"].indexOf(d)!==-1&&(m=ky):this.lossFunctions[i]===Gm?["accuracy","acc"].indexOf(d)!==-1?m=Ny:["crossentropy","ce"].indexOf(d)!==-1&&(m=ES):["accuracy","acc"].indexOf(d)!==-1?m=Zh:["crossentropy","ce"].indexOf(d)!==-1&&(m=Jh);let y;["accuracy","acc"].indexOf(d)!==-1?y="acc":["crossentropy","ce"].indexOf(d)!==-1&&(y="ce"),f=m,p=c+y}else f=E$(d),p=c+Qh(d);let h;si(p,()=>{h=f}),s(i,p,h)}})(a)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(t,e,n={}){let o=n.batchSize==null?32:n.batchSize;$y(o);let s=!0,i=this.standardizeUserDataXY(t,e,s,o);try{let a=i[0].concat(i[1]);this.makeTestFunction();let u=this.testFunction,l=this.testLoop(u,a,o,n.verbose,n.steps);return _r(l)}finally{$o(i[0],t),$o(i[1],e)}}async evaluateDataset(t,e){return this.makeTestFunction(),V$(this,t,e)}checkNumSamples(t,e,n,o="steps"){let s;if(n!=null){if(s=null,e!=null)throw new z(`If ${o} is set, batchSize must be null or undefined.Got batchSize = ${e}`)}else if(t!=null)Array.isArray(t)?s=t[0].shape[0]:s=t.shape[0];else throw new z(`Either the input data should have a defined shape, or ${o} shoud be specified.`);return s}execute(t,e){if(Array.isArray(e)&&e.length===0)throw new z("`outputs` is an empty Array, which is not allowed.");let n=Array.isArray(e),o=n?e:[e],s=this.retrieveSymbolicTensors(o),i=new Ao;if(t instanceof Pt&&(t=[t]),Array.isArray(t)){if(t.length!==this.inputs.length)throw new z(`The number of inputs provided (${t.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let u=0;u<this.inputs.length;++u)i.add(this.inputs[u],t[u])}else for(let u of this.inputs){let l=t[u.name];if(l==null)throw new z(`No value is provided for the model's input ${u.name}`);i.add(u,l)}let a=Rc(s,i);return n?a:a[0]}retrieveSymbolicTensors(t){let e=ko(null,t.length),n=t.length;for(let o of this.layers){let s=Array.isArray(o.output)?o.output:[o.output],i=s.map(a=>a.name);for(let a=0;a<t.length;++a){let u=i.indexOf(t[a]);if(u!==-1&&(e[a]=s[u],n--),n===0)break}if(n===0)break}if(n>0){let o=[];throw e.forEach((s,i)=>{s==null&&o.push(t[i])}),new z(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(o)}`)}return e}predictLoop(t,e=32,n=!1){return B(()=>{let o=this.checkNumSamples(t);if(n)throw new Nt("Verbose predictLoop() is not implemented yet.");let s=Ry(o,e),i=this.outputs.map(a=>[]);for(let a=0;a<s.length;++a)B(()=>{let l=s[a][0],c=s[a][1],p=Hm(t,l,c),m=[];if(Array.isArray(p))for(let d=0;d<p.length;++d)m.push({key:this.inputs[d],value:p[d]});else m.push({key:this.inputs[0],value:p});let f=new Ao(m);return Rc(this.outputs,f)}).forEach((l,c)=>i[c].push(l));return _r(i.map(a=>se(a,0)))})}predict(t,e={}){let n=RS(t);H$(n,this.inputNames,this.feedInputShapes,!1);try{let o=e.batchSize==null?32:e.batchSize;return $y(o),this.predictLoop(n,o)}finally{$o(n,t)}}predictOnBatch(t){H$(t,this.inputNames,this.feedInputShapes,!0);let e=(Array.isArray(t)?t[0]:t).shape[0];return this.predictLoop(t,e)}standardizeUserDataXY(t,e,n=!0,o){if(this.optimizer_==null)throw new Wr("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");let s=[];for(let i=0;i<this.feedOutputShapes.length;++i){let a=this.feedOutputShapes[i];this.feedLossFns[i]===Gm?s.push(a.slice(0,a.length-1).concat([1])):s.push(a)}if(t=U$(t,this.feedInputNames,this.feedInputShapes,!1,"input"),e=U$(e,this.feedOutputNames,s,!1,"target"),m8(t,e,null),f8(e,this.feedLossFns,this.feedOutputShapes),this.stateful&&o!=null&&o>0&&t[0].shape[0]%o!==0)throw new z(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${o}. Found: ${t[0].shape[0]} sample(s).`);return[t,e]}async standardizeUserData(t,e,n,o,s=!0,i){let[a,u]=this.standardizeUserDataXY(t,e,s,i);if(n!=null)throw new Error("sample weight is not supported yet.");let l=null;if(o!=null){let c=Ey(o,this.outputNames);l=[];for(let p=0;p<c.length;++p)l.push(await Ay(u[p],null,c[p]))}return[a,u,l]}testLoop(t,e,n,o=0,s){return B(()=>{let i=this.checkNumSamples(e,n,s,"steps"),a=[];if(o>0)throw new Nt("Verbose mode is not implemented yet.");if(s!=null)throw new Nt("steps mode in testLoop() is not implemented yet");{let u=Ry(i,n),l=Re(Jr(0,i));for(let c=0;c<u.length;++c){let p=u[c][0],m=u[c][1],f=al(l,p,m-p),d=Dy(e,f),h=t(d);if(c===0)for(let g=0;g<h.length;++g)a.push(pt(0));for(let g=0;g<h.length;++g){let y=h[g];a[g]=J(a[g],M(m-p,y))}}for(let c=0;c<a.length;++c)a[c]=ct(a[c],i)}return a})}getDedupedMetricsNames(){let t=this.metricsNames,e=[];for(let n=0;n<t.length;++n){let o=t[n],s=o;wS(t,o)>1&&(s+=`_${wS(t.slice(0,n),o)}`),e.push(s)}return e}makeTrainFunction(){return t=>{let e=[],n=t.slice(0,this.inputs.length),o=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),s=t.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),i=[],a=()=>{let p=[];for(let h=0;h<this.inputs.length;++h)p.push({key:this.inputs[h],value:n[h]});let m=new Ao(p),f=Rc(this.outputs,m,{training:!0}),d;for(let h=0;h<this.lossFunctions.length;++h){let y=this.lossFunctions[h](o[h],f[h]);s[h]!=null&&(y=M$(y,s[h]));let b=xe(y);e.push(b),h===0?d=y:d=J(d,y)}for(let h=0;h<this.metricsTensors.length;++h){let g;if(this.outputs.length>1&&h<this.outputs.length)g=e[h];else{let y=this.metricsTensors[h][0],b=this.metricsTensors[h][1];g=xe(y(o[b],f[b]))}Pe(g),i.push(g)}return d=xe(d),this.calculateLosses().forEach(h=>{d=J(d,h)}),d},u=this.collectedTrainableWeights.map(p=>p.read()),l=!0;return[this.optimizer_.minimize(a,l,u)].concat(i)}}makeTestFunction(){this.testFunction=t=>B(()=>{let e=[],n,o=t.slice(0,this.inputs.length),s=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),i=[];for(let l=0;l<this.inputs.length;++l)i.push({key:this.inputs[l],value:o[l]});let a=new Ao(i),u=Rc(this.outputs,a);for(let l=0;l<this.lossFunctions.length;++l){let c=this.lossFunctions[l],p=xe(c(s[l],u[l]));l===0?n=p:n=J(n,p),e.push(n)}for(let l=0;l<this.metricsTensors.length;++l){let c=this.metricsTensors[l][0],p=this.metricsTensors[l][1],m=xe(c(s[p],u[p]));e.push(m)}return e})}async fit(t,e,n={}){return G$(this,t,e,n)}async fitDataset(t,e){return B$(this,t,e)}async trainOnBatch(t,e){let n=await this.standardizeUserData(t,e),o=n[0],s=n[1],a=this.makeTrainFunction()(o.concat(s)),u=[];for(let l of a){let c=await l.data();u.push(c[0])}return _t(a),$o(n[0],t),$o(n[1],e),_r(u)}getNamedWeights(t){let e=[],n=t!=null&&t.trainableOnly,o=n?this.trainableWeights:this.weights,s=this.getWeights(n);for(let i=0;i<o.length;++i)n&&!o[i].trainable||e.push({name:o[i].originalName,tensor:s[i]});return e}set stopTraining(t){this.stopTraining_=t}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(t){this.optimizer_!==t&&(this.optimizer_=t,this.isOptimizerOwned=!1)}dispose(){let t=super.dispose();if(t.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){let e=oh().numTensors;this.optimizer_.dispose(),t.numDisposedVariables+=e-oh().numTensors}return t}getLossIdentifiers(){let t;if(typeof this.loss=="string")t=No(this.loss);else if(Array.isArray(this.loss)){for(let e of this.loss)if(typeof e!="string")throw new Error("Serialization of non-string loss is not supported.");t=this.loss.map(e=>No(e))}else{let e=Object.keys(this.loss);t={};let n=this.loss;for(let o of e)if(typeof n[o]=="string")t[o]=No(n[o]);else throw new Error("Serialization of non-string loss is not supported.")}return t}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[No(Qh(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(t=>No(Qh(t)));{let t={};for(let e in this.metrics)t[e]=No(Qh(this.metrics[e]));return t}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(t){if(t.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(t.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(t.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");let e=Dc(t.optimizer_config),n=vn(e),o;if(typeof t.loss=="string")o=il(t.loss);else if(Array.isArray(t.loss))o=t.loss.map(i=>il(i));else if(t.loss!=null){o={};for(let i in t.loss)o[i]=il(t.loss[i])}let s;if(Array.isArray(t.metrics))s=t.metrics.map(i=>il(i));else if(t.metrics!=null){s={};for(let i in t.metrics)s[i]=il(t.metrics[i])}this.compile({loss:o,metrics:s,optimizer:n})}async save(t,e){if(typeof t=="string"){let l=Mr.getSaveHandlers(t);if(l.length===0)throw new z(`Cannot find any save handlers for URL '${t}'`);if(l.length>1)throw new z(`Found more than one (${l.length}) save handlers for URL '${t}'`);t=l[0]}if(t.save==null)throw new z("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");let n=await Mr.encodeWeights(this.getNamedWeights(e)),o=!1,s=null,a={modelTopology:this.toJSON(s,o),format:h8,generatedBy:`TensorFlow.js tfjs-layers v${Um}`,convertedBy:null};if((e==null?!1:e.includeOptimizer)&&this.optimizer!=null){a.trainingConfig=this.getTrainingConfig();let l="optimizer",{data:c,specs:p}=await Mr.encodeWeights(await this.optimizer.getWeights(),l);n.specs.push(...p),n.data=Mr.concatenateArrayBuffers([n.data,c])}return this.userDefinedMetadata!=null&&($S(this.userDefinedMetadata,this.name,!0),a.userDefinedMetadata=this.userDefinedMetadata),a.weightData=n.data,a.weightSpecs=n.specs,t.save(a)}setUserDefinedMetadata(t){$S(t,this.name),this.userDefinedMetadata=t}getUserDefinedMetadata(){return this.userDefinedMetadata}};Vn.className="Model";et.registerClass(Vn);var Fy=class extends Vn{};Fy.className="Functional";et.registerClass(Fy);async function q$(r,t){"modelTopology"in r||(r={modelTopology:r}),r=r;let e=r.modelTopology;e.model_config!=null&&(e=e.model_config);let n=Dc(e),o=vn(n,t);if(r.weightsManifest!=null){let s=await Mr.loadWeights(r.weightsManifest,r.pathPrefix,o.weights.map(a=>a.originalName)),i={};for(let a of o.weights)i[a.originalName]=s[a.originalName];o.loadWeights(i),_t(s)}return o}async function K$(r,t){if(t==null&&(t={}),typeof r=="string"){let e=Mr.getLoadHandlers(r,t);if(e.length===0)e.push(Mr.browserHTTPRequest(r,t));else if(e.length>1)throw new z(`Found more than one (${e.length}) load handlers for URL '${r}'`);r=e[0]}return g8(r,void 0,t)}async function g8(r,t,e){if(e==null&&(e={}),r.load==null)throw new z("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let n=await r.load(),o=n.modelTopology;o.model_config!=null&&(o=o.model_config);let s=e.strict==null?!0:e.strict,i=n.weightData!=null&&n.weightSpecs!=null&&s,a=vn(Dc(o),t,i),u=n.trainingConfig;if(u!=null&&a.loadTrainingConfig(u),n.userDefinedMetadata!=null&&a.setUserDefinedMetadata(n.userDefinedMetadata),n.weightData!=null){if(n.weightSpecs==null)throw new z("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");let{modelWeights:l,optimizerWeights:c}=x8(n.weightData,n.weightSpecs);a.loadWeights(l,s),a.optimizer!=null&&c.length>0&&await a.optimizer.setWeights(c),_t(l),_t(c.map(p=>p.tensor))}return a}function x8(r,t){let e=Mr.decodeWeights(r,t),n={},o=[];return t.forEach(s=>{s.group==="optimizer"?o.push({name:s.name,tensor:e[s.name]}):n[s.name]=e[s.name]}),{modelWeights:n,optimizerWeights:o}}var Xi=class extends Vn{constructor(t){if(super({inputs:[],outputs:[]}),t=t||{},this.trainable=!0,this.built=!1,this.name=t.name!=null?t.name:au("sequential_"),t.layers!=null)for(let e of t.layers)this.add(e)}checkShape(t){if(t.inboundNodes[0].outputTensors[0].shape.some(n=>n<0))throw new z(`Negative dimension size caused by adding layer ${t.name} with input shape [${t.inboundNodes[0].inputTensors[0].shape}]`)}add(t){let e=t instanceof Xi||t instanceof Vn,n;if(e){if(n=t,n.outputs.length!==1)throw new z("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(n.inputs.length!==1)throw new z("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(t.inboundNodes.length===0){if(t.batchInputShape==null)throw new z("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");let o=gy({batchShape:t.batchInputShape,dtype:t.dtype,name:t.name+"_input"});t.apply(o)}if(e)this.outputs=n.outputs,this.inputs=n.inputs;else{if(t.inboundNodes.length!==1)throw new z(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${t.name} which has ${t.inboundNodes.length} pre-existing inbound connections.`);if(t.inboundNodes[0].outputTensors.length!==1)throw new z("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[t.inboundNodes[0].outputTensors[0]],this.inputs=NS(this.outputs[0])}this.inboundNodes=[],new ul({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:ko(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(o=>o.shape),outputShapes:this.outputs[0].shape})}else{let o=t.apply(this.outputs[0]);if(Array.isArray(o))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[o],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(t),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{let t=this.layers.length-1;this.layers[t].outboundNodes=[],this.outputs=[this.layers[t].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(t,e){return this.model==null&&this.build(),this.model.call(t,e)}build(t){if(Jt(t),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new Vn({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(t,e,n=console.log){this.built||this.build(),super.summary(t,e,n)}setWeights(t){this.model==null&&this.build(),this.model.setWeights(t)}evaluate(t,e,n={}){if(!this.built)throw new Wr("The model needs to be compiled before being used.");return this.model.evaluate(t,e,n)}async evaluateDataset(t,e){if(!this.built)throw new Wr("The model needs to be compiled before being used.");return this.model.evaluateDataset(t,e)}predict(t,e={}){return this.model==null&&this.build(),this.model.predict(t,e)}predictOnBatch(t){return this.model==null&&this.build(),this.model.predictOnBatch(t)}compile(t){this.build(),this.model.compile(t),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(t){this.model.optimizer=t}async fit(t,e,n={}){if(!this.built)throw new Wr("The model needs to be compiled before being used.");return this.model.fit(t,e,n)}async fitDataset(t,e){if(!this.built)throw new Wr("The model needs to be compiled before being used.");return this.model.fitDataset(t,e)}async trainOnBatch(t,e){return this.model.trainOnBatch(t,e)}static fromConfig(t,e,n={},o=!1){let s,i={};if(e instanceof Array){if(e[0].className==null||e[0].className==="Merge")throw new z("Legacy serialization format not supported yet.");s=e}else x.assert(e.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),s=e.layers,delete e.layers,i=e;let a=new t(i);if(!(a instanceof Xi))throw new Nt(`Sequential.fromConfig called on non-Sequential input: ${a}`);for(let u of s){let c=vn(u,void 0,o);o&&c.setFastWeightInitDuringBuild(!0),a.add(c)}return a}set stopTraining(t){if(this.model==null)throw new z("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=t}get stopTraining(){if(this.model==null)throw new z("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){let t=[];for(let e of this.layers){let n={};n.className=e.getClassName(),n.config=e.getConfig(),t.push(n)}return{name:this.name,layers:t}}};Xi.className="Sequential";et.registerClass(Xi);function y8(r){return new Vn(r)}function b8(r){return new Xi(r)}function w8(r,t){return t==null&&(t={}),K$(r,t)}function OS(r){return gy(r)}function v8(r,t){wn.registerCallbackConstructor(r,t)}var tn=class extends et.Serializable{getConfig(){return{}}},Oy=class extends tn{apply(t,e=1){return h$(t,e)}};Oy.className="elu";et.registerClass(Oy);var My=class extends tn{apply(t){return cc(t)}};My.className="selu";et.registerClass(My);var Py=class extends tn{apply(t){return Tr(t)}};Py.className="relu";et.registerClass(Py);var Ly=class extends tn{apply(t){return B(()=>ti(6,Tr(t)))}};Ly.className="relu6";et.registerClass(Ly);var zy=class extends tn{apply(t){return t}};zy.className="linear";et.registerClass(zy);var By=class extends tn{apply(t){return Lr(t)}};By.className="sigmoid";et.registerClass(By);var Vy=class extends tn{apply(t){return x$(t)}};Vy.className="hardSigmoid";et.registerClass(Vy);var Gy=class extends tn{apply(t){return bo(t)}};Gy.className="softplus";et.registerClass(Gy);var Wy=class extends tn{apply(t){return g$(t)}};Wy.className="softsign";et.registerClass(Wy);var Uy=class extends tn{apply(t){return Xs(t)}};Uy.className="tanh";et.registerClass(Uy);var qm=class extends tn{apply(t,e=-1){return nl(t,e)}};qm.className="softmax";et.registerClass(qm);var Hy=class extends tn{apply(t,e=-1){return rc(t,e)}};Hy.className="logSoftmax";et.registerClass(Hy);var qy=class extends tn{apply(t,e=1){return B(()=>M(Lr(M(t,e)),t))}};qy.className="swish";et.registerClass(qy);var Ky=class extends tn{apply(t){return B(()=>M(t,Xs(bo(t))))}};Ky.className="mish";et.registerClass(Ky);function li(r){return r.getClassName()}function MS(r,t={}){return Hi(r,et.SerializationMap.getMap().classNameMap,t,"activation")}function ui(r){if(r==null){let t={};return t.className="linear",t.config={},MS(t)}if(typeof r=="string"){let t={};return t.className=r,t.config={},MS(t)}else return r instanceof tn?r:MS(r)}function PS(r){if(r!=null&&typeof r!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${r}`)}var jy=class extends et.Serializable{},uu=class extends jy{constructor(t){super(),PS(t),this.l1=t==null||t.l1==null?.01:t.l1,this.l2=t==null||t.l2==null?.01:t.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(t){return B(()=>{let e=ye([1]);return this.hasL1&&(e=J(e,mt(M(this.l1,Ne(t))))),this.hasL2&&(e=J(e,mt(M(this.l2,Sc(t))))),O(e,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(t,e){return new t({l1:e.l1,l2:e.l2})}};uu.className="L1L2";et.registerClass(uu);function Y$(r){return PS(r),new uu({l1:r!=null?r.l1:null,l2:0})}function Z$(r){return PS(r),new uu({l2:r!=null?r.l2:null,l1:0})}var j$={l1l2:"L1L2"};function me(r){return Im(r)}function X$(r,t={}){return Hi(r,et.SerializationMap.getMap().classNameMap,t,"regularizer")}function Ce(r){if(r==null)return null;if(typeof r=="string"){let e={className:r in j$?j$[r]:r,config:{}};return X$(e)}else return r instanceof jy?r:X$(r)}var Km=class extends Bt{constructor(t){super(t==null?{}:t),this.supportsMasking=!0,t!=null&&(this.maxValue=t.maxValue)}call(t,e){t=Mt(t);let n=Tr(t);return this.maxValue!=null&&(n=br(n,0,this.maxValue)),n}computeOutputShape(t){return t}getConfig(){let t={maxValue:this.maxValue},e=super.getConfig();return Object.assign(t,e),t}};Km.className="ReLU";et.registerClass(Km);var jm=class extends Bt{constructor(t){super(t==null?{}:t),this.DEFAULT_ALPHA=.3,t==null&&(t={}),this.alpha=t.alpha==null?this.DEFAULT_ALPHA:t.alpha}call(t,e){let n=Mt(t);return Ya(n,this.alpha)}computeOutputShape(t){return t}getConfig(){let t={alpha:this.alpha},e=super.getConfig();return Object.assign(t,e),t}};jm.className="LeakyReLU";et.registerClass(jm);var Xm=class extends Bt{constructor(t){if(super(t==null?{}:t),this.DEFAULT_ALPHA_INITIALIZER="zeros",t==null&&(t={}),this.supportsMasking=!0,this.alphaInitializer=de(t.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=Ce(t.alphaRegularizer),this.alphaConstraint=Ue(t.alphaConstraint),t.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(t.sharedAxes))this.sharedAxes=t.sharedAxes;else if(typeof t.sharedAxes=="number")this.sharedAxes=[t.sharedAxes];else throw new z(`Expected sharedAxes to be a number or an array of numbers, but got ${t.sharedAxes}`)}build(t){t=Jt(t);let e=t.slice(1);if(this.sharedAxes!=null)for(let o of this.sharedAxes)e[o-1]=1;this.alpha=this.addWeight("alpha",e,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);let n={};if(this.sharedAxes!=null)for(let o=1;o<t.length;++o)n[o]=t[o];this.inputSpec=[new ve({ndim:t.length,axes:n})],this.built=!0}call(t,e){return t=Mt(t),el(t,this.alpha.read())}getConfig(){let t={alphaInitializer:Ee(this.alphaInitializer),alphaRegularizer:me(this.alphaRegularizer),alphaConstraint:We(this.alphaConstraint),sharedAxes:this.sharedAxes},e=super.getConfig();return Object.assign(t,e),t}};Xm.className="PReLU";et.registerClass(Xm);var Ym=class extends Bt{constructor(t){if(super(t==null?{}:t),this.DEFAULT_ALPHA=1,t==null&&(t={}),t.alpha!=null&&t.alpha!==this.DEFAULT_ALPHA)throw new Nt(`Non-default alpha value (${t.alpha}) is not supported by the ELU layer yet.`);this.alpha=t.alpha==null?this.DEFAULT_ALPHA:t.alpha}call(t,e){let n=Mt(t);return Zs(n)}computeOutputShape(t){return t}getConfig(){let t={alpha:this.alpha},e=super.getConfig();return Object.assign(t,e),t}};Ym.className="ELU";et.registerClass(Ym);var Zm=class extends Bt{constructor(t){super(t==null?{}:t),this.DEFAULT_THETA=1,t==null&&(t={}),this.theta=t.theta==null?this.DEFAULT_THETA:t.theta}call(t,e){let n=Mt(t);return M(n,Z(Ge(n,this.theta),"float32"))}computeOutputShape(t){return t}getConfig(){let t={theta:this.theta},e=super.getConfig();return Object.assign(t,e),t}};Zm.className="ThresholdedReLU";et.registerClass(Zm);var Jm=class extends Bt{constructor(t){super(t==null?{}:t),this.DEFAULT_AXIS=1,t==null&&(t={}),this.softmax=new qm().apply,this.axis=t.axis==null?this.DEFAULT_AXIS:t.axis}call(t,e){let n=Mt(t);return this.softmax(n,this.axis)}computeOutputShape(t){return t}getConfig(){let t={axis:this.axis},e=super.getConfig();return Object.assign(t,e),t}};Jm.className="Softmax";et.registerClass(Jm);function cu(r,t,e){if(typeof r=="number")return ko(r,t);if(r.length!==t)throw new z(`The ${e} argument must be an integer or tuple of ${t} integers. Received: ${r.length} elements.`);for(let n=0;n<t;++n){let o=r[n];if(!p$(o))throw new z(`The ${e} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(r)} including a non-integer number ${o}`)}return r}function An(r,t,e,n,o=1){if(r==null)return r;let s=t+(t-1)*(o-1),i;return e==="same"?i=r:i=r-s+1,Math.floor((i+n-1)/n)}function ci(r,t,e,n){if(r==null)return null;if(n==="valid")r=r*t+ii([e-t,0]);else if(n==="same")r=r*t;else throw new z(`Unsupport padding mode: ${n}.`);return r}function tg(r,t){return B(()=>(Le(t),t==="channelsFirst"?Wt(r,[0,2,3,1]):r))}function LS(r,t){return B(()=>(Le(t),t==="channelsFirst"?Wt(r,[0,2,3,4,1]):r))}function I8(r,t,e,n=1,o="valid",s,i=1){return B(()=>{if(s==null&&(s=hn()),Le(s),r.shape.length!==3)throw new z(`The input of a conv1dWithBias operation should be 3, but is ${r.shape.length} instead.`);if(t.shape.length!==3)throw new z(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(e!=null&&e.shape.length!==1)throw new z(`The bias for a conv1dWithBias operation should be 1, but is ${t.shape.length} instead`);if(s==="channelsFirst"&&(r=Wt(r,[0,2,1])),o==="causal")throw new Nt("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let a=Yu(r,t,n,o==="same"?"same":"valid","NWC",i);return e!=null&&(a=xn(a,e)),a})}function J$(r,t,e,n=[1,1],o="valid",s,i,a=null){return B(()=>{if(s==null&&(s=hn()),Le(s),r.rank!==3&&r.rank!==4)throw new z(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${r.rank}.`);if(t.rank!==3&&t.rank!==4)throw new z(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${r.rank}.`);let u=tg(r,s);if(o==="causal")throw new Nt("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return u=Co.conv2d({x:u,filter:t,strides:n,pad:o==="same"?"same":"valid",dilations:i,dataFormat:"NHWC",bias:e,activation:a}),s==="channelsFirst"&&(u=Wt(u,[0,3,1,2])),u})}function S8(r,t,e,n=[1,1,1],o="valid",s,i){return B(()=>{if(s==null&&(s=hn()),Le(s),r.rank!==4&&r.rank!==5)throw new z(`conv3dWithBias expects input to be of rank 4 or 5, but received ${r.rank}.`);if(t.rank!==4&&t.rank!==5)throw new z(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${r.rank}.`);let a=LS(r,s);if(o==="causal")throw new Nt("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return a=gh(a,t,n,o==="same"?"same":"valid","NDHWC",i),e!=null&&(a=xn(a,e)),s==="channelsFirst"&&(a=Wt(a,[0,4,1,2,3])),a})}var Fc=class extends Bt{constructor(t,e){if(super(e),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",Fc.verifyArgs(e),this.rank=t,er(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new Nt(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=cu(e.kernelSize,t,"kernelSize"),this.strides=cu(e.strides==null?1:e.strides,t,"strides"),this.padding=e.padding==null?"valid":e.padding,gn(this.padding),this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Le(this.dataFormat),this.activation=ui(e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.biasInitializer=de(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=Ue(e.biasConstraint),this.biasRegularizer=Ce(e.biasRegularizer),this.activityRegularizer=Ce(e.activityRegularizer),this.dilationRate=cu(e.dilationRate==null?1:e.dilationRate,t,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new z(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new z(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new z(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(t){if(Qn("kernelSize"in t,"required key 'kernelSize' not in config"),typeof t.kernelSize!="number"&&!sy(t.kernelSize,"number",1,3))throw new z(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(t.kernelSize)}.`)}getConfig(){let t={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:li(this.activation),useBias:this.useBias,biasInitializer:Ee(this.biasInitializer),biasRegularizer:me(this.biasRegularizer),activityRegularizer:me(this.activityRegularizer),biasConstraint:We(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}},pu=class extends Fc{constructor(t,e){super(t,e),this.kernel=null,pu.verifyArgs(e),this.filters=e.filters,er(this.filters,"filters"),this.kernelInitializer=de(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=Ue(e.kernelConstraint),this.kernelRegularizer=Ce(e.kernelRegularizer)}build(t){t=Jt(t);let e=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[e]==null)throw new z(`The channel dimension of the input should be defined. Found ${t[e]}`);let n=t[e],o=this.kernelSize.concat([n,this.filters]);this.kernel=this.addWeight("kernel",o,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[e]:n}}],this.built=!0}call(t,e){return B(()=>{t=Mt(t);let n,o=this.bias==null?null:this.bias.read(),s=iy(this.activation.getClassName());if(s!=null&&this.rank===2)n=J$(t,this.kernel.read(),o,this.strides,this.padding,this.dataFormat,this.dilationRate,s);else{if(this.rank===1)n=I8(t,this.kernel.read(),o,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)n=J$(t,this.kernel.read(),o,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)n=S8(t,this.kernel.read(),o,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new Nt("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(n=this.activation.apply(n))}return n})}computeOutputShape(t){t=Jt(t);let e=[],n=this.dataFormat==="channelsLast"?t.slice(1,t.length-1):t.slice(2);for(let s=0;s<n.length;++s){let i=An(n[s],this.kernelSize[s],this.padding,this.strides[s],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[s]);e.push(i)}let o=[t[0]];return this.dataFormat==="channelsLast"?(o=o.concat(e),o.push(this.filters)):(o.push(this.filters),o=o.concat(e)),o}getConfig(){let t={filters:this.filters,kernelInitializer:Ee(this.kernelInitializer),kernelRegularizer:me(this.kernelRegularizer),kernelConstraint:We(this.kernelConstraint)},e=super.getConfig();return Object.assign(t,e),t}static verifyArgs(t){if(!("filters"in t)||typeof t.filters!="number"||t.filters<1)throw new z(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(t.filters)}`)}},pl=class extends pu{constructor(t){super(2,t),pl.verifyArgs(t)}getConfig(){let t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!sy(t.kernelSize,"number",1,2))throw new z(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(t.kernelSize)}.`)}};pl.className="Conv2D";et.registerClass(pl);var ml=class extends pu{constructor(t){super(3,t),ml.verifyArgs(t)}getConfig(){let t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!(Array.isArray(t.kernelSize)&&(t.kernelSize.length===1||t.kernelSize.length===3)))throw new z(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(t.kernelSize)}.`)}};ml.className="Conv3D";et.registerClass(ml);var Qm=class extends pl{constructor(t){if(super(t),this.inputSpec=[new ve({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new z(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(t){if(t=Jt(t),t.length!==4)throw new z("Input should have rank 4; Received input shape: "+JSON.stringify(t));let e=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[e]==null)throw new z("The channel dimension of the inputs should be defined. Found `None`.");let n=t[e],o=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",o,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new ve({ndim:4,axes:{[e]:n}})],this.built=!0}call(t,e){return B(()=>{let n=Mt(t);if(n.shape.length!==4)throw new z(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${n.shape.length}`);let o=n.shape,s=o[0],i,a;this.dataFormat==="channelsFirst"?(i=2,a=3):(i=1,a=2);let u=o[i],l=o[a],c=this.kernelSize[0],p=this.kernelSize[1],m=this.strides[0],f=this.strides[1],d=ci(u,m,c,this.padding),h=ci(l,f,p,this.padding),g=[s,d,h,this.filters];this.dataFormat!=="channelsLast"&&(n=Wt(n,[0,2,3,1]));let y=Zu(n,this.kernel.read(),g,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(y=Wt(y,[0,3,1,2])),this.bias!=null&&(y=xn(y,this.bias.read(),this.dataFormat)),this.activation!=null&&(y=this.activation.apply(y)),y})}computeOutputShape(t){t=Jt(t);let e=t.slice(),n,o,s;this.dataFormat==="channelsFirst"?(n=1,o=2,s=3):(n=3,o=1,s=2);let i=this.kernelSize[0],a=this.kernelSize[1],u=this.strides[0],l=this.strides[1];return e[n]=this.filters,e[o]=ci(e[o],u,i,this.padding),e[s]=ci(e[s],l,a,this.padding),e}getConfig(){let t=super.getConfig();return delete t.dilationRate,t}};Qm.className="Conv2DTranspose";et.registerClass(Qm);var tf=class extends ml{constructor(t){if(super(t),this.inputSpec=[new ve({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new z(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(t){if(t=Jt(t),t.length!==5)throw new z("Input should have rank 5; Received input shape: "+JSON.stringify(t));let e=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[e]==null)throw new z("The channel dimension of the inputs should be defined. Found `None`.");let n=t[e],o=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",o,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new ve({ndim:5,axes:{[e]:n}})],this.built=!0}call(t,e){return B(()=>{let n=Mt(t);if(n.shape.length!==5)throw new z(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${n.shape.length}`);let o=n.shape,s=o[0],i,a,u;this.dataFormat==="channelsFirst"?(u=2,i=3,a=4):(u=1,i=2,a=3);let l=o[u],c=o[i],p=o[a],m=this.kernelSize[0],f=this.kernelSize[1],d=this.kernelSize[2],h=this.strides[0],g=this.strides[1],y=this.strides[2],b=ci(l,h,m,this.padding),w=ci(c,g,f,this.padding),v=ci(p,y,d,this.padding),k=[s,b,w,v,this.filters];this.dataFormat!=="channelsLast"&&(n=Wt(n,[0,2,3,4,1]));let E=PI(n,this.kernel.read(),k,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(E=Wt(E,[0,4,1,2,3])),this.bias!==null&&(E=xn(E,this.bias.read(),this.dataFormat)),this.activation!==null&&(E=this.activation.apply(E)),E})}computeOutputShape(t){t=Jt(t);let e=t.slice(),n,o,s,i;this.dataFormat==="channelsFirst"?(n=1,o=2,s=3,i=4):(n=4,o=1,s=2,i=3);let a=this.kernelSize[0],u=this.kernelSize[1],l=this.kernelSize[2],c=this.strides[0],p=this.strides[1],m=this.strides[2];return e[n]=this.filters,e[o]=ci(e[o],c,a,this.padding),e[s]=ci(e[s],p,u,this.padding),e[i]=ci(e[i],m,l,this.padding),e}getConfig(){let t=super.getConfig();return delete t.dilationRate,t}};tf.className="Conv3DTranspose";et.registerClass(tf);var Xy=class extends pu{constructor(t,e){if(super(t,e),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,e.filters==null)throw new z("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(e.kernelInitializer!=null||e.kernelRegularizer!=null||e.kernelConstraint!=null)throw new z("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(e.padding!=null&&e.padding!=="same"&&e.padding!=="valid")throw new z(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(e.padding)}`);this.depthMultiplier=e.depthMultiplier==null?1:e.depthMultiplier,this.depthwiseInitializer=de(e.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=Ce(e.depthwiseRegularizer),this.depthwiseConstraint=Ue(e.depthwiseConstraint),this.pointwiseInitializer=de(e.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=Ce(e.pointwiseRegularizer),this.pointwiseConstraint=Ue(e.pointwiseConstraint)}build(t){if(t=Jt(t),t.length<this.rank+2)throw new z(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(t)}`);let e=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[e]==null||t[e]<0)throw new z(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(t[e])}`);let n=t[e],o=this.kernelSize.concat([n,this.depthMultiplier]),s=[];for(let a=0;a<this.rank;++a)s.push(1);s.push(n*this.depthMultiplier,this.filters);let i=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",o,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,i,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",s,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,i,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,i,this.biasConstraint):this.bias=null,this.inputSpec=[new ve({ndim:this.rank+2,axes:{[e]:n}})],this.built=!0}call(t,e){return B(()=>{t=Mt(t);let n;if(this.rank===1)throw new Nt("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(t=Wt(t,[0,2,3,1])),n=$h(t,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(n=xn(n,this.bias.read(),this.dataFormat)),this.activation!=null&&(n=this.activation.apply(n)),this.dataFormat==="channelsFirst"&&(n=Wt(n,[0,3,1,2])),n})}getConfig(){let t=super.getConfig();return delete t.rank,delete t.kernelInitializer,delete t.kernelRegularizer,delete t.kernelConstraint,t.depthwiseInitializer=Ee(this.depthwiseInitializer),t.pointwiseInitializer=Ee(this.pointwiseInitializer),t.depthwiseRegularizer=me(this.depthwiseRegularizer),t.pointwiseRegularizer=me(this.pointwiseRegularizer),t.depthwiseConstraint=We(this.depthwiseConstraint),t.pointwiseConstraint=We(this.pointwiseConstraint),t}};Xy.className="SeparableConv";var ef=class extends Xy{constructor(t){super(2,t)}};ef.className="SeparableConv2D";et.registerClass(ef);var mu=class extends pu{constructor(t){super(1,t),mu.verifyArgs(t),this.inputSpec=[{ndim:3}]}getConfig(){let t=super.getConfig();return delete t.rank,delete t.dataFormat,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!sy(t.kernelSize,"number",1,1))throw new z(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(t.kernelSize)}.`)}};mu.className="Conv1D";et.registerClass(mu);var rf=class extends Bt{constructor(t){super(t),typeof t.cropping=="number"?this.cropping=[[t.cropping,t.cropping],[t.cropping,t.cropping]]:typeof t.cropping[0]=="number"?this.cropping=[[t.cropping[0],t.cropping[0]],[t.cropping[1],t.cropping[1]]]:this.cropping=t.cropping,this.dataFormat=t.dataFormat===void 0?"channelsLast":t.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(t){return this.dataFormat==="channelsFirst"?[t[0],t[1],t[2]-this.cropping[0][0]-this.cropping[0][1],t[3]-this.cropping[1][0]-this.cropping[1][1]]:[t[0],t[1]-this.cropping[0][0]-this.cropping[0][1],t[2]-this.cropping[1][0]-this.cropping[1][1],t[3]]}call(t,e){return B(()=>{if(t=Mt(t),this.dataFormat==="channelsLast"){let n=Uh(t,this.cropping[0][0],t.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return Uh(n,this.cropping[1][0],t.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{let n=Uh(t,this.cropping[0][0],t.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return Uh(n,this.cropping[1][0],t.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){let t={cropping:this.cropping,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}};rf.className="Cropping2D";et.registerClass(rf);var nf=class extends Bt{constructor(t){super(t),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=t.size==null?this.DEFAULT_SIZE:t.size,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,Le(this.dataFormat),this.interpolation=t.interpolation==null?"nearest":t.interpolation,u$(this.interpolation)}computeOutputShape(t){if(this.dataFormat==="channelsFirst"){let e=t[2]==null?null:this.size[0]*t[2],n=t[3]==null?null:this.size[1]*t[3];return[t[0],t[1],e,n]}else{let e=t[1]==null?null:this.size[0]*t[1],n=t[2]==null?null:this.size[1]*t[2];return[t[0],e,n,t[3]]}}call(t,e){return B(()=>{let n=Mt(t),o=n.shape;if(this.dataFormat==="channelsFirst"){n=Wt(n,[0,2,3,1]);let s=this.size[0]*o[2],i=this.size[1]*o[3],a=this.interpolation==="nearest"?dn.resizeNearestNeighbor(n,[s,i]):dn.resizeBilinear(n,[s,i]);return Wt(a,[0,3,1,2])}else{let s=this.size[0]*o[1],i=this.size[1]*o[2];return this.interpolation==="nearest"?dn.resizeNearestNeighbor(n,[s,i]):dn.resizeBilinear(n,[s,i])}})}getConfig(){let t={size:this.size,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}};nf.className="UpSampling2D";et.registerClass(nf);function k8(r,t,e=[1,1],n="valid",o,s){return B(()=>{o==null&&(o=hn()),Le(o);let i=tg(r,o);if(r.rank!==4)throw new z(`Input for depthwiseConv2d is required to be 4-D, but is instead ${r.rank}-D`);if(t.rank!==4)throw new z(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return i=Ys(i,t,e,n==="same"?"same":"valid","NHWC",s),o==="channelsFirst"&&(i=Wt(i,[0,3,1,2])),i})}var of=class extends Fc{constructor(t){super(2,t),this.depthwiseKernel=null,this.depthMultiplier=t.depthMultiplier==null?1:t.depthMultiplier,this.depthwiseInitializer=de(t.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=Ue(t.depthwiseConstraint),this.depthwiseRegularizer=Ce(t.depthwiseRegularizer)}build(t){if(t=Jt(t),t.length<4)throw new z(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(t)}.`);let e=this.dataFormat==="channelsFirst"?1:3;if(t[e]==null||t[e]<0)throw new z(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${t[e]}).`);let n=t[e],o=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",o,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return B(()=>{t=Mt(t);let n=k8(t,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(n=xn(n,this.bias.read(),this.dataFormat)),this.activation!=null&&(n=this.activation.apply(n)),n})}computeOutputShape(t){t=Jt(t);let e=this.dataFormat==="channelsFirst"?t[2]:t[1],n=this.dataFormat==="channelsFirst"?t[3]:t[2],o=this.dataFormat==="channelsFirst"?t[1]*this.depthMultiplier:t[3]*this.depthMultiplier,s=An(e,this.kernelSize[0],this.padding,this.strides[0]),i=An(n,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[t[0],o,s,i]:[t[0],s,i,o]}getConfig(){let t=super.getConfig();return t.depthMultiplier=this.depthMultiplier,t.depthwiseInitializer=Ee(this.depthwiseInitializer),t.depthwiseRegularizer=me(this.depthwiseRegularizer),t.depthwiseConstraint=We(this.depthwiseRegularizer),t}};of.className="DepthwiseConv2D";et.registerClass(of);function zS(r,t,e,n){if(Array.isArray(r)){if(t!=null||e!=null)throw new z("When inputs is an array, neither initialState or constants should be provided");n!=null&&(e=r.slice(r.length-n,r.length),r=r.slice(0,r.length-n)),r.length>1&&(t=r.slice(1,r.length)),r=r[0]}function o(s){return s==null||Array.isArray(s)?s:[s]}return t=o(t),e=o(e),{inputs:r,initialState:t,constants:e}}function BS(r,t,e,n=!1,o,s,i=!1,a=!1){return B(()=>{let u=t.shape.length;if(u<3)throw new z(`Input should be at least 3D, but is ${u}D.`);let l=[1,0].concat(Jr(2,u));if(t=Wt(t,l),s!=null)throw new Nt("The rnn() functoin of the deeplearn.js backend does not support constants yet.");i&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),o!=null&&(o=Z(Z(o,"bool"),"float32"),o.rank===u-1&&(o=fr(o,-1)),o=Wt(o,l)),n&&(t=ir(t,0),o!=null&&(o=ir(o,0)));let c=[],p,m=e,f=t.shape[0],d=vr(t),h;o!=null&&(h=vr(o));for(let y=0;y<f;++y){let b=d[y],w=B(()=>r(b,m));if(o==null)p=w[0],m=w[1];else{let v=B(()=>{let k=h[y],E=lt(dr(k),k),$=J(M(w[0],k),M(m[0],E)),D=m.map((R,P)=>J(M(w[1][P],k),M(R,E)));return{output:$,newStates:D}});p=v.output,m=v.newStates}a&&c.push(p)}let g;return a&&(g=Je(c,1)),[p,g,m]})}var $n=class extends Bt{constructor(t){super(t);let e;if(t.cell==null)throw new z("cell property is missing for the constructor of RNN.");if(Array.isArray(t.cell)?e=new Pc({cells:t.cell}):e=t.cell,e.stateSize==null)throw new z("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=e,this.returnSequences=t.returnSequences==null?!1:t.returnSequences,this.returnState=t.returnState==null?!1:t.returnState,this.goBackwards=t.goBackwards==null?!1:t.goBackwards,this._stateful=t.stateful==null?!1:t.stateful,this.unroll=t.unroll==null?!1:t.unroll,this.supportsMasking=!0,this.inputSpec=[new ve({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){let t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return Jr(0,t).map(e=>null)}else return this.states_}setStates(t){this.states_=t}computeOutputShape(t){hy(t)&&(t=t[0]),t=t;let e=this.cell.stateSize;Array.isArray(e)||(e=[e]);let n=e[0],o;if(this.returnSequences?o=[t[0],t[1],n]:o=[t[0],n],this.returnState){let s=[];for(let i of e)s.push([t[0],i]);return[o].concat(s)}else return o}computeMask(t,e){return B(()=>{Array.isArray(e)&&(e=e[0]);let n=this.returnSequences?e:null;if(this.returnState){let o=this.states.map(s=>null);return[n].concat(o)}else return n})}get states(){if(this.states_==null){let t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,e=[];for(let n=0;n<t;++n)e.push(null);return e}else return this.states_}set states(t){this.states_=t}build(t){if(this.numConstants!=null)throw new Nt("Constants support is not implemented in RNN yet.");hy(t)&&(t=t[0]),t=t;let n=this.stateful?t[0]:null,o=t.slice(2);this.inputSpec[0]=new ve({shape:[n,null,...o]});let s=[t[0]].concat(t.slice(2));this.cell.build(s);let i;if(Array.isArray(this.cell.stateSize)?i=this.cell.stateSize:i=[this.cell.stateSize],this.stateSpec!=null){if(!x.arraysEqual(this.stateSpec.map(a=>a.shape[a.shape.length-1]),i))throw new z(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=i.map(a=>new ve({shape:[null,a]}));this.stateful&&this.resetStates()}resetStates(t,e=!1){B(()=>{if(!this.stateful)throw new En("Cannot call resetStates() on an RNN Layer that is not stateful.");let n=this.inputSpec[0].shape[0];if(n==null)throw new z("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(o=>ye([n,o])):this.states_=[ye([n,this.cell.stateSize])];else if(t==null)_t(this.states_),this.keptStates!=null&&(_t(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(o=>ye([n,o])):this.states_[0]=ye([n,this.cell.stateSize]);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new z(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);e===!0?this.keptStates.push(this.states_.slice()):_t(this.states_);for(let o=0;o<this.states_.length;++o){let s=t[o],i=Array.isArray(this.cell.stateSize)?this.cell.stateSize[o]:this.cell.stateSize,a=[n,i];if(!x.arraysEqual(s.shape,a))throw new z(`State ${o} is incompatible with layer ${this.name}: expected shape=${a}, received shape=${s.shape}`);this.states_[o]=s}}this.states_=this.states_.map(o=>Pe(o.clone()))})}apply(t,e){let n=e==null?null:e.initialState,o=e==null?null:e.constants;e==null&&(e={});let s=zS(t,n,o,this.numConstants);t=s.inputs,n=s.initialState,o=s.constants;let i=[],a=[];if(n!=null){e.initialState=n,i=i.concat(n),this.stateSpec=[];for(let l of n)this.stateSpec.push(new ve({shape:l.shape}));a=a.concat(this.stateSpec)}if(o!=null&&(e.constants=o,i=i.concat(o),this.numConstants=o.length),i[0]instanceof Qr){let l=[t].concat(i),c=this.inputSpec.concat(a),p=this.inputSpec;this.inputSpec=c;let m=super.apply(l,e);return this.inputSpec=p,m}else return super.apply(t,e)}call(t,e){return B(()=>{let n=e==null?null:e.mask,o=e==null?null:e.training,s=e==null?null:e.initialState;t=Mt(t),s==null&&(this.stateful?s=this.states_:s=this.getInitialState(t));let i=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(s.length!==i)throw new z(`RNN Layer has ${i} state(s) but was passed ${s.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");let a={training:o},l=BS((d,h)=>{let g=this.cell.call([d].concat(h),a);return[g[0],g.slice(1)]},t,s,this.goBackwards,n,null,this.unroll,this.returnSequences),c=l[0],p=l[1],m=l[2];this.stateful&&this.resetStates(m,o);let f=this.returnSequences?p:c;return this.returnState?[f].concat(m):f})}getInitialState(t){return B(()=>{let e=ye(t.shape);return e=mt(e,[1,2]),e=ll(e),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(n=>n>1?cy(e,[1,n]):e):this.cell.stateSize>1?[cy(e,[1,this.cell.stateSize])]:[e]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(t)}getConfig(){let t=super.getConfig(),e={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(e.numConstants=this.numConstants);let n=this.cell.getConfig();return this.getClassName()===$n.className&&(e.cell={className:this.cell.getClassName(),config:n}),Object.assign({},n,t,e)}static fromConfig(t,e,n={}){let o=e.cell,s=vn(o,n);return new t(Object.assign(e,{cell:s}))}};$n.className="RNN";et.registerClass($n);var fl=class extends Bt{},Oc=class extends fl{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,er(this.units,"units"),this.activation=ui(t.activation==null?this.DEFAULT_ACTIVATION:t.activation),this.useBias=t.useBias==null?!0:t.useBias,this.kernelInitializer=de(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=de(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=de(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Ce(t.kernelRegularizer),this.recurrentRegularizer=Ce(t.recurrentRegularizer),this.biasRegularizer=Ce(t.biasRegularizer),this.kernelConstraint=Ue(t.kernelConstraint),this.recurrentConstraint=Ue(t.recurrentConstraint),this.biasConstraint=Ue(t.biasConstraint),this.dropout=Cc([1,ii([0,t.dropout==null?0:t.dropout])]),this.recurrentDropout=Cc([1,ii([0,t.recurrentDropout==null?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=Jt(t),this.kernel=this.addWeight("kernel",[t[t.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return B(()=>{if(t=t,t.length!==2)throw new z(`SimpleRNNCell expects 2 input Tensors, got ${t.length}.`);let n=t[1];t=t[0];let o=e.training==null?!1:e.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=hl({ones:()=>dr(t),rate:this.dropout,training:o,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=hl({ones:()=>dr(n),rate:this.recurrentDropout,training:o,dropoutFunc:this.dropoutFunc}));let s,i=this.dropoutMask,a=this.recurrentDropoutMask;i!=null?s=Eo(M(t,i),this.kernel.read()):s=Eo(t,this.kernel.read()),this.bias!=null&&(s=xn(s,this.bias.read())),a!=null&&(n=M(n,a));let u=J(s,Eo(n,this.recurrentKernel.read()));return this.activation!=null&&(u=this.activation.apply(u)),[u,u]})}getConfig(){let t=super.getConfig(),e={units:this.units,activation:li(this.activation),useBias:this.useBias,kernelInitializer:Ee(this.kernelInitializer),recurrentInitializer:Ee(this.recurrentInitializer),biasInitializer:Ee(this.biasInitializer),kernelRegularizer:me(this.kernelRegularizer),recurrentRegularizer:me(this.recurrentRegularizer),biasRegularizer:me(this.biasRegularizer),activityRegularizer:me(this.activityRegularizer),kernelConstraint:We(this.kernelConstraint),recurrentConstraint:We(this.recurrentConstraint),biasConstraint:We(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign({},t,e)}};Oc.className="SimpleRNNCell";et.registerClass(Oc);var sf=class extends $n{constructor(t){t.cell=new Oc(t),super(t)}call(t,e){return B(()=>{this.cell.dropoutMask!=null&&(_t(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(_t(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=e==null?null:e.mask,o=e==null?null:e.training,s=e==null?null:e.initialState;return super.call(t,{mask:n,training:o,initialState:s})})}static fromConfig(t,e){return new t(e)}};sf.className="SimpleRNN";et.registerClass(sf);var Mc=class extends fl{constructor(t){if(super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",t.resetAfter)throw new z("GRUCell does not support reset_after parameter set to true.");this.units=t.units,er(this.units,"units"),this.activation=ui(t.activation===void 0?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=ui(t.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=t.useBias==null?!0:t.useBias,this.kernelInitializer=de(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=de(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=de(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Ce(t.kernelRegularizer),this.recurrentRegularizer=Ce(t.recurrentRegularizer),this.biasRegularizer=Ce(t.biasRegularizer),this.kernelConstraint=Ue(t.kernelConstraint),this.recurrentConstraint=Ue(t.recurrentConstraint),this.biasConstraint=Ue(t.biasConstraint),this.dropout=Cc([1,ii([0,t.dropout==null?0:t.dropout])]),this.recurrentDropout=Cc([1,ii([0,t.recurrentDropout==null?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.implementation=t.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=Jt(t);let e=t[t.length-1];this.kernel=this.addWeight("kernel",[e,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return B(()=>{if(t=t,t.length!==2)throw new z(`GRUCell expects 2 input Tensors (inputs, h, c), got ${t.length}.`);let n=e.training==null?!1:e.training,o=t[1];t=t[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=hl({ones:()=>dr(t),rate:this.dropout,training:n,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=hl({ones:()=>dr(o),rate:this.recurrentDropout,training:n,count:3,dropoutFunc:this.dropoutFunc}));let s=this.dropoutMask,i=this.recurrentDropoutMask,a,u,l;0<this.dropout&&this.dropout<1&&(t=M(t,s[0]));let c=Eo(t,this.kernel.read());this.useBias&&(c=xn(c,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(o=M(o,i[0]));let p=this.recurrentKernel.read(),[m,f]=ur(p,[2*this.units,this.units],p.rank-1),d=Eo(o,m),[h,g,y]=ur(c,3,c.rank-1),[b,w]=ur(d,2,d.rank-1);a=this.recurrentActivation.apply(J(h,b)),u=this.recurrentActivation.apply(J(g,w));let v=Eo(M(u,o),f);l=this.activation.apply(J(y,v));let k=J(M(a,o),M(J(1,Zt(a)),l));return[k,k]})}getConfig(){let t=super.getConfig(),e={units:this.units,activation:li(this.activation),recurrentActivation:li(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Ee(this.kernelInitializer),recurrentInitializer:Ee(this.recurrentInitializer),biasInitializer:Ee(this.biasInitializer),kernelRegularizer:me(this.kernelRegularizer),recurrentRegularizer:me(this.recurrentRegularizer),biasRegularizer:me(this.biasRegularizer),activityRegularizer:me(this.activityRegularizer),kernelConstraint:We(this.kernelConstraint),recurrentConstraint:We(this.recurrentConstraint),biasConstraint:We(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign({},t,e)}};Mc.className="GRUCell";et.registerClass(Mc);var af=class extends $n{constructor(t){t.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new Mc(t),super(t)}call(t,e){return B(()=>{this.cell.dropoutMask!=null&&(_t(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(_t(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=e==null?null:e.mask,o=e==null?null:e.training,s=e==null?null:e.initialState;return super.call(t,{mask:n,training:o,initialState:s})})}static fromConfig(t,e){return e.implmentation===0&&(e.implementation=1),new t(e)}};af.className="GRU";et.registerClass(af);var dl=class extends fl{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,er(this.units,"units"),this.activation=ui(t.activation===void 0?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=ui(t.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=t.useBias==null?!0:t.useBias,this.kernelInitializer=de(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=de(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=de(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=t.unitForgetBias,this.kernelRegularizer=Ce(t.kernelRegularizer),this.recurrentRegularizer=Ce(t.recurrentRegularizer),this.biasRegularizer=Ce(t.biasRegularizer),this.kernelConstraint=Ue(t.kernelConstraint),this.recurrentConstraint=Ue(t.recurrentConstraint),this.biasConstraint=Ue(t.biasConstraint),this.dropout=Cc([1,ii([0,t.dropout==null?0:t.dropout])]),this.recurrentDropout=Cc([1,ii([0,t.recurrentDropout==null?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.implementation=t.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){var e;t=Jt(t);let n=t[t.length-1];this.kernel=this.addWeight("kernel",[n,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let o;if(this.useBias){if(this.unitForgetBias){let s=this.biasInitializer,i=this.units;o=new(e=class extends bn{apply(u,l){let c=s.apply([i]),p=new iu().apply([i]),m=s.apply([i*2]);return kS(kS(c,p),m)}},e.className="CustomInit",e)}else o=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,o,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(t,e){return B(()=>{let n=e.training==null?!1:e.training;if(t=t,t.length!==3)throw new z(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);let o=t[1],s=t[2];t=t[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=hl({ones:()=>dr(t),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=hl({ones:()=>dr(o),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));let i=this.dropoutMask,a=this.recurrentDropoutMask,u,l,c,p;0<this.dropout&&this.dropout<1&&(t=M(t,i[0]));let m=Eo(t,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(o=M(o,a[0])),m=J(m,Eo(o,this.recurrentKernel.read())),this.useBias&&(m=xn(m,this.bias.read()));let[f,d,h,g]=ur(m,4,m.rank-1);u=this.recurrentActivation.apply(f),l=this.recurrentActivation.apply(d),c=J(M(l,s),M(u,this.activation.apply(h))),p=this.recurrentActivation.apply(g);let y=M(p,this.activation.apply(c));return[y,y,c]})}getConfig(){let t=super.getConfig(),e={units:this.units,activation:li(this.activation),recurrentActivation:li(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Ee(this.kernelInitializer),recurrentInitializer:Ee(this.recurrentInitializer),biasInitializer:Ee(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:me(this.kernelRegularizer),recurrentRegularizer:me(this.recurrentRegularizer),biasRegularizer:me(this.biasRegularizer),activityRegularizer:me(this.activityRegularizer),kernelConstraint:We(this.kernelConstraint),recurrentConstraint:We(this.recurrentConstraint),biasConstraint:We(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign({},t,e)}};dl.className="LSTMCell";et.registerClass(dl);var lf=class extends $n{constructor(t){t.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new dl(t),super(t)}call(t,e){return B(()=>{this.cell.dropoutMask!=null&&(_t(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(_t(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=e==null?null:e.mask,o=e==null?null:e.training,s=e==null?null:e.initialState;return super.call(t,{mask:n,training:o,initialState:s})})}static fromConfig(t,e){return e.implmentation===0&&(e.implementation=1),new t(e)}};lf.className="LSTM";et.registerClass(lf);var Pc=class extends fl{constructor(t){super(t),this.cells=t.cells}get stateSize(){let t=[];for(let e of this.cells.slice().reverse())Array.isArray(e.stateSize)?t.push(...e.stateSize):t.push(e.stateSize);return t}call(t,e){return B(()=>{t=t;let n=t.slice(1),o=[];for(let a of this.cells.slice().reverse())Array.isArray(a.stateSize)?o.push(n.splice(0,a.stateSize.length)):o.push(n.splice(0,1));o.reverse();let s=[],i;for(let a=0;a<this.cells.length;++a){let u=this.cells[a];n=o[a],a===0?i=[t[0]].concat(n):i=[i[0]].concat(n),i=u.call(i,e),s.push(i.slice(1))}n=[];for(let a of s.slice().reverse())n.push(...a);return[i[0]].concat(n)})}build(t){hy(t)&&(t=t[0]),t=t;let e;this.cells.forEach((n,o)=>{si(`RNNCell_${o}`,()=>{n.build(t),Array.isArray(n.stateSize)?e=n.stateSize[0]:e=n.stateSize,t=[t[0],e]})}),this.built=!0}getConfig(){let t=super.getConfig(),e=s=>({className:s.getClassName(),config:s.getConfig()}),o={cells:this.cells.map(e)};return Object.assign({},t,o)}static fromConfig(t,e,n={}){let o=[];for(let s of e.cells)o.push(vn(s,n));return new t({cells:o})}get trainableWeights(){if(!this.trainable)return[];let t=[];for(let e of this.cells)t.push(...e.trainableWeights);return t}get nonTrainableWeights(){let t=[];for(let e of this.cells)t.push(...e.nonTrainableWeights);if(!this.trainable){let e=[];for(let n of this.cells)e.push(...n.trainableWeights);return e.concat(t)}return t}getWeights(){let t=[];for(let e of this.cells)t.push(...e.weights);return qh(t)}setWeights(t){let e=[];for(let n of this.cells){let o=n.weights.length,s=t.splice(o);for(let i=0;i<n.weights.length;++i)e.push([n.weights[i],s[i]])}Bm(e)}};Pc.className="StackedRNNCells";et.registerClass(Pc);function hl(r){let{ones:t,rate:e,training:n=!1,count:o=1,dropoutFunc:s}=r,i=()=>s!=null?s(t(),e):my(t(),e),a=()=>su(i,t,n);return!o||o<=1?Pe(a().clone()):Array(o).fill(void 0).map(a).map(l=>Pe(l.clone()))}var N8=function(r,t){var e={};for(var n in r)Object.prototype.hasOwnProperty.call(r,n)&&t.indexOf(n)<0&&(e[n]=r[n]);if(r!=null&&typeof Object.getOwnPropertySymbols=="function")for(var o=0,n=Object.getOwnPropertySymbols(r);o<n.length;o++)t.indexOf(n[o])<0&&Object.prototype.propertyIsEnumerable.call(r,n[o])&&(e[n[o]]=r[n[o]]);return e};var Yy=class extends $n{constructor(t){if(t.unroll)throw new Nt("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(t.cell))throw new Nt("It is not possible at the moment to stack convolutional cells.");super(t),this.inputSpec=[new ve({ndim:5})]}call(t,e){return B(()=>{if(this.cell.dropoutMask!=null&&(_t(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(_t(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),e&&e.constants)throw new z("ConvRNN2D cell does not support constants");let n=e==null?null:e.mask,o=e==null?null:e.training,s=e==null?null:e.initialState;return super.call(t,{mask:n,training:o,initialState:s})})}computeOutputShape(t){let e=this.computeSingleOutputShape(t);return this.returnSequences||(e=[e[0],...e.slice(2)]),this.returnState&&(e=[e,...Array(2).fill([t[0],...e.slice(-3)])]),e}getInitialState(t){return B(()=>{let{stateSize:e}=this.cell,n=t.shape,o=this.computeSingleOutputShape(n),s=[o[0],...o.slice(2)],i=ye(s);return Array.isArray(e)?Array(e.length).fill(i):[i]})}resetStates(t,e=!1){B(()=>{if(!this.stateful)throw new En("Cannot call resetStates() on an RNN Layer that is not stateful.");let n=this.inputSpec[0].shape,o=this.computeSingleOutputShape(n),s=[o[0],...o.slice(2)];if(n[0]==null)throw new z("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>ye(s)):this.states_=[ye(s)];else if(t==null)_t(this.states_),this.keptStates!=null&&(_t(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>ye(s)):this.states_[0]=ye(s);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new z(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);e?this.keptStates.push(this.states_.slice()):_t(this.states_);for(let a=0;a<this.states_.length;++a){let u=t[a],l=s;if(!x.arraysEqual(u.shape,l))throw new z(`State ${a} is incompatible with layer ${this.name}: expected shape=${l}, received shape=${u.shape}`);this.states_[a]=u}}this.states_=this.states_.map(a=>Pe(a.clone()))})}computeSingleOutputShape(t){let{dataFormat:e,filters:n,kernelSize:o,padding:s,strides:i,dilationRate:a}=this.cell,u=e==="channelsFirst",l=t[u?3:2],c=t[u?4:3],p=An(l,o[0],s,i[0],a[0]),m=An(c,o[1],s,i[1],a[1]);return[...t.slice(0,2),...u?[n,p,m]:[p,m,n]]}};Yy.className="ConvRNN2D";var Lc=class extends dl{constructor(t){let{filters:e,kernelSize:n,strides:o,padding:s,dataFormat:i,dilationRate:a}=t;super(Object.assign({},t,{units:e})),this.filters=e,er(this.filters,"filters"),this.kernelSize=cu(n,2,"kernelSize"),this.kernelSize.forEach(u=>er(u,"kernelSize")),this.strides=cu(o||1,2,"strides"),this.strides.forEach(u=>er(u,"strides")),this.padding=s||"valid",gn(this.padding),this.dataFormat=i||"channelsLast",Le(this.dataFormat),this.dilationRate=cu(a||1,2,"dilationRate"),this.dilationRate.forEach(u=>er(u,"dilationRate"))}build(t){var e;t=Jt(t);let n=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[n]==null)throw new z(`The channel dimension of the input should be defined. Found ${t[n]}`);let o=t[n],s=4,i=this.kernelSize.concat([o,this.filters*s]);this.kernel=this.addWeight("kernel",i,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);let a=this.kernelSize.concat([this.filters,this.filters*s]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",a,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let u;if(this.unitForgetBias){let l=this.biasInitializer,c=this.filters;u=new(e=class extends bn{apply(m,f){let d=l.apply([c]),h=lr([c]),g=l.apply([c*2]);return Em([d,h,g])}},e.className="CustomInit",e)}else u=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*s],null,u,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(t,e){return B(()=>{if(t.length!==3)throw new z(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);let n=e.training||!1,o=t[0],s=t[1],i=t[2],a=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=hl({ones:()=>dr(o),rate:this.dropout,training:n,count:a,dropoutFunc:this.dropoutFunc}));let u=this.dropoutMask,l=(st,it,ft)=>!it||!it[ft]?st:M(it[ft],st),c=l(o,u,0),p=l(o,u,1),m=l(o,u,2),f=l(o,u,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=hl({ones:()=>dr(s),rate:this.recurrentDropout,training:n,count:a,dropoutFunc:this.dropoutFunc}));let d=this.recurrentDropoutMask,h=l(s,d,0),g=l(s,d,1),y=l(s,d,2),b=l(s,d,3),w=3,[v,k,E,$]=ur(this.kernel.read(),a,w),[D,R,P,W]=this.useBias?ur(this.bias.read(),a):[null,null,null,null];c=this.inputConv(c,v,D,this.padding),p=this.inputConv(p,k,R,this.padding),m=this.inputConv(m,E,P,this.padding),f=this.inputConv(f,$,W,this.padding);let[U,q,K,j]=ur(this.recurrentKernel.read(),a,w);h=this.recurrentConv(h,U),g=this.recurrentConv(g,q),y=this.recurrentConv(y,K),b=this.recurrentConv(b,j);let Q=this.recurrentActivation.apply(J(c,h)),rt=this.recurrentActivation.apply(J(p,g)),X=J(M(rt,i),M(Q,this.activation.apply(J(m,y)))),ot=M(this.recurrentActivation.apply(J(f,b)),this.activation.apply(X));return[ot,ot,X]})}getConfig(){let t=super.getConfig(),{units:e}=t,n=N8(t,["units"]),o={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign({},n,o)}inputConv(t,e,n,o){let s=pn(t,e,this.strides,o||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return n?xn(s,n,this.dataFormat):s}recurrentConv(t,e){return pn(t,e,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}};Lc.className="ConvLSTM2DCell";et.registerClass(Lc);var uf=class extends Yy{constructor(t){let e=new Lc(t);super(Object.assign({},t,{cell:e}))}static fromConfig(t,e){return new t(e)}};uf.className="ConvLSTM2D";et.registerClass(uf);var zc=class extends Bt{constructor(t){super(t),this.rate=Math.max(Math.min(t.rate,1),0),this.noiseShape=t.noiseShape,this.seed=t.seed,this.supportsMasking=!0}getNoiseShape(t){if(this.noiseShape==null)return this.noiseShape;let e=t.shape,n=[];for(let o=0;o<this.noiseShape.length;++o)n.push(this.noiseShape[o]==null?e[o]:this.noiseShape[o]);return n}call(t,e){return B(()=>{this.invokeCallHook(t,e);let n=Mt(t);if(0<this.rate&&this.rate<1){let o=e.training==null?!1:e.training,s=this.getNoiseShape(n);return su(()=>my(n,this.rate,s,this.seed),()=>n,o)}return t})}getConfig(){let t={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},e=super.getConfig();return Object.assign(t,e),t}dispose(){return super.dispose()}};zc.className="Dropout";et.registerClass(zc);var cf=class extends zc{constructor(t){super(t),this.inputSpec=[{ndim:3}]}getNoiseShape(t){let e=t.shape;return[e[0],1,e[2]]}};cf.className="SpatialDropout1D";et.registerClass(cf);var pf=class extends Bt{constructor(t){if(super(t),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",t.batchInputShape==null&&t.inputShape==null&&t.inputDim!=null){let e=null;t.batchSize!=null&&(e=t.batchSize),this.batchInputShape=[e,t.inputDim]}this.units=t.units,er(this.units,"units"),this.activation=ui(t.activation),t.useBias!=null&&(this.useBias=t.useBias),this.kernelInitializer=de(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=de(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=Ue(t.kernelConstraint),this.biasConstraint=Ue(t.biasConstraint),this.kernelRegularizer=Ce(t.kernelRegularizer),this.biasRegularizer=Ce(t.biasRegularizer),this.activityRegularizer=Ce(t.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(t){t=Jt(t);let e=t[t.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[e,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:e}}],this.built=!0}computeOutputShape(t){t=Jt(t);let e=t.slice();return e[e.length-1]=this.units,e}call(t,e){return B(()=>{this.invokeCallHook(t,e);let n=Mt(t),o=iy(this.activation.getClassName()),s;return o!=null?s=Eo(n,this.kernel.read(),o,this.bias?this.bias.read():null):(s=Eo(n,this.kernel.read()),this.bias!=null&&(s=xn(s,this.bias.read())),this.activation!=null&&(s=this.activation.apply(s))),s})}getConfig(){let t={units:this.units,activation:li(this.activation),useBias:this.useBias,kernelInitializer:Ee(this.kernelInitializer),biasInitializer:Ee(this.biasInitializer),kernelRegularizer:me(this.kernelRegularizer),biasRegularizer:me(this.biasRegularizer),activityRegularizer:me(this.activityRegularizer),kernelConstraint:We(this.kernelConstraint),biasConstraint:We(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}};pf.className="Dense";et.registerClass(pf);var mf=class extends Bt{constructor(t){t=t||{},super(t),this.inputSpec=[{minNDim:3}],this.dataFormat=t.dataFormat}computeOutputShape(t){t=Jt(t);for(let e of t.slice(1))if(e==null)throw new z(`The shape of the input to "Flatten" is not fully defined (got ${t.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[t[0],_o(t,1)]}call(t,e){return B(()=>{this.invokeCallHook(t,e);let n=Mt(t);if(this.dataFormat==="channelsFirst"&&n.rank>1){let o=[0];for(let s=2;s<n.rank;++s)o.push(s);o.push(1),n=Wt(n,o)}return d$(n)})}getConfig(){let t={};this.dataFormat!=null&&(t.dataFormat=this.dataFormat);let e=super.getConfig();return Object.assign(t,e),t}};mf.className="Flatten";et.registerClass(mf);var ff=class extends Bt{constructor(t){super(t),this.supportsMasking=!0,this.activation=ui(t.activation)}call(t,e){return B(()=>{this.invokeCallHook(t,e);let n=Mt(t);return this.activation.apply(n)})}getConfig(){let t={activation:li(this.activation)},e=super.getConfig();return Object.assign(t,e),t}};ff.className="Activation";et.registerClass(ff);var df=class extends Bt{constructor(t){super(t),this.n=t.n,this.inputSpec=[{ndim:2}]}computeOutputShape(t){return[t[0],this.n,t[1]]}call(t,e){return B(()=>(t=Mt(t),m$(t,this.n)))}getConfig(){let t={n:this.n},e=super.getConfig();return Object.assign(t,e),t}};df.className="RepeatVector";et.registerClass(df);var hf=class extends Bt{constructor(t){super(t),this.targetShape=t.targetShape;for(let e=0;e<this.targetShape.length;++e)this.isUnknown(this.targetShape[e])&&(this.targetShape[e]=null)}isUnknown(t){return t<0||t==null}fixUnknownDimension(t,e){let n="Total size of new array must be unchanged.",o=e.slice(),s=1,i=null;for(let u=0;u<o.length;++u){let l=o[u];if(this.isUnknown(l))if(i===null)i=u;else throw new z("Can only specifiy one unknown dimension.");else s*=l}let a=_o(t);if(i!==null){if(s===0||a%s!==0)throw new z(n);o[i]=a/s}else if(a!==s)throw new z(n);return o}computeOutputShape(t){let e=!1;for(let n=0;n<t.length;++n)if(this.isUnknown(t[n])){e=!0;break}return e?t.slice(0,1).concat(this.targetShape):t.slice(0,1).concat(this.fixUnknownDimension(t.slice(1),this.targetShape))}call(t,e){return B(()=>{this.invokeCallHook(t,e);let n=Mt(t),o=n.shape,s=o.slice(0,1).concat(this.fixUnknownDimension(o.slice(1),this.targetShape));return O(n,s)})}getConfig(){let t={targetShape:this.targetShape},e=super.getConfig();return Object.assign(t,e),t}};hf.className="Reshape";et.registerClass(hf);var gf=class extends Bt{constructor(t){if(super(t),t.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(t.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${t.dims} instead.`);let e=Jr(1,t.dims.length+1);if(!x.arraysEqual(t.dims.slice().sort(),e))throw new Error("Invalid permutation `dims`: "+JSON.stringify(t.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=t.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new ve({ndim:this.dims.length+1})]}computeOutputShape(t){t=Jt(t);let e=t.slice();return this.dims.forEach((n,o)=>{e[o+1]=t[n]}),e}call(t,e){return Wt(Mt(t),this.dimsIncludingBatch)}getConfig(){let t={dims:this.dims},e=super.getConfig();return Object.assign(t,e),t}};gf.className="Permute";et.registerClass(gf);var xf=class extends Bt{constructor(t){super(t==null?{}:t),this.supportsMasking=!0,t!=null?this.maskValue=t.maskValue==null?0:t.maskValue:this.maskValue=0}computeOutputShape(t){return t}getConfig(){let t=super.getConfig(),e={maskValue:this.maskValue};return Object.assign(e,t),e}computeMask(t,e){let n=Mt(t),o=-1;return Yl(vo(n,this.maskValue),o)}call(t,e){return B(()=>{this.invokeCallHook(t,e);let n=Mt(t),o=-1,s=!0,i=Yl(vo(n,this.maskValue),o,s);return M(n,Z(i,n.dtype))})}};xf.className="Masking";et.registerClass(xf);var yf=class extends Bt{constructor(t){if(super(t),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",t.batchInputShape==null&&t.inputShape==null){let e=null;t.batchSize!=null&&(e=t.batchSize),t.inputLength==null?this.batchInputShape=[e,null]:this.batchInputShape=[e].concat(we(t.inputLength))}this.inputDim=t.inputDim,er(this.inputDim,"inputDim"),this.outputDim=t.outputDim,er(this.outputDim,"outputDim"),this.embeddingsInitializer=de(t.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=Ce(t.embeddingsRegularizer),this.activityRegularizer=Ce(t.activityRegularizer),this.embeddingsConstraint=Ue(t.embeddingsConstraint),this.maskZero=t.maskZero,this.supportsMasking=t.maskZero,this.inputLength=t.inputLength}build(t){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(t){}computeMask(t,e){return B(()=>this.maskZero?(t=Mt(t),vo(t,St(t))):null)}computeOutputShape(t){if(t=Jt(t),this.inputLength==null)return[...t,this.outputDim];let e=we(this.inputLength);if(e.length!==t.length-1)throw new z(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);{let n=0;for(let o=0;o<e.length;++o){let s=e[o],i=t[o+1];if(s!=null&&i!=null&&s!==i)throw new z(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);s==null&&(e[n]=i),n++}}return[t[0],...e,this.outputDim]}call(t,e){return B(()=>{this.invokeCallHook(t,e);let n=Mt(t);n.dtype!=="int32"&&(n=Ic(n,"int32"));let o=py(this.embeddings.read(),O(n,[n.size]));return O(o,Jt(this.computeOutputShape(n.shape)))})}getConfig(){let t={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:Ee(this.embeddingsInitializer),embeddingsRegularizer:me(this.embeddingsRegularizer),activityRegularizer:me(this.activityRegularizer),embeddingsConstraint:We(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},e=super.getConfig();return Object.assign(t,e),t}};yf.className="Embedding";et.registerClass(yf);var gl=class extends Bt{constructor(t){super(t||{}),this.supportsMasking=!0}mergeFunction(t){throw new Nt}computeElementwiseOpOutputShape(t,e){if(t==null||e==null)return null;if(t.length<e.length)return this.computeElementwiseOpOutputShape(e,t);if(e.length===0)return t;let n=t.slice(0,t.length-e.length);for(let o=0;o<e.length;++o){let s=t[t.length-e.length+o],i=e[o];if(s==null||i==null||s<0||i<0)n.push(null);else if(s===1)n.push(i);else if(i===1)n.push(s);else{if(s!==i)throw new z("Operands could not be broadcast together with shapes "+JSON.stringify(t)+" "+JSON.stringify(e));n.push(s)}}return n}build(t){if(Array.isArray(t)&&!Array.isArray(t[0])&&(t=[Jt(t)]),t=t,t.length<2)throw new z(`A merge layer should be called on an Array of at least 2 inputs. Got ${t.length} input(s).`);let e=[];for(let s of t)s!=null&&s[0]!==null&&e.push(s[0]);if(e=To(e),e.length>1)throw new z(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(t)}.`);let n=t[0]==null?null:t[0].slice(1);for(let s=1;s<t.length;++s){let i=t[s]==null?null:t[s].slice(1);n=this.computeElementwiseOpOutputShape(n,i)}let o=t.map(s=>s.length);t.indexOf(null)===-1&&To(o).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(t,e){return B(()=>{if(t=t,this.reshapeRequired){let n=[],o=t.map(s=>s.rank);if(o.indexOf(null)===-1){let s=ii(o);for(let i of t){let a=i.rank;for(let u=0;u<s-a;++u)i=ll(i,1);n.push(i)}return this.mergeFunction(n)}else{let s=!1;for(let u of t){let l=u.rank;if(l==null){let c=u.shape,p=c[0],m=c.slice(1).concat([p]),f=O(u,[p].concat(_o(c.slice(1))));f=Wt(f,[1,0]),f=O(f,m),n.push(f),s=!0}else if(l>1){let c=Jr(1,l).concat([0]);n.push(Wt(u,c)),s=!0}else n.push(u)}let i=this.mergeFunction(n),a=i.rank;if(s){if(a==null){let u=i.shape,l=u.length,c=u[l-1],p=[c].concat(u.slice(0,u.length-1));i=O(Wt(O(i,[-1,c]),[1,0]),p)}else if(a>1){let u=[a-1].concat(Jr(0,a-1));i=Wt(i,u)}}return i}}else return this.mergeFunction(t)})}computeOutputShape(t){t=t;let e;t[0]==null?e=null:e=t[0].slice(1);for(let o=1;o<t.length;++o){let s=t[o]==null?null:t[o].slice(1);e=this.computeElementwiseOpOutputShape(e,s)}let n=[];for(let o of t)o!=null&&o[0]!==null&&n.push(o[0]);return n=To(n),n.length===1?e=n.concat(e):e=[null].concat(e),e}computeMask(t,e){return B(()=>{if(e==null)return null;if(!Array.isArray(e))throw new z("`mask` should be an Array");if(!Array.isArray(t))throw new z("`inputs` should be an Array");if(e.length!==t.length)throw new z(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${t.length} vs ${e.length})`);if(e.every(o=>o==null))return null;e=e.map(o=>o==null?o:fr(o,0));let n=e[0];for(let o=1;o<e.length-1;++o)n=Nr(n,e[o]);return n})}},bf=class extends gl{constructor(t){super(t)}mergeFunction(t){return B(()=>{let e=t[0].clone();for(let n=1;n<t.length;++n)e=J(e,t[n]);return e})}};bf.className="Add";et.registerClass(bf);var wf=class extends gl{constructor(t){super(t)}mergeFunction(t){return B(()=>{let e=t[0].clone();for(let n=1;n<t.length;++n)e=M(e,t[n]);return e})}};wf.className="Multiply";et.registerClass(wf);var vf=class extends gl{constructor(t){super(t)}mergeFunction(t){return B(()=>{let e=t[0].clone();for(let n=1;n<t.length;++n)e=J(e,t[n]);return M(1/t.length,e)})}};vf.className="Average";et.registerClass(vf);var Cf=class extends gl{constructor(t){super(t)}mergeFunction(t){return B(()=>{let e=t[0];for(let n=1;n<t.length;++n)e=fn(e,t[n]);return e})}};Cf.className="Maximum";et.registerClass(Cf);var If=class extends gl{constructor(t){super(t)}mergeFunction(t){return B(()=>{let e=t[0];for(let n=1;n<t.length;++n)e=ti(e,t[n]);return e})}};If.className="Minimum";et.registerClass(If);var Sf=class extends gl{constructor(t){super(t),this.DEFAULT_AXIS=-1,t==null&&(t={}),this.axis=t.axis==null?this.DEFAULT_AXIS:t.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){if(!(Array.isArray(t)&&Array.isArray(t[0]))||t.length===1)throw new z("A `Concatenate` layer should be called on a list of at least 2 inputs");t=t;let e=!0;for(let o of t)if(o!=null){e=!1;break}if(e)return;let n=[];for(let o=0;o<t.length;++o){let s=t[o].slice();s.splice(this.axis,1);let i=!1;for(let a of n)if(x.arraysEqual(a,s)){i=!0;break}i||n.push(s)}if(n.length>1)throw new z("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(t))}mergeFunction(t){return B(()=>Em(t,this.axis))}computeOutputShape(t){if(!(Array.isArray(t)&&Array.isArray(t[0])))throw new z("A `Concatenate` layer should be called on a list of inputs.");let e=t,n=e[0].slice(),o=this.axis<0?n.length+this.axis:this.axis;for(let s of e.slice(1)){if(n[o]==null||s[o]==null){n[o]=null;break}n[o]+=s[o]}return n}computeMask(t,e){if(e==null)return null;if(!Array.isArray(e))throw new z("`mask` should be an array for Concatenate");if(!Array.isArray(t))throw new z("`inputs` should be an array for Concatenate");if(e.length!==t.length)throw new z(`Mismatch in the length of mask (${e.length}) and the legnth of inputs (${t.length})`);return B(()=>{let n=!0;if(e.forEach(i=>{if(i!=null){n=!1;return}}),n)return null;let o=[];for(let i=0;i<t.length;++i)e[i]==null?o.push(Z(dr(t[i]),"bool")):e[i].rank<t[i].rank?o.push(fr(e[i],-1)):o.push(e[i]);let s=se(o,this.axis);return Ku(s,-1,!1)})}getConfig(){let t={axis:this.axis},e=super.getConfig();return Object.assign(t,e),t}};Sf.className="Concatenate";et.registerClass(Sf);function eg(r,t){for(;r<0;)r+=t;return r}function T8(r,t,e){if(r.shape.length>3||t.shape.length>3)throw new Nt("batchDot is not implemented for tensors of 4D or higher rank yet");if(x.assert(r.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${r.shape.length}`),x.assert(r.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`),typeof e=="number"&&(e=[e,e]),r.dtype==="complex64"||t.dtype==="complex64")throw new Nt("batchDot is not implemented for complex64-type Tensors yet.");let n=r.shape.length,o=t.shape.length;e==null&&(e=[n-1,o-2]);let s=e;return B(()=>{let i;if(n>o){i=n-o;let u=[];for(let l=0;l<i;++l)u.push(1);t=O(t,t.shape.concat(u))}else if(o>n){i=o-n;let u=[];for(let l=0;l<i;++l)u.push(1);r=O(r,r.shape.concat(u))}else i=0;let a;if(r.shape.length===2&&t.shape.length===2)s[0]===s[1]?a=mt(M(r,t),s[0]):a=mt(M(Wt(r,[1,0]),t),s[1]);else{let u=s[0]!==r.shape.length-1,l=s[1]===t.shape.length-1;a=Lt(r,t,u,l)}if(i>0){let u;n>o?u=n+o-3:u=n-1;let l=[];for(let c=u;c<u+i;++c)l.push(c);a=zr(a,l)}return a.shape.length===1&&(a=fr(a,1)),a})}var kf=class extends gl{constructor(t){super(t),this.axes=t.axes,this.normalize=t.normalize==null?!1:t.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){x.assert(Array.isArray(t)&&t.length===2&&Array.isArray(t[0])&&Array.isArray(t[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let e=t[0],n=t[1];if(e.length>3||n.length>3)throw new Nt("Dot layer does not support tensors of 4D or higher rank yet.");let o=this.interpretAxes(e,n);if(e[o[0]]!==n[o[1]])throw new z(`Dimension incompatibility: ${e[o[0]]} !== ${n[o[1]]}`)}mergeFunction(t){if(t.length!==2)throw new z(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${t.length} input(s).`);let e=t[0],n=t[1],o;return Array.isArray(this.axes)?o=this.axes.map((s,i)=>eg(s,t[i].shape.length)):o=[eg(this.axes,e.shape.length),eg(this.axes,n.shape.length)],this.normalize&&(e=Kh(e,o[0]),n=Kh(n,o[1])),T8(e,n,o)}interpretAxes(t,e){let n;return Array.isArray(this.axes)?n=this.axes:n=[eg(this.axes,t.length),eg(this.axes,e.length)],n}computeOutputShape(t){x.assert(Array.isArray(t)&&t.length===2&&Array.isArray(t[0])&&Array.isArray(t[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let e=t[0].slice(),n=t[1].slice();if(e.length>3||n.length>3)throw new Nt("Dot layer does not support tensors of 4D or higher rank yet.");let o=this.interpretAxes(e,n);e.splice(o[0],1),n.splice(o[1],1),n.splice(0,1);let s=e.concat(n);return s.length===1&&s.push(1),s}computeMask(t,e){return null}getConfig(){let t={axes:this.axes,normalize:this.normalize},e=super.getConfig();return Object.assign(t,e),t}};kf.className="Dot";et.registerClass(kf);var Nf=class extends Bt{constructor(t){super(t),this.supportsMasking=!0,this.stddev=t.stddev}computeOutputShape(t){return t}getConfig(){let t=super.getConfig(),e={stddev:this.stddev};return Object.assign(e,t),e}call(t,e){return B(()=>{this.invokeCallHook(t,e);let n=Mt(t);return su(()=>J(Am(n.shape,0,this.stddev),n),()=>n,e.training||!1)})}};Nf.className="GaussianNoise";et.registerClass(Nf);var Tf=class extends Bt{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate}computeOutputShape(t){return t}getConfig(){let t=super.getConfig(),e={rate:this.rate};return Object.assign(e,t),e}call(t,e){return B(()=>{this.invokeCallHook(t,e);let n=Mt(t);return this.rate>0&&this.rate<1?su(()=>{let s=Math.sqrt(this.rate/(1-this.rate));return M(n,Am(n.shape,1,s))},()=>n,e.training||!1):n})}};Tf.className="GaussianDropout";et.registerClass(Tf);var _f=class extends Bt{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate,this.noiseShape=t.noiseShape}_getNoiseShape(t){return this.noiseShape||Mt(t).shape}computeOutputShape(t){return t}getConfig(){let t=super.getConfig(),e={rate:this.rate};return Object.assign(e,t),e}call(t,e){return B(()=>{if(this.rate<1&&this.rate>0){let n=this._getNoiseShape(t);return su(()=>{let s=Mt(t),i=1.6732632423543772,a=1.0507009873554805,u=-i*a,l=Tn(ei(n),this.rate);l=Ic(l,"float32");let c=((1-this.rate)*(1+this.rate*u**2))**-.5,p=-c*u*this.rate,m=J(M(s,l),M(J(l,-1),u));return J(M(m,c),p)},()=>Mt(t),e.training||!1)}return t})}};_f.className="AlphaDropout";et.registerClass(_f);function rg(r,t,e,n,o,s=.001){let i;if(r.rank===2)i=EI(r,t,e,n,o,s);else if(r.rank===3)i=AI(r,t,e,n,o,s);else if(r.rank===4)i=$I(r,t,e,n,o,s);else throw new Nt(`batchNormalization is not implemented for array of rank ${r.rank} yet`);return i}function _8(r,t,e,n,o=.001){return B(()=>{let s=xm(r,n),i=s.mean,a=s.variance;return[rg(r,i,a,e,t,o),i,a]})}function E8(r,t,e,n,o=.001){return B(()=>{let s=xm(r,n),i=s.mean,a=s.variance,u=[];for(let d of Jr(0,r.rank))n.indexOf(d)!==-1?u.push(1):u.push(r.shape[d]);let l=O(i,u),c=O(a,u),p=t==null?null:O(t,u),m=e==null?null:O(e,u);return[rg(r,l,c,m,p,o),i,a]})}function A8(r,t,e,n,o=.001){return x.arraysEqual(n.slice().sort(),Jr(0,r.rank-1))?_8(r,t,e,n,o):E8(r,t,e,n,o)}var Ef=class extends Bt{constructor(t){t==null&&(t={}),super(t),this.supportsMasking=!0,this.axis=t.axis==null?-1:t.axis,this.momentum=t.momentum==null?.99:t.momentum,this.epsilon=t.epsilon==null?.001:t.epsilon,this.center=t.center==null?!0:t.center,this.scale=t.scale==null?!0:t.scale,this.betaInitializer=de(t.betaInitializer||"zeros"),this.gammaInitializer=de(t.gammaInitializer||"ones"),this.movingMeanInitializer=de(t.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=de(t.movingVarianceInitializer||"ones"),this.betaConstraint=Ue(t.betaConstraint),this.gammaConstraint=Ue(t.gammaConstraint),this.betaRegularizer=Ce(t.betaRegularizer),this.gammaRegularizer=Ce(t.gammaRegularizer)}build(t){t=Jt(t);let e=this.axis>=0?this.axis:this.axis+t.length,n=t[e];if(n==null)throw new z(`Axis ${e} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(t)}.`);this.inputSpec=[new ve({ndim:t.length,axes:{[e]:n}})];let o=[n];this.scale&&(this.gamma=this.addWeight("gamma",o,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",o,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",o,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",o,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(t,e){return B(()=>{let n=e.training==null?!1:e.training,o=Mt(t),s=o.shape,i=s.length,a=Jr(0,i),u=this.axis>=0?this.axis:this.axis+i;a.splice(u,1);let l=ko(1,i);l[u]=s[u];let c=a.slice();c.sort();let p=!x.arraysEqual(c,Jr(0,i).slice(0,i-1)),m=()=>{if(p){let b=O(this.movingMean.read(),l),w=O(this.movingVariance.read(),l),v=this.center?O(this.beta.read(),l):null,k=this.scale?O(this.gamma.read(),l):null;return rg(o,b,w,v,k,this.epsilon)}else return rg(o,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!n)return m();let[f,d,h]=A8(o,this.gamma.read(),this.beta.read(),a,this.epsilon),g=(b,w,v)=>{B(()=>{let k=1-v,E=b.read(),$=M(lt(E,w),k);b.write(lt(E,$))})};return(()=>{g(this.movingMean,d,this.momentum),g(this.movingVariance,h,this.momentum)})(),f})}getConfig(){let t={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Ee(this.betaInitializer),gammaInitializer:Ee(this.gammaInitializer),movingMeanInitializer:Ee(this.movingMeanInitializer),movingVarianceInitializer:Ee(this.movingVarianceInitializer),betaRegularizer:me(this.betaRegularizer),gammaRegularizer:me(this.gammaRegularizer),betaConstraint:We(this.betaConstraint),gammaConstraint:We(this.gammaConstraint)},e=super.getConfig();return Object.assign(t,e),t}};Ef.className="BatchNormalization";et.registerClass(Ef);var Af=class extends Bt{constructor(t){if(t==null&&(t={}),super(t),this.axis=t.axis==null?-1:t.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(let e of this.axis)if(!Number.isInteger(e))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=t.epsilon==null?.001:t.epsilon,this.center=t.center==null?!0:t.center,this.scale=t.scale==null?!0:t.scale,this.betaInitializer=de(t.betaInitializer||"zeros"),this.gammaInitializer=de(t.gammaInitializer||"ones"),this.betaRegularizer=Ce(t.betaRegularizer),this.gammaRegularizer=Ce(t.gammaRegularizer),this.supportsMasking=!0}build(t){t=Jt(t);let e=t.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let s=0;s<this.axis.length;++s)this.axis[s]<0&&(this.axis[s]+=e);for(let s of this.axis)if(s<0||s>=e)throw new Error(`Invalid axis: ${s}`);if(this.axis.length!==To(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);let n=this.axis.map(s=>t[s]),o=!0;this.scale?this.gamma=this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,o):this.gamma=null,this.center?this.beta=this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,o):this.beta=null,this.built=!0}call(t,e){let n=Mt(t),o=n.shape,s=o.length;return B(()=>{let{mean:a,variance:u}=xm(n,this.axis,!0),l=ko(1,s);for(let h of this.axis)l[h]=o[h];let c=h=>h!=null&&h.shape.length!==s?O(h,l):h,p=c(this.gamma.read()),m=c(this.beta.read()),f=[],d=[];for(let h=0;h<s;++h)this.axis.indexOf(h)!==-1?(f.push(o[h]),d.push(1)):(f.push(1),d.push(o[h]));return a=kr(a,f),u=kr(u,f),p=kr(p,d),m=kr(m,d),rg(n,a,u,m,p,this.epsilon)})}getConfig(){let t={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Ee(this.betaInitializer),gammaInitializer:Ee(this.gammaInitializer),betaRegularizer:me(this.betaRegularizer),gammaRegularizer:me(this.gammaRegularizer)},e=super.getConfig();return Object.assign(t,e),t}};Af.className="LayerNormalization";et.registerClass(Af);function $8(r,t,e){return B(()=>{if(r.rank!==4)throw new z(`temporalPadding expects input tensor to be 4-D, but received a ${r.rank}-D tensor.`);if(t==null&&(t=[[1,1],[1,1]]),t.length!==2||t[0].length!==2||t[1].length!==2)throw new z("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(e==null&&(e=hn()),e!=="channelsLast"&&e!=="channelsFirst")throw new z(`Unknown data format: ${e}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let n;return e==="channelsFirst"?n=[[0,0],[0,0],t[0],t[1]]:n=[[0,0],t[0],t[1],[0,0]],Yr(r,n)})}var $f=class extends Bt{constructor(t){if(t==null&&(t={}),super(t),this.dataFormat=t.dataFormat==null?hn():t.dataFormat,t.padding==null)this.padding=[[1,1],[1,1]];else if(typeof t.padding=="number")this.padding=[[t.padding,t.padding],[t.padding,t.padding]];else{if(t.padding=t.padding,t.padding.length!==2)throw new z(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${t.padding.length} array.`);let e,n;if(typeof t.padding[0]=="number")e=[t.padding[0],t.padding[0]],n=[t.padding[1],t.padding[1]];else{if(t.padding=t.padding,t.padding[0].length!==2)throw new z(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${t.padding[0].length} array.`);if(e=t.padding[0],t.padding[1].length!==2)throw new z(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${t.padding[1].length} array.`);n=t.padding[1]}this.padding=[e,n]}this.inputSpec=[new ve({ndim:4})]}computeOutputShape(t){t=Jt(t);let e,n;return this.dataFormat==="channelsFirst"?(t[2]!=null&&t[2]>=0?e=t[2]+this.padding[0][0]+this.padding[0][1]:e=null,t[3]!=null&&t[3]>=0?n=t[3]+this.padding[1][0]+this.padding[1][1]:n=null,[t[0],t[1],e,n]):(t[1]!=null&&t[1]>=0?e=t[1]+this.padding[0][0]+this.padding[0][1]:e=null,t[2]!=null&&t[2]>=0?n=t[2]+this.padding[1][0]+this.padding[1][1]:n=null,[t[0],e,n,t[3]])}call(t,e){return B(()=>$8(Mt(t),this.padding,this.dataFormat))}getConfig(){let t={padding:this.padding,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}};$f.className="ZeroPadding2D";et.registerClass($f);function rb(r,t,e,n,o,s){return B(()=>{Le(o),CS(s),gn(n),e==null&&(e=[1,1]),n==null&&(n="valid"),o==null&&(o=hn()),s==null&&(s="max"),r=tg(r,o);let i,a=n==="same"?"same":"valid";return s==="max"?i=Qa(r,t,e,a):i=qa(r,t,e,a),o==="channelsFirst"&&(i=Wt(i,[0,3,1,2])),i})}function Q$(r,t,e,n,o,s){return B(()=>{Le(o),CS(s),gn(n),e==null&&(e=[1,1,1]),n==null&&(n="valid"),o==null&&(o=hn()),s==null&&(s="max"),r=LS(r,o);let i,a=n==="same"?"same":"valid";return s==="max"?i=Th(r,t,e,a):i=fh(r,t,e,a),o==="channelsFirst"&&(i=Wt(i,[0,4,1,2,3])),i})}var Zy=class extends Bt{constructor(t){if(t.poolSize==null&&(t.poolSize=2),super(t),typeof t.poolSize=="number")this.poolSize=[t.poolSize];else if(Array.isArray(t.poolSize)&&t.poolSize.length===1&&typeof t.poolSize[0]=="number")this.poolSize=t.poolSize;else throw new z(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.poolSize)}`);if(er(this.poolSize,"poolSize"),t.strides==null)this.strides=this.poolSize;else if(typeof t.strides=="number")this.strides=[t.strides];else if(Array.isArray(t.strides)&&t.strides.length===1&&typeof t.strides[0]=="number")this.strides=t.strides;else throw new z(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.strides)}`);er(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,gn(this.padding),this.inputSpec=[new ve({ndim:3})]}computeOutputShape(t){t=Jt(t);let e=An(t[1],this.poolSize[0],this.padding,this.strides[0]);return[t[0],e,t[2]]}call(t,e){return B(()=>{this.invokeCallHook(t,e),t=ll(Mt(t),2);let n=this.poolingFunction(Mt(t),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return zr(n,[2])})}getConfig(){let t={poolSize:this.poolSize,padding:this.padding,strides:this.strides},e=super.getConfig();return Object.assign(t,e),t}},Df=class extends Zy{constructor(t){super(t)}poolingFunction(t,e,n,o,s){return Le(s),gn(o),rb(t,e,n,o,s,"max")}};Df.className="MaxPooling1D";et.registerClass(Df);var Rf=class extends Zy{constructor(t){super(t)}poolingFunction(t,e,n,o,s){return Le(s),gn(o),rb(t,e,n,o,s,"avg")}};Rf.className="AveragePooling1D";et.registerClass(Rf);var Jy=class extends Bt{constructor(t){if(t.poolSize==null&&(t.poolSize=[2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize],t.strides==null)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(t.strides.length!==2)throw new z(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides];er(this.poolSize,"poolSize"),er(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,Le(this.dataFormat),gn(this.padding),this.inputSpec=[new ve({ndim:4})]}computeOutputShape(t){t=Jt(t);let e=this.dataFormat==="channelsFirst"?t[2]:t[1],n=this.dataFormat==="channelsFirst"?t[3]:t[2];return e=An(e,this.poolSize[0],this.padding,this.strides[0]),n=An(n,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[t[0],t[1],e,n]:[t[0],e,n,t[3]]}call(t,e){return B(()=>(this.invokeCallHook(t,e),this.poolingFunction(Mt(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}},Ff=class extends Jy{constructor(t){super(t)}poolingFunction(t,e,n,o,s){return Le(s),gn(o),rb(t,e,n,o,s,"max")}};Ff.className="MaxPooling2D";et.registerClass(Ff);var Of=class extends Jy{constructor(t){super(t)}poolingFunction(t,e,n,o,s){return Le(s),gn(o),rb(t,e,n,o,s,"avg")}};Of.className="AveragePooling2D";et.registerClass(Of);var Qy=class extends Bt{constructor(t){if(t.poolSize==null&&(t.poolSize=[2,2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize,t.poolSize],t.strides==null)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(t.strides.length!==3)throw new z(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides,t.strides];er(this.poolSize,"poolSize"),er(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,Le(this.dataFormat),gn(this.padding),this.inputSpec=[new ve({ndim:5})]}computeOutputShape(t){t=Jt(t);let e=this.dataFormat==="channelsFirst"?t[2]:t[1],n=this.dataFormat==="channelsFirst"?t[3]:t[2],o=this.dataFormat==="channelsFirst"?t[4]:t[3];return e=An(e,this.poolSize[0],this.padding,this.strides[0]),n=An(n,this.poolSize[1],this.padding,this.strides[1]),o=An(o,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[t[0],t[1],e,n,o]:[t[0],e,n,o,t[4]]}call(t,e){return B(()=>(this.invokeCallHook(t,e),this.poolingFunction(Mt(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}},Mf=class extends Qy{constructor(t){super(t)}poolingFunction(t,e,n,o,s){return Le(s),gn(o),Q$(t,e,n,o,s,"max")}};Mf.className="MaxPooling3D";et.registerClass(Mf);var Pf=class extends Qy{constructor(t){super(t)}poolingFunction(t,e,n,o,s){return Le(s),gn(o),Q$(t,e,n,o,s,"avg")}};Pf.className="AveragePooling3D";et.registerClass(Pf);var tb=class extends Bt{constructor(t){super(t),this.inputSpec=[new ve({ndim:3})]}computeOutputShape(t){return[t[0],t[2]]}call(t,e){throw new Nt}},Lf=class extends tb{constructor(t){super(t||{})}call(t,e){return B(()=>{let n=Mt(t);return xe(n,1)})}};Lf.className="GlobalAveragePooling1D";et.registerClass(Lf);var zf=class extends tb{constructor(t){super(t||{})}call(t,e){return B(()=>{let n=Mt(t);return Dr(n,1)})}};zf.className="GlobalMaxPooling1D";et.registerClass(zf);var eb=class extends Bt{constructor(t){super(t),this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,Le(this.dataFormat),this.inputSpec=[new ve({ndim:4})]}computeOutputShape(t){return t=t,this.dataFormat==="channelsLast"?[t[0],t[3]]:[t[0],t[1]]}call(t,e){throw new Nt}getConfig(){let t={dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}},Bf=class extends eb{call(t,e){return B(()=>{let n=Mt(t);return this.dataFormat==="channelsLast"?xe(n,[1,2]):xe(n,[2,3])})}};Bf.className="GlobalAveragePooling2D";et.registerClass(Bf);var Vf=class extends eb{call(t,e){return B(()=>{let n=Mt(t);return this.dataFormat==="channelsLast"?Dr(n,[1,2]):Dr(n,[2,3])})}};Vf.className="GlobalMaxPooling2D";et.registerClass(Vf);var nb=class extends Bt{constructor(t){super(t),this.layer=t.layer}build(t){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(t){this.layer!=null&&(this.layer.trainable=t)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(t){this.layer.setWeights(t)}getConfig(){let t={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},e=super.getConfig();return Object.assign(t,e),t}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(t)}static fromConfig(t,e,n={}){let o=e.layer,s=vn(o,n);delete e.layer;let i={layer:s};return Object.assign(i,e),new t(i)}},Gf=class extends nb{constructor(t){super(t),this.supportsMasking=!0}build(t){if(t=Jt(t),t.length<3)throw new z(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(t)}`);this.inputSpec=[{shape:t}];let e=[t[0]].concat(t.slice(2));this.layer.built||(this.layer.build(e),this.layer.built=!0),super.build(t)}computeOutputShape(t){t=Jt(t);let e=[t[0]].concat(t.slice(2)),n=this.layer.computeOutputShape(e),o=t[1];return[n[0],o].concat(n.slice(1))}call(t,e){return B(()=>(t=Mt(t),BS((i,a)=>[Mt(this.layer.call(i,e)),[]],t,[],!1,null,null,!1,!0)[1]))}};Gf.className="TimeDistributed";et.registerClass(Gf);function D8(r){qi(a$,"BidirectionalMergeMode",r)}var R8="concat",Wf=class extends nb{constructor(t){super(t);let e=t.layer.getConfig(),n={};n.className=t.layer.getClassName(),n.config=e,this.forwardLayer=vn(n),e.goBackwards=e.goBackwards!==!0;let o={};if(o.className=t.layer.getClassName(),o.config=e,this.backwardLayer=vn(o),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=t.mergeMode===void 0?R8:t.mergeMode,D8(this.mergeMode),t.weights)throw new Nt("weights support is not implemented for Bidirectional layer yet.");this._stateful=t.layer.stateful,this.returnSequences=t.layer.returnSequences,this.returnState=t.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=t.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(t){this._trainable=t,this.forwardLayer!=null&&(this.forwardLayer.trainable=t),this.backwardLayer!=null&&(this.backwardLayer.trainable=t)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(t){let e=t.length,n=Math.floor(e/2);this.forwardLayer.setWeights(t.slice(0,n)),this.backwardLayer.setWeights(t.slice(n))}computeOutputShape(t){let e=this.forwardLayer.computeOutputShape(t);Array.isArray(e)&&Array.isArray(e[0])||(e=[e]),e=e;let n,o,s;return this.returnState&&(s=e.slice(1)),n=e[0],n=n,this.mergeMode==="concat"?(n[n.length-1]*=2,o=[n]):this.mergeMode==null?o=[n,n.slice()]:o=[n],this.returnState?this.mergeMode==null?o.concat(s).concat(s.slice()):[n].concat(s).concat(s.slice()):_r(o)}apply(t,e){let n=e==null?null:e.initialState,o=e==null?null:e.constants;e==null&&(e={});let s=zS(t,n,o,this.numConstants);if(t=s.inputs,n=s.initialState,o=s.constants,Array.isArray(t)&&(n=t.slice(1),t=t[0]),(n==null||n.length===0)&&o==null)return super.apply(t,e);let i=[],a=[];if(n!=null){let l=n.length;if(l%2>0)throw new z("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");e.initialState=n,i.push(...n);let c=n.map(p=>new ve({shape:p.shape}));this.forwardLayer.stateSpec=c.slice(0,l/2),this.backwardLayer.stateSpec=c.slice(l/2),a.push(...c)}if(o!=null)throw new Nt("Support for constants in Bidirectional layers is not implemented yet.");let u=i[0]instanceof Qr;for(let l of i)if(l instanceof Qr!==u)throw new z("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(u){let l=[t].concat(i),c=this.inputSpec.concat(a),p=this.inputSpec;this.inputSpec=c;let m=super.apply(l,e);return this.inputSpec=p,m}else return super.apply(t,e)}call(t,e){return B(()=>{let n=e.initialState,o,s;if(n==null)o=this.forwardLayer.call(t,e),s=this.backwardLayer.call(t,e);else{let u=n.slice(0,n.length/2),l=n.slice(n.length/2);o=this.forwardLayer.call(t,Object.assign(e,{initialState:u})),s=this.backwardLayer.call(t,Object.assign(e,{initialState:l}))}let i;this.returnState&&(Array.isArray(o)&&(i=o.slice(1).concat(s.slice(1))),o=o[0],s=s[0]),this.returnSequences&&(s=ir(s,1));let a;return this.mergeMode==="concat"?a=Em([o,s]):this.mergeMode==="sum"?a=J(o,s):this.mergeMode==="ave"?a=M(.5,J(o,s)):this.mergeMode==="mul"?a=M(o,s):this.mergeMode==null&&(a=[o,s]),this.returnState?this.mergeMode==null?a.concat(i):[a].concat(i):a})}resetStates(t){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(t){si(this.forwardLayer.name,()=>{this.forwardLayer.build(t)}),si(this.backwardLayer.name,()=>{this.backwardLayer.build(t)}),this.built=!0}computeMask(t,e){Array.isArray(e)&&(e=e[0]);let n;if(this.returnSequences?this.mergeMode==null?n=[e,e]:n=e:this.mergeMode==null?n=[null,null]:n=null,this.returnState){let s=this.forwardLayer.states.map(i=>null);return Array.isArray(n)?n.concat(s).concat(s):[n].concat(s).concat(s)}else return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(t),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(t)}getConfig(){let t={mergeMode:this.mergeMode},e=super.getConfig();return Object.assign(t,e),t}static fromConfig(t,e){let n=vn(e.layer);if(delete e.layer,e.numConstants!=null)throw new Nt("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");let o=e;return o.layer=n,new t(o)}};Wf.className="Bidirectional";et.registerClass(Wf);function F8(r){return new ai(r)}function O8(r){return new Ym(r)}function M8(r){return new Km(r)}function P8(r){return new jm(r)}function L8(r){return new Xm(r)}function z8(r){return new Jm(r)}function B8(r){return new Zm(r)}function V8(r){return new mu(r)}function G8(r){return new pl(r)}function W8(r){return new Qm(r)}function U8(r){return new ml(r)}function H8(r){return new tf(r)}function q8(r){return new ef(r)}function K8(r){return new rf(r)}function j8(r){return new nf(r)}function X8(r){return new of(r)}function Y8(r){return new ff(r)}function Z8(r){return new pf(r)}function J8(r){return new zc(r)}function Q8(r){return new cf(r)}function tY(r){return new mf(r)}function eY(r){return new df(r)}function rY(r){return new hf(r)}function nY(r){return new gf(r)}function oY(r){return new yf(r)}function sY(r){return new bf(r)}function iY(r){return new vf(r)}function aY(r){return new Sf(r)}function lY(r){return new Cf(r)}function uY(r){return new If(r)}function cY(r){return new wf(r)}function pY(r){return new kf(r)}function mY(r){return new Ef(r)}function fY(r){return new Af(r)}function dY(r){return new $f(r)}function VS(r){return new Rf(r)}function hY(r){return VS(r)}function gY(r){return VS(r)}function GS(r){return new Of(r)}function xY(r){return GS(r)}function yY(r){return GS(r)}function WS(r){return new Pf(r)}function bY(r){return WS(r)}function wY(r){return WS(r)}function vY(r){return new Lf(r)}function CY(r){return new Bf(r)}function tD(r){return new zf(r)}function eD(r){return new Vf(r)}function rD(r){return new Df(r)}function nD(r){return new Ff(r)}function IY(r){return new Mf(r)}function SY(r){return new af(r)}function kY(r){return new Mc(r)}function NY(r){return new lf(r)}function TY(r){return new dl(r)}function _Y(r){return new sf(r)}function EY(r){return new Oc(r)}function AY(r){return new uf(r)}function $Y(r){return new Lc(r)}function DY(r){return new $n(r)}function RY(r){return new Pc(r)}function FY(r){return new Wf(r)}function OY(r){return new Gf(r)}var MY=tD,PY=eD,LY=rD,zY=nD;function BY(r){return new Nf(r)}function VY(r){return new Tf(r)}function GY(r){return new _f(r)}function WY(r){return new xf(r)}var sD={};Yt(sD,{MAPE:()=>t7,MSE:()=>n7,binaryAccuracy:()=>UY,binaryCrossentropy:()=>HY,categoricalAccuracy:()=>KY,categoricalCrossentropy:()=>jY,cosineProximity:()=>ZY,mape:()=>e7,meanAbsoluteError:()=>JY,meanAbsolutePercentageError:()=>QY,meanSquaredError:()=>r7,mse:()=>o7,precision:()=>XY,recall:()=>YY,sparseCategoricalAccuracy:()=>qY});function UY(r,t){return Yh(r,t)}function HY(r,t){return ky(r,t)}function qY(r,t){return Ny(r,t)}function KY(r,t){return Zh(r,t)}function jY(r,t){return Jh(r,t)}function XY(r,t){return _S(r,t)}function YY(r,t){return _$(r,t)}function ZY(r,t){return Xh(r,t)}function JY(r,t){return Vm(r,t)}function QY(r,t){return lu(r,t)}function t7(r,t){return lu(r,t)}function e7(r,t){return lu(r,t)}function r7(r,t){return ji(r,t)}function n7(r,t){return ji(r,t)}function o7(r,t){return ji(r,t)}var iD={};Yt(iD,{modelFromJSON:()=>q$});var aD={};Yt(aD,{l1:()=>i7,l1l2:()=>s7,l2:()=>a7});function s7(r){return new uu(r)}function i7(r){return Y$(r)}function a7(r){return Z$(r)}var sb=class extends cl{constructor(){super(...arguments),this.model=null}setModel(t){if(!(t instanceof Vn))throw new Error("model must be a LayersModel, not some other Container");this.model=t}};function ob(r,t){return r<t}function lD(r,t){return r>t}var ib=class extends sb{constructor(t){if(super(),t==null&&(t={}),t.restoreBestWeights)throw new Nt("restoreBestWeights = True is not implemented in EarlyStopping yet.");this.monitor=t.monitor||"val_loss",this.minDelta=Math.abs(t.minDelta||0),this.patience=t.patience||0,this.verbose=t.verbose||0,this.mode=t.mode||"auto",this.baseline=t.baseline,["auto","min","max"].indexOf(this.mode)===-1&&(console.warn(`EarlyStopping mode '${this.mode}' is invalid. Falling back to mode 'auto'.`),this.mode="auto"),this.mode==="min"?this.monitorFunc=ob:this.mode==="max"?this.monitorFunc=lD:this.monitor.indexOf("acc")!==-1?this.monitorFunc=lD:this.monitorFunc=ob,this.monitorFunc===ob&&(this.minDelta*=-1)}async onTrainBegin(t){this.wait=0,this.stoppedEpoch=0,this.baseline!=null?this.best=this.baseline:this.best=this.monitorFunc===ob?1/0:-1/0}async onEpochEnd(t,e){await Ki(e);let n=this.getMonitorValue(e);n!=null&&(this.monitorFunc(n-this.minDelta,this.best)?(this.best=n,this.wait=0):(this.wait++,this.wait>=this.patience&&(this.stoppedEpoch=t,this.model.stopTraining=!0)))}async onTrainEnd(t){this.stoppedEpoch>0&&this.verbose&&console.log(`Epoch ${this.stoppedEpoch}: early stopping.`)}getMonitorValue(t){t==null&&(t={});let e=t[this.monitor];return e==null&&console.warn(`Metric for EarlyStopping ${this.monitor} is not available. Available metrics are: ${Object.keys(t)}`),e}};function l7(r){return new ib(r)}var u7={earlyStopping:l7};var c7=V();c7.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,r=>{r&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});var to;(function(r){r[r.DT_INVALID=0]="DT_INVALID",r[r.DT_FLOAT=1]="DT_FLOAT",r[r.DT_DOUBLE=2]="DT_DOUBLE",r[r.DT_INT32=3]="DT_INT32",r[r.DT_UINT8=4]="DT_UINT8",r[r.DT_INT16=5]="DT_INT16",r[r.DT_INT8=6]="DT_INT8",r[r.DT_STRING=7]="DT_STRING",r[r.DT_COMPLEX64=8]="DT_COMPLEX64",r[r.DT_INT64=9]="DT_INT64",r[r.DT_BOOL=10]="DT_BOOL",r[r.DT_QINT8=11]="DT_QINT8",r[r.DT_QUINT8=12]="DT_QUINT8",r[r.DT_QINT32=13]="DT_QINT32",r[r.DT_BFLOAT16=14]="DT_BFLOAT16",r[r.DT_QINT16=15]="DT_QINT16",r[r.DT_QUINT16=16]="DT_QUINT16",r[r.DT_UINT16=17]="DT_UINT16",r[r.DT_COMPLEX128=18]="DT_COMPLEX128",r[r.DT_HALF=19]="DT_HALF",r[r.DT_RESOURCE=20]="DT_RESOURCE",r[r.DT_VARIANT=21]="DT_VARIANT",r[r.DT_UINT32=22]="DT_UINT32",r[r.DT_UINT64=23]="DT_UINT64",r[r.DT_FLOAT_REF=101]="DT_FLOAT_REF",r[r.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",r[r.DT_INT32_REF=103]="DT_INT32_REF",r[r.DT_UINT8_REF=104]="DT_UINT8_REF",r[r.DT_INT16_REF=105]="DT_INT16_REF",r[r.DT_INT8_REF=106]="DT_INT8_REF",r[r.DT_STRING_REF=107]="DT_STRING_REF",r[r.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",r[r.DT_INT64_REF=109]="DT_INT64_REF",r[r.DT_BOOL_REF=110]="DT_BOOL_REF",r[r.DT_QINT8_REF=111]="DT_QINT8_REF",r[r.DT_QUINT8_REF=112]="DT_QUINT8_REF",r[r.DT_QINT32_REF=113]="DT_QINT32_REF",r[r.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",r[r.DT_QINT16_REF=115]="DT_QINT16_REF",r[r.DT_QUINT16_REF=116]="DT_QUINT16_REF",r[r.DT_UINT16_REF=117]="DT_UINT16_REF",r[r.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",r[r.DT_HALF_REF=119]="DT_HALF_REF",r[r.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",r[r.DT_VARIANT_REF=121]="DT_VARIANT_REF",r[r.DT_UINT32_REF=122]="DT_UINT32_REF",r[r.DT_UINT64_REF=123]="DT_UINT64_REF"})(to||(to={}));var uD;(function(r){let t;(function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"})(t=r.CheckpointFormatVersion||(r.CheckpointFormatVersion={}))})(uD||(uD={}));var US={};function m7(r,t){let e={tfOpName:r,category:"custom",inputs:[],attrs:[],customExecutor:t};US[r]=e}function ab(r){return US[r]}function f7(r){delete US[r]}function I(r,t,e,n,o){let s=t.inputParams[r];if(s&&s.inputIndexStart!==void 0){let a=s.inputIndexStart,u=s.inputIndexEnd===0?void 0:s.inputIndexEnd===void 0?a+1:s.inputIndexEnd;if(s.type==="tensor")return Cr(t.inputNames[s.inputIndexStart],e,n,o);if(s.type==="tensors")return t.inputNames.slice(a,u).map(m=>Cr(m,e,n,o));let l=Cr(t.inputNames.slice(a)[0],e,n,o),c=l.dataSync();return s.type==="number"?c[0]:x.toNestedArray(l.shape,c)}let i=t.attrParams[r];return i&&i.value}function Cr(r,t,e,n){let[o,s]=Cn(r);if(n!=null){let a=n.getHashTableHandleByName(o);if(a!=null)return a}let i=e.currentContextIds.find(a=>!!t[lb(o,a)]);return i!==void 0?t[lb(o,i)][s]:void 0}function cD(r,t,e){return t[lb(r,e.currentContextId)]}function Do(r,t){let[e,n,o]=Cn(r);return[lb(e,t&&t.currentContextId),n,o]}function lb(r,t){return t?`${r}-${t}`:r}function Cn(r){let t=r.split(":");if(t.length===1)return[r,0,void 0];let e=t[0],n=t.length===3?t[1]:void 0,o=Number(t[t.length-1]);return[e,o,n]}function ng(r,t,e){let n=I("pad",r,t,e);if(n==="explicit"){n=I("explicitPaddings",r,t,e);let o=[[0,0],[0,0],[0,0],[0,0]];for(let s=0;s<4;s++)o[s][0]=n[s*2],o[s][1]=n[s*2+1];return o}return n}function pi(r){return r.kept?r:kn(r)}var HS={};Yt(HS,{json:()=>d7});var d7=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var qS={};Yt(qS,{json:()=>h7});var h7=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var KS={};Yt(KS,{json:()=>g7});var g7=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]}];var jS={};Yt(jS,{json:()=>x7});var x7=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number"}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}];var XS={};Yt(XS,{json:()=>y7});var y7=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}];var YS={};Yt(YS,{json:()=>b7});var b7=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var ZS={};Yt(ZS,{json:()=>w7});var w7=[{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}];var JS={};Yt(JS,{json:()=>v7});var v7=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}];var QS={};Yt(QS,{json:()=>C7});var C7=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]}];var tk={};Yt(tk,{json:()=>I7});var I7=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}];var ek={};Yt(ek,{json:()=>S7});var S7=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var rk={};Yt(rk,{json:()=>k7});var k7=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]}];var nk={};Yt(nk,{json:()=>N7});var N7=[{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}];var ok={};Yt(ok,{json:()=>T7});var T7=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}];var sk={};Yt(sk,{json:()=>_7});var _7=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}];var ik={};Yt(ik,{json:()=>E7});var E7=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}];var ak={};Yt(ak,{json:()=>A7});var A7=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}];var lk={};Yt(lk,{json:()=>$7});var $7=[{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}];var uk={};Yt(uk,{json:()=>D7});var D7=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}];var og=class{static get Instance(){return this._instance||(this._instance=new this)}constructor(){let t=[HS,qS,KS,jS,XS,YS,ZS,JS,QS,tk,ek,rk,nk,ok,sk,ik,ak,lk,uk],e=[].concat(...t.map(n=>n.json));this.opMappers=e.reduce((n,o)=>(n[o.tfOpName]=o,n),{})}transformGraph(t,e={}){let n=t.node,o=[],s=[],i=[],a=n.reduce((h,g)=>(h[g.name]=this.mapNode(g),g.op.startsWith("Placeholder")?o.push(h[g.name]):g.op==="Const"?s.push(h[g.name]):(g.input==null||g.input.length===0)&&i.push(h[g.name]),h),{}),u=[],l=[],c={},p={};e!=null&&(c=this.mapSignatureEntries(e.inputs),p=this.mapSignatureEntries(e.outputs));let m=Object.keys(a);m.forEach(h=>{let g=a[h];g.inputNames.forEach((y,b)=>{let[w,,v]=Do(y),k=a[w];if(k.outputs!=null){let E=k.outputs.indexOf(v);if(E!==-1){let $=`${w}:${E}`;g.inputNames[b]=$}}g.inputs.push(k),k.children.push(g)})}),Object.keys(p).length===0?m.forEach(h=>{let g=a[h];g.children.length===0&&l.push(g)}):Object.keys(p).forEach(h=>{let[g]=Do(h),y=a[g];y!=null&&(y.signatureKey=p[h],l.push(y))}),Object.keys(c).length>0?Object.keys(c).forEach(h=>{let[g]=Do(h),y=a[g];y&&(y.signatureKey=c[h],u.push(y))}):u=o;let f={};t.library!=null&&t.library.function!=null&&(f=t.library.function.reduce((h,g)=>(h[g.signature.name]=this.mapFunction(g),h),{}));let d={nodes:a,inputs:u,outputs:l,weights:s,placeholders:o,signature:e,functions:f};return i.length>0&&(d.initNodes=i),d}mapSignatureEntries(t){return Object.keys(t||{}).reduce((e,n)=>(e[t[n].name]=n,e),{})}mapNode(t){let e=ab(t.op)||this.opMappers[t.op]||{};t.attr==null&&(t.attr={});let n={name:t.name,op:t.op,category:e.category,inputNames:(t.input||[]).map(o=>o.startsWith("^")?o.substr(1):o),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:t.attr,outputs:e.outputs};return e.inputs!=null&&(n.inputParams=e.inputs.reduce((o,s)=>(o[s.name]={type:s.type,inputIndexStart:s.start,inputIndexEnd:s.end},o),{})),e.attrs!=null&&(n.attrParams=e.attrs.reduce((o,s)=>{let i=s.type,a;switch(s.type){case"string":a=ub(t.attr,s.tfName,s.defaultValue),a===void 0&&!!s.tfDeprecatedName&&(a=ub(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"string[]":a=gb(t.attr,s.tfName,s.defaultValue),a===void 0&&!!s.tfDeprecatedName&&(a=gb(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"number":a=pb(t.attr,s.tfName,s.defaultValue||0),a===void 0&&!!s.tfDeprecatedName&&(a=pb(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"number[]":a=hb(t.attr,s.tfName,s.defaultValue),a===void 0&&!!s.tfDeprecatedName&&(a=hb(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"bool":a=cb(t.attr,s.tfName,s.defaultValue),a===void 0&&!!s.tfDeprecatedName&&(a=cb(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"bool[]":a=yb(t.attr,s.tfName,s.defaultValue),a===void 0&&!!s.tfDeprecatedName&&(a=yb(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"shape":a=db(t.attr,s.tfName,s.defaultValue),a===void 0&&!!s.tfDeprecatedName&&(a=db(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"shape[]":a=xb(t.attr,s.tfName,s.defaultValue),a===void 0&&!!s.tfDeprecatedName&&(a=xb(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"dtype":a=mb(t.attr,s.tfName,s.defaultValue),a===void 0&&!!s.tfDeprecatedName&&(a=mb(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"dtype[]":a=fb(t.attr,s.tfName,s.defaultValue),a===void 0&&!!s.tfDeprecatedName&&(a=fb(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"func":a=pD(t.attr,s.tfName,s.defaultValue),a===void 0&&!!s.tfDeprecatedName&&(a=pD(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${s.type} for op: ${t.op}`)}return o[s.name]={value:a,type:i},o},{})),n}mapFunction(t){let e=t.nodeDef,n=[],o=[],s={};e!=null&&(s=e.reduce((p,m)=>(p[m.name]=this.mapNode(m),m.op==="Const"&&o.push(p[m.name]),p),{}));let i=[],a=[];t.signature.inputArg.forEach(p=>{let[m]=Do(p.name),f={name:m,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:ck(p.type),type:"dtype"}},children:[]};f.signatureKey=p.name,i.push(f),s[m]=f}),Object.keys(s).forEach(p=>{let m=s[p];m.inputNames.forEach((f,d)=>{let[h,,g]=Do(f),y=s[h];if(y.outputs!=null){let b=y.outputs.indexOf(g);if(b!==-1){let w=`${h}:${b}`;m.inputNames[d]=w}}m.inputs.push(y),y.children.push(m)})});let l=t.ret;t.signature.outputArg.forEach(p=>{let[m,f]=Do(l[p.name]),d=s[m];d!=null&&(d.defaultOutput=f,a.push(d))});let c=this.mapArgsToSignature(t);return{nodes:s,inputs:i,outputs:a,weights:o,placeholders:n,signature:c}}mapArgsToSignature(t){return{methodName:t.signature.name,inputs:t.signature.inputArg.reduce((e,n)=>(e[n.name]=this.mapArgToTensorInfo(n),e),{}),outputs:t.signature.outputArg.reduce((e,n)=>(e[n.name]=this.mapArgToTensorInfo(n,t.ret),e),{})}}mapArgToTensorInfo(t,e){let n=t.name;return e!=null&&(n=e[n]),{name:n,dtype:t.type}}};function R7(r){let t=V().global;if(typeof t.atob!="undefined")return t.atob(r);if(typeof Buffer!="undefined")return new Buffer(r,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function mD(r,t){let e=Array.isArray(r)?String.fromCharCode.apply(null,r):R7(r);return t?e:e.toLowerCase()}function ub(r,t,e,n=!1){let o=r[t];return o!=null?mD(o.s,n):e}function cb(r,t,e){let n=r[t];return n?n.b:e}function pb(r,t,e){let n=r[t]||{},o=n.i!=null?n.i:n.f!=null?n.f:e;return typeof o=="number"?o:parseInt(o,10)}function ck(r){switch(typeof r=="string"&&(r=to[r]),r){case to.DT_FLOAT:case to.DT_HALF:return"float32";case to.DT_INT32:case to.DT_INT64:case to.DT_INT8:case to.DT_UINT8:return"int32";case to.DT_BOOL:return"bool";case to.DT_DOUBLE:return"float32";case to.DT_STRING:return"string";default:return null}}function pD(r,t,e){let n=r[t];return n&&n.func?n.func.name:e}function mb(r,t,e){let n=r[t];return n&&n.type?ck(n.type):e}function fb(r,t,e){let n=r[t];return n&&n.list&&n.list.type?n.list.type.map(o=>ck(o)):e}function fD(r){if(!r.unknownRank)return r.dim!=null?r.dim.map(t=>typeof t.size=="number"?t.size:parseInt(t.size,10)):[]}function db(r,t,e){let n=r[t];return n&&n.shape?fD(n.shape):e}function hb(r,t,e){let n=r[t];return n?((n.list.f&&n.list.f.length?n.list.f:n.list.i)||[]).map(o=>typeof o=="number"?o:parseInt(o,10)):e}function gb(r,t,e,n=!1){let o=r[t];return o&&o.list&&o.list.s?o.list.s.map(s=>mD(s,n)):e}function xb(r,t,e){let n=r[t];return n&&n.list&&n.list.shape?n.list.shape.map(o=>fD(o)):e}function yb(r,t,e){let n=r[t];return n&&n.list&&n.list.b?n.list.b:e}var bb=class{constructor(t,e,n){this.node=t,this.tensorMap=e,this.context=n,this.inputs=[],this.attrs={},this.inputs=t.inputNames.map(o=>this.getInput(o)),t.rawAttrs!=null&&(this.attrs=Object.keys(t.rawAttrs).reduce((o,s)=>(o[s]=this.getAttr(s),o),{}))}getInput(t){return Cr(t,this.tensorMap,this.context)}getAttr(t,e){let n=this.node.rawAttrs[t];if(n.tensor!=null)return Cr(t,this.tensorMap,this.context);if(n.i!=null||n.f!=null)return pb(this.node.rawAttrs,t,e);if(n.s!=null)return ub(this.node.rawAttrs,t,e);if(n.b!=null)return cb(this.node.rawAttrs,t,e);if(n.shape!=null)return db(this.node.rawAttrs,t,e);if(n.type!=null)return mb(this.node.rawAttrs,t,e);if(n.list!=null){if(n.list.i!=null||n.list.f!=null)return hb(this.node.rawAttrs,t,e);if(n.list.s!=null)return gb(this.node.rawAttrs,t,e);if(n.list.shape!=null)return xb(this.node.rawAttrs,t,e);if(n.list.b!=null)return yb(this.node.rawAttrs,t,e);if(n.list.type!=null)return fb(this.node.rawAttrs,t,e)}return e}};var dD=(r,t,e)=>{switch(r.op){case"BiasAdd":case"AddV2":case"Add":return[J(I("a",r,t,e),I("b",r,t,e))];case"AddN":return[kI(I("tensors",r,t,e))];case"FloorMod":case"Mod":return[Eh(I("a",r,t,e),I("b",r,t,e))];case"Mul":return[M(I("a",r,t,e),I("b",r,t,e))];case"RealDiv":case"Div":return[ct(I("a",r,t,e),I("b",r,t,e))];case"DivNoNan":return[wh(I("a",r,t,e),I("b",r,t,e))];case"FloorDiv":return[qu(I("a",r,t,e),I("b",r,t,e))];case"Sub":return[lt(I("a",r,t,e),I("b",r,t,e))];case"Minimum":return[ti(I("a",r,t,e),I("b",r,t,e))];case"Maximum":return[fn(I("a",r,t,e),I("b",r,t,e))];case"Pow":return[Zr(I("a",r,t,e),I("b",r,t,e))];case"SquaredDifference":return[dc(I("a",r,t,e),I("b",r,t,e))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var hD=(r,t,e)=>{switch(r.op){case"Abs":case"ComplexAbs":return[Ne(I("x",r,t,e))];case"Acos":return[sh(I("x",r,t,e))];case"Acosh":return[ih(I("x",r,t,e))];case"Asin":return[lh(I("x",r,t,e))];case"Asinh":return[uh(I("x",r,t,e))];case"Atan":return[ch(I("x",r,t,e))];case"Atan2":return[ph(I("x",r,t,e),I("y",r,t,e))];case"Atanh":return[mh(I("x",r,t,e))];case"Ceil":return[hh(I("x",r,t,e))];case"Complex":return[zn(I("real",r,t,e),I("imag",r,t,e))];case"Cos":return[Xa(I("x",r,t,e))];case"Cosh":return[Ju(I("x",r,t,e))];case"Elu":return[Zs(I("x",r,t,e))];case"Erf":return[vh(I("x",r,t,e))];case"Exp":return[Ze(I("x",r,t,e))];case"Expm1":return[Ch(I("x",r,t,e))];case"Floor":return[Qs(I("x",r,t,e))];case"Log":return[wr(I("x",r,t,e))];case"Log1p":return[Za(I("x",r,t,e))];case"Imag":return[tc(I("x",r,t,e))];case"Neg":return[Zt(I("x",r,t,e))];case"Reciprocal":return[Ah(I("x",r,t,e))];case"Real":return[Jl(I("x",r,t,e))];case"Relu":return[Tr(I("x",r,t,e))];case"Round":return[lc(I("x",r,t,e))];case"Selu":return[cc(I("x",r,t,e))];case"Sigmoid":return[Lr(I("x",r,t,e))];case"Sin":return[pc(I("x",r,t,e))];case"Sign":return[Dh(I("x",r,t,e))];case"Sinh":return[mc(I("x",r,t,e))];case"Softplus":return[bo(I("x",r,t,e))];case"Sqrt":return[be(I("x",r,t,e))];case"Square":return[Ut(I("x",r,t,e))];case"Tanh":return[Xs(I("x",r,t,e))];case"Tan":return[Mh(I("x",r,t,e))];case"ClipByValue":return[br(I("x",r,t,e),I("clipValueMin",r,t,e),I("clipValueMax",r,t,e))];case"Relu6":return[ac(I("x",r,t,e))];case"Rsqrt":return[uc(Cr(r.inputNames[0],t,e))];case"Prod":return[oc(I("x",r,t,e),I("axes",r,t,e))];case"LeakyRelu":return[Ya(I("x",r,t,e),I("alpha",r,t,e))];case"Prelu":return[el(I("x",r,t,e),I("alpha",r,t,e))];case"IsNan":return[Ih(Cr(r.inputNames[0],t,e))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};function Gn(r,t,e=""){if(!(typeof r=="number"||typeof t=="number")){x.assert(r.length===t.length,()=>e+` Shapes ${r} and ${t} must match`);for(let n=0;n<r.length;n++){let o=r[n],s=t[n];x.assert(o<0||s<0||o===s,()=>e+` Shapes ${r} and ${t} must match`)}}}function gD(r){return!(typeof r=="number"||r.some(t=>t<0))}function Uf(r,t,e){let n=wb(r,e),o=!gD(n);if(o&&t.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${n}`);if(o&&t.forEach(s=>{n=wb(s.shape,n)}),!gD(n))throw new Error(`Non-fully-defined elementShape: ${n}`);return n}function wb(r,t){if(typeof r=="number")return t;if(typeof t=="number")return r;if(r.length!==t.length)throw new Error(`Incompatible ranks during merge: ${r} vs. ${t}`);let e=[];for(let n=0;n<r.length;++n){let o=r[n],s=t[n];if(o>=0&&s>=0&&o!==s)throw new Error(`Incompatible shape during merge: ${r} vs. ${t}`);e[n]=o>=0?o:s}return e}var vb=class{constructor(t,e,n,o,s,i,a){this.name=t,this.dtype=e,this.maxSize=n,this.elementShape=o,this.identicalElementShapes=s,this.dynamicSize=i,this.clearAfterRead=a,this.tensors=[],this.closed_=!1,this.idTensor=pt(0),Pe(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(t){this.tensors.forEach(e=>{(t==null||!t.has(e.tensor.id))&&e.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(t<0||t>=this.size())throw new Error(`Tried to read from index ${t}, but array size is: ${this.size()}`);let e=this.tensors[t];if(e.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${t} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(e.cleared=!0),e.read=!0,e.tensor}readMany(t){return t.map(e=>this.read(e))}write(t,e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(t<0||!this.dynamicSize&&t>=this.maxSize)throw new Error(`Tried to write to index ${t}, but array is not resizeable and size is: ${this.maxSize}`);let n=this.tensors[t]||{};if(e.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t},
          because the value dtype is ${e.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=e.shape),Gn(this.elementShape,e.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${t}.`),n.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been read.`);if(n.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been written.`);n.tensor=e,Pe(e),n.written=!0,this.tensors[t]=n}writeMany(t,e){if(t.length!==e.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${t.length} is not the same as tensors size: ${e.length}.`);t.forEach((n,o)=>this.write(n,e[o]))}gather(t,e){if(!!e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${e}`);if(t)t=t.slice(0,this.size());else{t=[];for(let o=0;o<this.size();o++)t.push(o)}if(t.length===0)return Ar([],[0].concat(this.elementShape));let n=this.readMany(t);return Gn(this.elementShape,n[0].shape,"TensorArray shape mismatch: "),Je(n,0)}concat(t){if(!!t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${t}`);if(this.size()===0)return Ar([],[0].concat(this.elementShape));let e=[];for(let o=0;o<this.size();o++)e.push(o);let n=this.readMany(e);return Gn(this.elementShape,n[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${n[0].shape})`),se(n,0)}scatter(t,e){if(e.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${e.dtype}`);if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);let n=Math.max(...t);if(!this.dynamicSize&&n>=this.maxSize)throw new Error(`Max index must be < array size (${n}  vs. ${this.maxSize})`);this.writeMany(t,vr(e,0))}split(t,e){if(e.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${e.dtype}`);let n=0,o=t.map(u=>(n+=u,n));if(n!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${n}, and tensor's shape is: ${e.shape}`);if(!this.dynamicSize&&t.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${t.length}), and the TensorArray is not marked as dynamically resizeable`);let s=n===0?0:e.size/n,i=[];B(()=>{e=O(e,[1,n,s]);for(let u=0;u<t.length;++u){let l=u===0?0:o[u-1],c=[0,l,0],p=[1,t[u],s];i[u]=O(Rt(e,c,p),this.elementShape)}return i});let a=[];for(let u=0;u<t.length;u++)a[u]=u;this.writeMany(a,i)}};var fu=class{constructor(t,e,n,o=-1){this.tensors=t,this.elementShape=e,this.elementDtype=n,t!=null&&t.forEach(s=>{if(n!==s.dtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${s.dtype}`);Gn(e,s.shape,"TensorList shape mismatch: "),Pe(s)}),this.idTensor=pt(0),this.maxNumElements=o,Pe(this.idTensor)}get id(){return this.idTensor.id}copy(){return new fu([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(t){this.tensors.forEach(e=>{(t==null||!t.has(e.id))&&e.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(t,e,n=-1){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);if(n!==-1&&this.tensors.length!==n)throw new Error(`Operation expected a list with ${n} elements but got a list with ${this.tensors.length} elements.`);Gn(t,this.elementShape,"TensorList shape mismatch: ");let o=Uf(this.elementShape,this.tensors,t);return B(()=>{let s=this.tensors.map(i=>O(i,o));return Je(s,0)})}popBack(t,e){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");let n=Uf(this.elementShape,this.tensors,t),o=this.tensors.pop();return Gn(o.shape,t,"TensorList shape mismatch: "),O(o,n)}pushBack(t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(Gn(t.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");Pe(t),this.tensors.push(t)}resize(t){if(t<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${t}`);if(this.maxNumElements!==-1&&t>this.maxNumElements)throw new Error(`TensorListResize input size ${t} is greater maxNumElement ${this.maxNumElements}.`);this.tensors.length=t}getItem(t,e,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(t<0||t>this.tensors.length)throw new Error(`Trying to access element ${t} in a list with ${this.tensors.length} elements.`);if(this.tensors[t]==null)throw new Error(`element at index ${t} is null.`);Gn(this.tensors[t].shape,e,"TensorList shape mismatch: ");let o=Uf(this.elementShape,this.tensors,e);return O(this.tensors[t],o)}setItem(t,e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(t<0||this.maxNumElements!==-1&&t>=this.maxNumElements)throw new Error(`Trying to set element ${t} in a list with max ${this.maxNumElements} elements.`);Gn(this.elementShape,e.shape,"TensorList shape mismatch: "),Pe(e),this.tensors[t]=e}gather(t,e,n){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);Gn(this.elementShape,n,"TensorList shape mismatch: "),t=t.slice(0,this.size());let o=Uf(this.elementShape,this.tensors,n);return t.length===0?Ar([],[0].concat(o)):B(()=>{let s=t.map(i=>O(this.tensors[i],o));return Je(s,0)})}concat(t,e){if(!!t&&t!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${t}`);Gn(this.elementShape,e,"TensorList shape mismatch: ");let n=Uf(this.elementShape,this.tensors,e);return this.size()===0?Ar([],[0].concat(n)):B(()=>{let o=this.tensors.map(s=>O(s,n));return se(o,0)})}};function xD(r,t,e){let n=r.dtype;if(r.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${r.shape}`);if(r.dtype!==e)throw new Error(`Invalid data types; op elements ${r.dtype}, but list elements ${e}`);let o=r.shape.slice(1);Gn(o,t,"TensorList shape mismatch: ");let s=vr(r);return new fu(s,t,n)}function yD(r,t,e){return new fu([],r,t,e)}function bD(r,t,e,n){if(t.length!==r.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${r.shape[0]}`);let o=Math.max(...t);if(n!=null&&n!==-1&&o>=n)throw new Error(`Max index must be < array size (${o}  vs. ${n})`);let s=new fu([],e,r.dtype,n),i=vr(r,0);return t.forEach((a,u)=>{s.setItem(a,i[u])}),s}function wD(r,t,e){let n=0,o=t.map(c=>(n+=c,n));if(n!==r.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${n}, and tensor's shape is: ${r.shape}`);let s=r.shape.slice(1),i=wb(s,e),a=n===0?0:r.size/n,u=B(()=>{let c=[];r=O(r,[1,n,a]);for(let p=0;p<t.length;++p){let m=p===0?0:o[p-1],f=[0,m,0],d=[1,t[p],a];c[p]=O(Rt(r,f,d),i)}return r.dispose(),c}),l=new fu([],e,r.dtype,t.length);for(let c=0;c<u.length;c++)l.setItem(c,u[c]);return l}var vD=async(r,t,e)=>{switch(r.op){case"If":case"StatelessIf":{let n=I("thenBranch",r,t,e),o=I("elseBranch",r,t,e),s=I("cond",r,t,e),i=I("args",r,t,e);return(await s.data())[0]?e.functionMap[n].executeFunctionAsync(i,e.tensorArrayMap,e.tensorListMap):e.functionMap[o].executeFunctionAsync(i,e.tensorArrayMap,e.tensorListMap)}case"While":case"StatelessWhile":{let n=I("body",r,t,e),o=I("cond",r,t,e),s=I("args",r,t,e),i=await e.functionMap[o].executeFunctionAsync(s,e.tensorArrayMap,e.tensorListMap),a=s.map(c=>c.id),u=await i[0].data();i.forEach(c=>{!c.kept&&a.indexOf(c.id)===-1&&c.dispose()});let l=s;for(;u[0];){let c=l;l=await e.functionMap[n].executeFunctionAsync(l,e.tensorArrayMap,e.tensorListMap);let p=l.map(f=>f.id);c.forEach(f=>{!f.kept&&a.indexOf(f.id)===-1&&p.indexOf(f.id)===-1&&f.dispose()});let m=await e.functionMap[o].executeFunctionAsync(l,e.tensorArrayMap,e.tensorListMap);u=await m[0].data(),m.forEach(f=>{!f.kept&&a.indexOf(f.id)===-1&&p.indexOf(f.id)===-1&&f.dispose()})}return l}case"LoopCond":{let n=I("pred",r,t,e);return[pi(n)]}case"Switch":{let n=I("pred",r,t,e),o=I("data",r,t,e);return o.kept||(o=pi(o)),(await n.data())[0]?[void 0,o]:[o,void 0]}case"Merge":{let n=r.inputNames.find(o=>Cr(o,t,e)!==void 0);if(n){let o=Cr(n,t,e);return[pi(o)]}return}case"Enter":{let n=I("frameName",r,t,e),o=I("tensor",r,t,e);return e.enterFrame(n),[pi(o)]}case"Exit":{let n=I("tensor",r,t,e);return e.exitFrame(),[pi(n)]}case"NextIteration":{let n=I("tensor",r,t,e);return e.nextIteration(),[pi(n)]}case"TensorArrayV3":{let n=I("size",r,t,e),o=I("dtype",r,t,e),s=I("elementShape",r,t,e),i=I("dynamicSize",r,t,e),a=I("clearAfterRead",r,t,e),u=I("identicalElementShapes",r,t,e),l=I("name",r,t,e),c=new vb(l,o,n,s,u,i,a);return e.addTensorArray(c),[c.idTensor,pt(1)]}case"TensorArrayWriteV3":{let n=I("tensorArrayId",r,t,e),o=I("index",r,t,e),s=I("tensor",r,t,e),i=e.getTensorArray(n.id);return i.write(o,s),[i.idTensor]}case"TensorArrayReadV3":{let n=I("tensorArrayId",r,t,e),o=I("index",r,t,e);return[e.getTensorArray(n.id).read(o)]}case"TensorArrayGatherV3":{let n=I("tensorArrayId",r,t,e),o=I("indices",r,t,e),s=I("dtype",r,t,e);return[e.getTensorArray(n.id).gather(o,s)]}case"TensorArrayScatterV3":{let n=I("tensorArrayId",r,t,e),o=I("indices",r,t,e),s=I("tensor",r,t,e),i=e.getTensorArray(n.id);return i.scatter(o,s),[i.idTensor]}case"TensorArrayConcatV3":{let n=I("tensorArrayId",r,t,e),o=e.getTensorArray(n.id),s=I("dtype",r,t,e);return[o.concat(s)]}case"TensorArraySplitV3":{let n=I("tensorArrayId",r,t,e),o=I("tensor",r,t,e),s=I("lengths",r,t,e),i=e.getTensorArray(n.id);return i.split(s,o),[i.idTensor]}case"TensorArraySizeV3":{let n=I("tensorArrayId",r,t,e),o=e.getTensorArray(n.id);return[pt(o.size(),"int32")]}case"TensorArrayCloseV3":{let n=I("tensorArrayId",r,t,e),o=e.getTensorArray(n.id);return o.clearAndClose(),[o.idTensor]}case"TensorListSetItem":{let n=I("tensorListId",r,t,e),o=I("index",r,t,e),s=I("tensor",r,t,e),i=e.getTensorList(n.id);return i.setItem(o,s),[i.idTensor]}case"TensorListGetItem":{let n=I("tensorListId",r,t,e),o=I("index",r,t,e),s=I("elementShape",r,t,e),i=I("elementDType",r,t,e);return[e.getTensorList(n.id).getItem(o,s,i)]}case"TensorListScatterV2":case"TensorListScatter":{let n=I("indices",r,t,e),o=I("tensor",r,t,e),s=I("elementShape",r,t,e),i=I("numElements",r,t,e),a=bD(o,n,s,i);return e.addTensorList(a),[a.idTensor]}case"TensorListReserve":case"EmptyTensorList":{let n=I("elementShape",r,t,e),o=I("elementDType",r,t,e),s;r.op==="TensorListReserve"?s="numElements":s="maxNumElements";let i=I(s,r,t,e),a=yD(n,o,i);return e.addTensorList(a),[a.idTensor]}case"TensorListGather":{let n=I("tensorListId",r,t,e),o=I("indices",r,t,e),s=I("elementShape",r,t,e),i=I("elementDType",r,t,e);return[e.getTensorList(n.id).gather(o,i,s)]}case"TensorListStack":{let n=I("tensorListId",r,t,e),o=I("elementShape",r,t,e),s=I("elementDType",r,t,e),i=I("numElements",r,t,e);return[e.getTensorList(n.id).stack(o,s,i)]}case"TensorListFromTensor":{let n=I("tensor",r,t,e),o=I("elementShape",r,t,e),s=I("elementDType",r,t,e),i=xD(n,o,s);return e.addTensorList(i),[i.idTensor]}case"TensorListConcat":{let n=I("tensorListId",r,t,e),o=e.getTensorList(n.id),s=I("dtype",r,t,e),i=I("elementShape",r,t,e);return[o.concat(s,i)]}case"TensorListPushBack":{let n=I("tensorListId",r,t,e),o=I("tensor",r,t,e),s=e.getTensorList(n.id);return s.pushBack(o),[s.idTensor]}case"TensorListPopBack":{let n=I("tensorListId",r,t,e),o=I("elementShape",r,t,e),s=I("elementDType",r,t,e);return[e.getTensorList(n.id).popBack(o,s)]}case"TensorListSplit":{let n=I("tensor",r,t,e),o=I("elementShape",r,t,e),s=I("lengths",r,t,e),i=wD(n,s,o);return e.addTensorList(i),[i.idTensor]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};function CD(r,t,e){let[n,o]=I("fusedOps",r,t,e),s=n==="biasadd",i=!s,a=o==="prelu",u=n==="fusedbatchnorm",l=I("numArgs",r,t,e);if(s){if(a&&l!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&s&&l!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(u)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");let c=I("strides",r,t,e),p=ng(r,t,e),m=I("dataFormat",r,t,e).toUpperCase(),f=I("dilations",r,t,e),[d,h]=I("args",r,t,e);i&&(h=d,d=void 0);let g=I("leakyreluAlpha",r,t,e);return{stride:c,pad:p,dataFormat:m,dilations:f,biasArg:d,preluArg:h,activationFunc:o,leakyreluAlpha:g}}var ID=(r,t,e)=>{switch(r.op){case"Conv1D":{let n=I("stride",r,t,e),o=I("pad",r,t,e),s=I("dataFormat",r,t,e).toUpperCase(),i=I("dilation",r,t,e);return[Yu(I("x",r,t,e),I("filter",r,t,e),n,o,s,i)]}case"Conv2D":{let n=I("strides",r,t,e),o=ng(r,t,e),s=I("dataFormat",r,t,e).toUpperCase(),i=I("dilations",r,t,e);return[pn(I("x",r,t,e),I("filter",r,t,e),[n[1],n[2]],o,s,[i[1],i[2]])]}case"_FusedConv2D":{let{stride:n,pad:o,dataFormat:s,dilations:i,biasArg:a,preluArg:u,activationFunc:l,leakyreluAlpha:c}=CD(r,t,e);return[Co.conv2d({x:I("x",r,t,e),filter:I("filter",r,t,e),strides:[n[1],n[2]],pad:o,dataFormat:s,dilations:[i[1],i[2]],bias:a,activation:l,preluActivationWeights:u,leakyreluAlpha:c})]}case"FusedDepthwiseConv2dNative":{let{stride:n,pad:o,dataFormat:s,dilations:i,biasArg:a,preluArg:u,activationFunc:l,leakyreluAlpha:c}=CD(r,t,e);return[Co.depthwiseConv2d({x:I("x",r,t,e),filter:I("filter",r,t,e),strides:[n[1],n[2]],pad:o,dataFormat:s,dilations:[i[1],i[2]],bias:a,activation:l,preluActivationWeights:u,leakyreluAlpha:c})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{let n=I("outputShape",r,t,e),o=I("strides",r,t,e),s=ng(r,t,e);return[Zu(I("x",r,t,e),I("filter",r,t,e),n,[o[1],o[2]],s)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{let n=I("strides",r,t,e),o=ng(r,t,e),s=I("dilations",r,t,e),i=I("dataFormat",r,t,e).toUpperCase();return[Ys(I("input",r,t,e),I("filter",r,t,e),[n[1],n[2]],o,i,[s[1],s[2]])]}case"Conv3D":{let n=I("strides",r,t,e),o=I("pad",r,t,e),s=I("dataFormat",r,t,e).toUpperCase(),i=I("dilations",r,t,e);return[gh(I("x",r,t,e),I("filter",r,t,e),[n[1],n[2],n[3]],o,s,[i[1],i[2],i[3]])]}case"AvgPool":{let n=I("strides",r,t,e),o=I("pad",r,t,e),s=I("kernelSize",r,t,e);return[qa(I("x",r,t,e),[s[1],s[2]],[n[1],n[2]],o)]}case"MaxPool":{let n=I("strides",r,t,e),o=I("pad",r,t,e),s=I("kernelSize",r,t,e);return[Qa(I("x",r,t,e),[s[1],s[2]],[n[1],n[2]],o)]}case"MaxPoolWithArgmax":{let n=I("strides",r,t,e),o=I("pad",r,t,e),s=I("kernelSize",r,t,e),i=I("includeBatchInIndex",r,t,e),{result:a,indexes:u}=YI(I("x",r,t,e),[s[1],s[2]],[n[1],n[2]],o,i);return[a,u]}case"AvgPool3D":{let n=I("strides",r,t,e),o=I("pad",r,t,e),s=I("kernelSize",r,t,e);return[fh(I("x",r,t,e),[s[1],s[2],s[3]],[n[1],n[2],n[3]],o)]}case"MaxPool3D":{let n=I("strides",r,t,e),o=I("pad",r,t,e),s=I("kernelSize",r,t,e);return[Th(I("x",r,t,e),[s[1],s[2],s[3]],[n[1],n[2],n[3]],o)]}case"Dilation2D":{let n=I("strides",r,t,e),o=I("pad",r,t,e),s=I("dilations",r,t,e),i=n[1],a=n[2],u=s[1],l=s[2];return[bh(I("x",r,t,e),I("filter",r,t,e),[i,a],o,[u,l],"NHWC")]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};var SD=(r,t,e)=>{switch(r.op){case"Fill":{let n=I("shape",r,t,e),o=I("dtype",r,t,e),s=I("value",r,t,e);return[Js(n,s,o)]}case"LinSpace":{let n=I("start",r,t,e),o=I("stop",r,t,e),s=I("num",r,t,e);return[WI(n,o,s)]}case"Multinomial":{let n=I("logits",r,t,e),o=I("numSamples",r,t,e),s=I("seed",r,t,e);return[ZI(n,o,s)]}case"OneHot":{let n=I("indices",r,t,e),o=I("depth",r,t,e),s=I("onValue",r,t,e),i=I("offValue",r,t,e);return[Ks(n,o,s,i)]}case"Ones":return[lr(I("shape",r,t,e),I("dtype",r,t,e))];case"OnesLike":return[dr(I("x",r,t,e))];case"RandomUniform":return[ei(I("shape",r,t,e),I("minval",r,t,e),I("maxval",r,t,e),I("dtype",r,t,e))];case"Range":{let n=I("start",r,t,e),o=I("stop",r,t,e),s=I("step",r,t,e);return[rl(n,o,s,I("dtype",r,t,e))]}case"TruncatedNormal":{let n=I("shape",r,t,e),o=I("mean",r,t,e),s=I("stdDev",r,t,e),i=I("seed",r,t,e);return[hc(n,o,s,I("dtype",r,t,e),i)]}case"Zeros":return[ye(I("shape",r,t,e),I("dtype",r,t,e))];case"ZerosLike":return[St(I("x",r,t,e))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};function pk(r,t,e){let n=I("boxes",r,t,e),o=I("scores",r,t,e),s=I("maxOutputSize",r,t,e),i=I("iouThreshold",r,t,e),a=I("scoreThreshold",r,t,e),u=I("softNmsSigma",r,t,e);return{boxes:n,scores:o,maxOutputSize:s,iouThreshold:i,scoreThreshold:a,softNmsSigma:u}}var kD=async(r,t,e)=>{switch(r.op){case"NonMaxSuppressionV5":{let{boxes:n,scores:o,maxOutputSize:s,iouThreshold:i,scoreThreshold:a,softNmsSigma:u}=pk(r,t,e),l=await dn.nonMaxSuppressionWithScoreAsync(n,o,s,i,a,u);return[l.selectedIndices,l.selectedScores]}case"NonMaxSuppressionV4":{let{boxes:n,scores:o,maxOutputSize:s,iouThreshold:i,scoreThreshold:a}=pk(r,t,e),u=I("padToMaxOutputSize",r,t,e),l=await dn.nonMaxSuppressionPaddedAsync(n,o,s,i,a,u);return[l.selectedIndices,l.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{let{boxes:n,scores:o,maxOutputSize:s,iouThreshold:i,scoreThreshold:a}=pk(r,t,e);return[await dn.nonMaxSuppressionAsync(n,o,s,i,a)]}case"Where":{let n=Z(I("condition",r,t,e),"bool"),o=[await zh(n)];return n.dispose(),o}case"ListDiff":return aS(I("x",r,t,e),I("y",r,t,e));default:throw TypeError(`Node type ${r.op} is not implemented`)}};var ND=(r,t,e)=>{switch(r.op){case"TopKV2":{let n=I("x",r,t,e),o=I("k",r,t,e),s=I("sorted",r,t,e),i=Ph(n,o,s);return[i.values,i.indices]}case"Unique":{let n=I("x",r,t,e),o=bm(n);return[o.values,o.indices]}case"UniqueV2":{let n=I("x",r,t,e),o=I("axis",r,t,e),s=bm(n,o);return[s.values,s.indices]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};var TD=(r,t,e)=>{switch(r.op){case"Const":return t[r.name];case"PlaceholderWithDefault":let n=I("default",r,t,e);return[Cr(r.name,t,e)||n];case"Placeholder":return[Cr(r.name,t,e)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{let l=I("x",r,t,e);return[pi(l)]}case"IdentityN":return I("x",r,t,e).map(l=>pi(l));case"Snapshot":let o=I("x",r,t,e);return[pi(o)];case"Shape":return[Re(I("x",r,t,e).shape,"int32")];case"ShapeN":return I("x",r,t,e).map(l=>Re(l.shape));case"Size":return[pt(I("x",r,t,e).size,"int32")];case"Rank":return[pt(I("x",r,t,e).rank,"int32")];case"NoOp":return[pt(1)];case"Print":let s=I("x",r,t,e),i=I("data",r,t,e),a=I("message",r,t,e),u=I("summarize",r,t,e);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(a);for(let l=0;l<i.length;l++)console.log(Array.prototype.slice.call(i[l].dataSync()).slice(0,u));return[s];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var Cb=class{constructor(t,e){this.keyDType=t,this.valueDType=e,this.handle=pt(0),this.tensorMap=new Map,Pe(this.handle)}get id(){return this.handle.id}clearAndClose(){this.tensorMap.forEach(t=>t.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return pt(this.size(),"int32")}async import(t,e){this.checkKeyAndValueTensor(t,e);let n=await t.data();return this.tensorMap.forEach(o=>o.dispose()),this.tensorMap.clear(),B(()=>{let o=vr(e),s=n.length,i=o.length;x.assert(s===i,()=>`The number of elements doesn't match, keys has ${s} elements, the values has ${i} elements.`);for(let a=0;a<s;a++){let u=n[a],l=o[a];Pe(l),this.tensorMap.set(u,l)}return this.handle})}async find(t,e){this.checkKeyAndValueTensor(t,e);let n=await t.data();return B(()=>{let o=[];for(let s=0;s<n.length;s++){let i=n[s],a=this.findWithDefault(i,e);o.push(a)}return Je(o)})}findWithDefault(t,e){let n=this.tensorMap.get(t);return n!=null?n:e}checkKeyAndValueTensor(t,e){if(t.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${t.dtype}`);if(e.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${e.dtype}`)}};var _D=async(r,t,e,n)=>{switch(r.op){case"HashTable":case"HashTableV2":{let o=I("keyDType",r,t,e),s=I("valueDType",r,t,e),i=new Cb(o,s);return n.addHashTable(r.name,i),[i.handle]}case"LookupTableImport":case"LookupTableImportV2":{let o=I("tableHandle",r,t,e,n),s=I("keys",r,t,e),i=I("values",r,t,e);return[await n.getHashTableById(o.id).import(s,i)]}case"LookupTableFind":case"LookupTableFindV2":{let o=I("tableHandle",r,t,e,n),s=I("keys",r,t,e),i=I("defaultValue",r,t,e);return[await n.getHashTableById(o.id).find(s,i)]}case"LookupTableSize":case"LookupTableSizeV2":{let o=I("tableHandle",r,t,e,n);return[n.getHashTableById(o.id).tensorSize()]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};var ED=(r,t,e)=>{switch(r.op){case"ResizeBilinear":{let n=I("images",r,t,e),o=I("size",r,t,e),s=I("alignCorners",r,t,e),i=I("halfPixelCenters",r,t,e);return[dn.resizeBilinear(n,[o[0],o[1]],s,i)]}case"ResizeNearestNeighbor":{let n=I("images",r,t,e),o=I("size",r,t,e),s=I("alignCorners",r,t,e),i=I("halfPixelCenters",r,t,e);return[dn.resizeNearestNeighbor(n,[o[0],o[1]],s,i)]}case"CropAndResize":{let n=I("image",r,t,e),o=I("boxes",r,t,e),s=I("boxInd",r,t,e),i=I("cropSize",r,t,e),a=I("method",r,t,e),u=I("extrapolationValue",r,t,e);return[dn.cropAndResize(n,o,s,i,a,u)]}case"ImageProjectiveTransformV3":{let n=I("images",r,t,e),o=I("transforms",r,t,e),s=I("outputShape",r,t,e),i=I("fillValue",r,t,e),a=I("interpolation",r,t,e),u=I("fillMode",r,t,e);return[dn.transform(n,o,a.toLowerCase(),u.toLowerCase(),i,s)]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};var AD=(r,t,e)=>{switch(r.op){case"Equal":return[Sr(I("a",r,t,e),I("b",r,t,e))];case"NotEqual":return[vo(I("a",r,t,e),I("b",r,t,e))];case"Greater":return[Ge(I("a",r,t,e),I("b",r,t,e))];case"GreaterEqual":return[Tn(I("a",r,t,e),I("b",r,t,e))];case"Less":return[ec(I("a",r,t,e),I("b",r,t,e))];case"LessEqual":return[_n(I("a",r,t,e),I("b",r,t,e))];case"LogicalAnd":return[Nr(I("a",r,t,e),I("b",r,t,e))];case"LogicalNot":return[Ja(I("a",r,t,e))];case"LogicalOr":return[nc(I("a",r,t,e),I("b",r,t,e))];case"Select":case"SelectV2":return[_e(I("condition",r,t,e),I("a",r,t,e),I("b",r,t,e))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var $D=(r,t,e)=>{switch(r.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[Lt(I("a",r,t,e),I("b",r,t,e),I("transposeA",r,t,e),I("transposeB",r,t,e))];case"Einsum":return[BI(I("equation",r,t,e),...I("tensors",r,t,e))];case"Transpose":return[Wt(I("x",r,t,e),I("perm",r,t,e))];case"_FusedMatMul":let[n,o]=I("fusedOps",r,t,e),s=n==="biasadd",i=o==="prelu",a=I("numArgs",r,t,e),u=I("leakyreluAlpha",r,t,e);if(s){if(i&&a!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!i&&a!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}let[l,c]=I("args",r,t,e);return[Co.matMul({a:I("a",r,t,e),b:I("b",r,t,e),transposeA:I("transposeA",r,t,e),transposeB:I("transposeB",r,t,e),bias:l,activation:o,preluActivationWeights:c,leakyreluAlpha:u})];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var DD=(r,t,e)=>{switch(r.op){case"FusedBatchNorm":case"FusedBatchNormV2":return[xo(I("x",r,t,e),I("mean",r,t,e),I("variance",r,t,e),I("offset",r,t,e),I("scale",r,t,e),I("epsilon",r,t,e))];case"FusedBatchNormV3":return[xo(I("x",r,t,e),I("mean",r,t,e),I("variance",r,t,e),I("offset",r,t,e),I("scale",r,t,e),I("epsilon",r,t,e))];case"LRN":return[Sh(I("x",r,t,e),I("radius",r,t,e),I("bias",r,t,e),I("alpha",r,t,e),I("beta",r,t,e))];case"Softmax":return[nl(I("x",r,t,e))];case"LogSoftmax":return[rc(I("x",r,t,e))];case"SparseToDense":return[Ux(I("sparseIndices",r,t,e),I("outputShape",r,t,e),I("sparseValues",r,t,e),I("defaultValue",r,t,e))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var RD=(r,t,e)=>{switch(r.op){case"Max":{let i=I("axis",r,t,e),a=I("keepDims",r,t,e);return[Dr(I("x",r,t,e),i,a)]}case"Mean":{let i=I("axis",r,t,e),a=I("keepDims",r,t,e);return[xe(I("x",r,t,e),i,a)]}case"Min":{let i=I("axis",r,t,e),a=I("keepDims",r,t,e);return[Zl(I("x",r,t,e),i,a)]}case"Sum":{let i=I("axis",r,t,e),a=I("keepDims",r,t,e);return[mt(I("x",r,t,e),i,a)]}case"All":{let i=I("axis",r,t,e),a=I("keepDims",r,t,e);return[Ku(I("x",r,t,e),i,a)]}case"Any":{let i=I("axis",r,t,e),a=I("keepDims",r,t,e);return[Yl(I("x",r,t,e),i,a)]}case"ArgMax":{let i=I("axis",r,t,e);return[js(I("x",r,t,e),i)]}case"ArgMin":{let i=I("axis",r,t,e);return[ah(I("x",r,t,e),i)]}case"Prod":{let i=I("axis",r,t,e),a=I("keepDims",r,t,e);return[oc(I("x",r,t,e),i,a)]}case"Cumprod":{let i=I("axis",r,t,e),a=I("exclusive",r,t,e),u=I("reverse",r,t,e);return[xh(I("x",r,t,e),i,a,u)]}case"Cumsum":{let i=I("axis",r,t,e),a=I("exclusive",r,t,e),u=I("reverse",r,t,e);return[Qu(I("x",r,t,e),i,a,u)]}case"Bincount":let n=I("x",r,t,e),o=I("weights",r,t,e),s=I("size",r,t,e);return[dh(n,o,s)];case"DenseBincount":{let i=I("x",r,t,e),a=I("weights",r,t,e),u=I("size",r,t,e),l=I("binaryOutput",r,t,e);return[LI(i,a,u,l)]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};var FD=(r,t,e)=>{switch(r.op){case"ConcatV2":case"Concat":{let n=I("n",r,t,e),o=I("axis",r,t,e),s=I("tensors",r,t,e);return s=s.slice(0,n),[se(s,o)]}case"Gather":{let n=I("x",r,t,e),o=I("indices",r,t,e);return[yo(n,Z(o,"int32"),0)]}case"GatherV2":{let n=I("axis",r,t,e),o=I("batchDims",r,t,e),s=I("x",r,t,e),i=I("indices",r,t,e);return[yo(s,Z(i,"int32"),n,o)]}case"Reverse":{let n=I("dims",r,t,e),o=[];for(let i=0;i<n.length;i++)n[i]&&o.push(i);let s=I("x",r,t,e);return[ir(s,o)]}case"ReverseV2":{let n=I("axis",r,t,e),o=I("x",r,t,e);return[ir(o,n)]}case"Slice":{let n=I("begin",r,t,e),o=I("size",r,t,e);return[Rt(I("x",r,t,e),n,o)]}case"StridedSlice":{let n=I("begin",r,t,e),o=I("end",r,t,e),s=I("strides",r,t,e),i=I("beginMask",r,t,e),a=I("endMask",r,t,e),u=I("ellipsisMask",r,t,e),l=I("newAxisMask",r,t,e),c=I("shrinkAxisMask",r,t,e),p=I("x",r,t,e);return[Oh(p,n,o,s,i,a,u,l,c)]}case"Pack":return B(()=>{let n=I("axis",r,t,e),o=I("tensors",r,t,e),s=o[0].shape,i=zr(o[0]).shape,a=o.map(u=>{let l=x.arraysEqual(u.shape,s);if(!l&&!x.arraysEqual(zr(u).shape,i))throw new Error("the input tensors shape does not match");return l?u:O(u,s)});return[Je(a,n)]});case"Unpack":{let n=I("axis",r,t,e),o=I("tensor",r,t,e);return vr(o,n)}case"Tile":{let n=I("reps",r,t,e);return[kr(I("x",r,t,e),n)]}case"Split":case"SplitV":{let n=I("axis",r,t,e),o=I("numOrSizeSplits",r,t,e),s=I("x",r,t,e);return ur(s,o,n)}case"ScatterNd":{let n=I("indices",r,t,e),o=I("values",r,t,e),s=I("shape",r,t,e);return[uE(n,o,s)]}case"GatherNd":{let n=I("x",r,t,e),o=I("indices",r,t,e);return[pE(n,o)]}case"SparseToDense":{let n=I("sparseIndices",r,t,e),o=I("outputShape",r,t,e),s=I("sparseValues",r,t,e),i=I("defaultValue",r,t,e);return[Ux(n,s,o,s.dtype===i.dtype?i:Z(i,s.dtype))]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};var OD=(r,t,e)=>{switch(r.op){case"SparseFillEmptyRows":{let{outputIndices:n,outputValues:o,emptyRowIndicator:s,reverseIndexMap:i}=Bh.sparseFillEmptyRows(I("indices",r,t,e),I("values",r,t,e),I("denseShape",r,t,e),I("defaultValue",r,t,e));return[n,o,s,i]}case"SparseReshape":{let{outputIndices:n,outputShape:o}=Bh.sparseReshape(I("inputIndices",r,t,e),I("inputShape",r,t,e),I("newShape",r,t,e));return[n,o]}case"SparseSegmentMean":return[Bh.sparseSegmentMean(I("data",r,t,e),I("indices",r,t,e),I("segmentIds",r,t,e))];case"SparseSegmentSum":return[Bh.sparseSegmentSum(I("data",r,t,e),I("indices",r,t,e),I("segmentIds",r,t,e))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var MD=(r,t,e)=>{switch(r.op){case"FFT":return[ol(I("x",r,t,e))];case"IFFT":return[Gi(I("x",r,t,e))];case"RFFT":return[sl(I("x",r,t,e))];case"IRFFT":return[fc(I("x",r,t,e))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var PD=(r,t,e)=>{switch(r.op){case"StringNGrams":{let{nGrams:n,nGramsSplits:o}=ey.stringNGrams(I("data",r,t,e),I("dataSplits",r,t,e),I("separator",r,t,e),I("nGramWidths",r,t,e),I("leftPad",r,t,e),I("rightPad",r,t,e),I("padWidth",r,t,e),I("preserveShortSequences",r,t,e));return[n,o]}case"StringSplit":{let{indices:n,values:o,shape:s}=ey.stringSplit(I("input",r,t,e),I("delimiter",r,t,e),I("skipEmpty",r,t,e));return[n,o,s]}case"StringToHashBucketFast":return[ey.stringToHashBucketFast(I("input",r,t,e),I("numBuckets",r,t,e))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var LD=(r,t,e)=>{switch(r.op){case"Cast":return[Z(I("x",r,t,e),I("dtype",r,t,e))];case"ExpandDims":{let n=I("axis",r,t,e);return[fr(I("x",r,t,e),n)]}case"Squeeze":{let n=I("axis",r,t,e);return[zr(I("x",r,t,e),n)]}case"Reshape":return[O(I("x",r,t,e),I("shape",r,t,e))];case"MirrorPad":return[_h(I("x",r,t,e),I("padding",r,t,e),I("mode",r,t,e))];case"PadV2":case"Pad":return[Yr(I("x",r,t,e),I("padding",r,t,e),I("constantValue",r,t,e))];case"SpaceToBatchND":{let n=I("blockShape",r,t,e),o=I("paddings",r,t,e);return[tl(I("x",r,t,e),n,o)]}case"BatchToSpaceND":{let n=I("blockShape",r,t,e),o=I("crops",r,t,e);return[Ka(I("x",r,t,e),n,o)]}case"DepthToSpace":{let n=I("blockSize",r,t,e),o=I("dataFormat",r,t,e).toUpperCase();return[yh(I("x",r,t,e),n,o)]}case"BroadcastTo":return[ja(I("x",r,t,e),I("shape",r,t,e))];case"BroadcastArgs":return[DI(I("s0",r,t,e),I("s1",r,t,e))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};function mk(r,t,e,n){let o=((s,i,a)=>{switch(s.category){case"arithmetic":return B(()=>dD(s,i,a));case"basic_math":return B(()=>hD(s,i,a));case"control":return vD(s,i,a);case"convolution":return B(()=>ID(s,i,a));case"creation":return B(()=>SD(s,i,a));case"dynamic":return kD(s,i,a);case"evaluation":return B(()=>ND(s,i,a));case"image":return B(()=>ED(s,i,a));case"graph":return B(()=>TD(s,i,a));case"logical":return B(()=>AD(s,i,a));case"matrices":return B(()=>$D(s,i,a));case"normalization":return B(()=>DD(s,i,a));case"reduction":return B(()=>RD(s,i,a));case"slice_join":return B(()=>FD(s,i,a));case"sparse":return B(()=>OD(s,i,a));case"spectral":return B(()=>MD(s,i,a));case"string":return B(()=>PD(s,i,a));case"transformation":return B(()=>LD(s,i,a));case"hash_table":return _D(s,i,a,n);case"custom":let u=ab(s.op);if(u&&u.customExecutor)return u.customExecutor(new bb(s,i,a));throw TypeError(`Custom op ${s.op} is not registered.`);default:throw TypeError(`Unknown op '${s.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(r,t,e);return x.isPromise(o)?o.then(s=>[].concat(s)):[].concat(o)}var sg=class{constructor(t={},e={},n={},o={}){this.weightMap=t,this.tensorArrayMap=e,this.tensorListMap=n,this.functionMap=o,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(t,e){return{id:t,frameName:e,iterationId:0}}set currentContext(t){this.contexts!==t&&(this.contexts=t,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){let t=[];for(let e=0;e<this.contexts.length-1;e++){let n=this.contexts.slice(0,this.contexts.length-e);t.push(this.contextIdforContexts(n))}t.push(""),this._currentContextIds=t}contextIdforContexts(t){return t?t.map(e=>e.id===0&&e.iterationId===0?"":`${e.frameName}-${e.iterationId}`).join("/"):""}enterFrame(t){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,t)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;let t=Object.assign({},this.contexts[this.contexts.length-1]);t.iterationId+=1,t.id=this.lastId,this.contexts.splice(-1,1,t),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(t){return this.weightMap[t]}addTensorArray(t){this.tensorArrayMap[t.id]=t}getTensorArray(t){return this.tensorArrayMap[t]}addTensorList(t){this.tensorListMap[t.id]=t}getTensorList(t){return this.tensorListMap[t]}dispose(t){for(let e in this.tensorArrayMap)this.tensorArrayMap[e].clearAndClose(t);for(let e in this.tensorListMap)this.tensorListMap[e].clearAndClose(t)}};function fk(r,t,e,n){let o=new Set,s=[],i=null,a=null,u=new Set,l=Object.keys(r).map(m=>Cn(m)[0]),c=[];n!=null&&(c=n.map(m=>Cn(m.name)[0]));let p=[...t];for(;p.length>0;){let m=p.pop();if((dk(m)||rZ(m)||nZ(m))&&i==null&&(i=m,a=i.children.map(f=>f.name).filter(f=>o.has(f))),o.add(m.name),e[m.name]==null&&l.indexOf(m.name)===-1&&c.indexOf(m.name)===-1){if(m.inputs.length===0){s.push(m.name);continue}m.inputs.forEach(f=>{u.has(f.name)||(u.add(f.name),p.push(f))})}}return{inputs:r,outputs:t,usedNodes:o,missingInputs:s,dynamicNode:i,syncInputs:a}}function zD(r,t,e){let{usedNodes:n,inputs:o}=e,s=[],i=Object.keys(o).map(c=>Cn(c)[0]).map(c=>r.nodes[c]),a=r.initNodes;i.forEach(c=>{n.has(c.name)&&s.push(c)}),r.weights.forEach(c=>{n.has(c.name)&&s.push(c)}),a!=null&&a.forEach(c=>{n.has(c.name)&&s.push(c)});let u=new Set,l=[];for(;s.length>0;){let c=s.pop();u.add(c.name),t[c.name]||l.push(c),c.children.forEach(p=>{!u.has(p.name)&&n.has(p.name)&&p.inputs.every(m=>u.has(m.name))&&s.push(p)})}return l}var Q7=["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"],tZ=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"],eZ=["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"];function dk(r){return Q7.indexOf(r.op)>=0}function rZ(r){return tZ.indexOf(r.op)>=0}function nZ(r){return eZ.indexOf(r.op)>=0}var Bc=class{constructor(t,e){this.graph=t,this.parent=e,this.compiledMap=new Map,this._weightMap={},this.SEPERATOR=",",this._functions={},this._functionExecutorMap={},this.intermediateTensors={},this.keepTensorForDebug=!1,this._outputs=t.outputs,this._inputs=t.inputs,this._initNodes=t.initNodes,this._signature=t.signature,this._functions=t.functions,t.functions!=null&&Object.keys(t.functions).forEach(n=>{this._functionExecutorMap[n]=new Bc(t.functions[n],this)})}get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(t){let e=Object.keys(t).map(n=>t[n].map(o=>o.id));this._weightIds=[].concat(...e),this._weightMap=t}set resourceManager(t){this._resourceManager=t}get inputs(){return this._inputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(t=>t.signatureKey||t.name)}get outputNodes(){return this._outputs.map(t=>{let e=t.signatureKey||t.name;return t.defaultOutput?`${e}:${t.defaultOutput}`:e})}get functions(){return Object.keys(this._functions).reduce((t,e)=>(t[e]=this._functions[e].signature,t),{})}getCompilationKey(t,e){let n=t.map(s=>s.name).sort(),o=e.map(s=>s.name).sort();return n.join(this.SEPERATOR)+"--"+o.join(this.SEPERATOR)}compile(t,e){let n=fk(t,e,this.weightMap,this._initNodes),{missingInputs:o,dynamicNode:s,syncInputs:i}=n;if(s!=null)throw new Error(`This execution contains the node '${s.name}', which has the dynamic op '${s.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${i}]`);if(o.length>0){let a=e.map(l=>l.name),u=Object.keys(t);throw new Error(`Cannot compute the outputs [${a}] from the provided inputs [${u}]. Missing the following inputs: [${o}]`)}return zD(this.graph,this.weightMap,n)}execute(t,e){t=this.mapInputs(t);let n=Object.keys(t).sort();this.checkInputs(t),this.checkInputShapeAndType(t),e=this.mapOutputs(e),this.checkOutputs(e);let o=n.map(p=>this.graph.nodes[Cn(p)[0]]),s=e.map(p=>Cn(p)[0]),i=s.map(p=>this.graph.nodes[p]);this.resetIntermediateTensors(),i.length===0&&(i=this._outputs);let a=this.getCompilationKey(o,i),u=this.compiledMap.get(a);u==null&&(u=this.compile(t,i),this.compiledMap.set(a,u));let l={},c={};return B(()=>{let p=new sg(this.weightMap,l,c,this.functionExecutorMap),m=Object.assign({},this.weightMap);Object.keys(t).forEach(h=>{let[g,y]=Cn(h),b=[];b[y]=t[h],m[g]=b});let f=this.getFrozenTensorIds(m),d={};for(let h=0;h<u.length;h++){let g=u[h];if(!m[g.name]){let y=mk(g,m,p,this._resourceManager);if(x.isPromise(y))throw new Error(`The execution of the op '${g.op}' returned a promise. Please use model.executeAsync() instead.`);m[g.name]=y,this.checkTensorForDisposal(g.name,g,m,p,f,s,d)}}return this.parent==null&&p.dispose(f),e.map(h=>Cr(h,m,p))})}getFrozenTensorIds(t){let e=[].concat.apply([],Object.keys(t).map(n=>t[n]).map(n=>n.map(o=>o.id)));return new Set(e)}checkTensorForDisposal(t,e,n,o,s,i,a){e.category==="control"||i.indexOf(t)!==-1||(n[t].forEach(u=>{u!=null&&(a[u.id]=(a[u.id]||0)+e.children.length)}),e.inputs.forEach(u=>{if(u.category!=="control"){let l=cD(u.name,n,o);l!=null&&l.forEach(c=>{if(c&&!c.kept&&!s.has(c.id)){let p=a[c.id];if(p===1){if(!this.keepTensorForDebug)c.dispose();else{let[m,f]=Do(e.name,o);this.intermediateTensors[m]?this.intermediateTensors[m][f]=c:(this.intermediateTensors[m]=[],this.intermediateTensors[m][f]=c)}delete a[c.id]}else p!=null&&a[c.id]--}})}}))}async executeAsync(t,e){return this._executeAsync(t,e)}disposeIntermediateTensors(){!this.intermediateTensors||(Object.keys(this.intermediateTensors).forEach(t=>this.intermediateTensors[t].forEach(e=>e.dispose())),this.disposeTensorsMap())}disposeTensorsMap(){!this.tensorsMap||Object.keys(this.tensorsMap).forEach(t=>{this.tensorsMap[t].forEach(n=>{n&&!n.kept&&!n.isDisposed&&!this.keepIds.has(n.id)&&n.dispose()})})}getIntermediateTensors(){return this.tensorsMap}resetIntermediateTensors(){for(let t in this.intermediateTensors)this.intermediateTensors[t].forEach(e=>e.dispose()),delete this.intermediateTensors[t]}async _executeAsync(t,e,n=!1,o={},s={}){n||(t=this.mapInputs(t),this.checkInputs(t),this.checkInputShapeAndType(t),e=this.mapOutputs(e),this.checkOutputs(e));try{this.keepTensorForDebug=V().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(c){console.warn(c.message)}this.resetIntermediateTensors();let i=new sg(this.weightMap,o,s,this.functionExecutorMap);this.tensorsMap=await this.executeWithControlFlow(t,i,e,n);let a=e.map(c=>Cr(c,this.tensorsMap,i)),u=a.map(c=>c.id),l=Object.keys(t).map(c=>t[c].id);return this.keepIds=new Set([...u,...l,...this.weightIds]),this.keepTensorForDebug||this.disposeTensorsMap(),this.parent==null&&i.dispose(this.keepIds),a}async executeFunctionAsync(t,e,n){let o=t.reduce((s,i,a)=>(s[this.inputs[a].name]=i,s),{});return this._executeAsync(o,this.outputNodes,!0,e,n)}async executeWithControlFlow(t,e,n,o){let s=Object.keys(t),i=s.map(w=>this.graph.nodes[Cn(w)[0]]),a=n.map(w=>Cn(w)[0]),u=a.map(w=>this.graph.nodes[w]);u.length===0&&(u=this._outputs);let{usedNodes:l,missingInputs:c,dynamicNode:p,syncInputs:m}=fk(t,u,this.weightMap,this._initNodes),f=[...i,...this.graph.weights,...this._initNodes||[]].map(w=>({node:w,contexts:e.currentContext})),d=Object.assign({},this.weightMap);Object.keys(t).forEach(w=>{let[v,k]=Cn(w),E=[];E[k]=t[w],d[v]=E});let h={},g=this.getFrozenTensorIds(d),y={};for(;f.length>0;){let w=this.processStack(i,f,e,d,y,g,a,h,l);await Promise.all(w)}p==null&&!o&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");let b=u.filter(w=>!dk(w)&&!Cr(w.name,d,e)).map(w=>w.name);if(b.length>0){let w="";throw p!=null&&(w=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${m}]`),new Error(`Cannot compute the outputs [${b}] from the provided inputs [${s}]. Consider providing the following inputs: [${c}]. ${w}`)}return d}processStack(t,e,n,o,s,i,a,u,l){let c=[];for(;e.length>0;){let p=e.pop();n.currentContext=p.contexts;let m="";if(p.node.op==="Enter"&&I("isConstant",p.node,o,n)&&([m]=Do(p.node.name,n)),o[p.node.name]==null){let f=mk(p.node,o,n,this._resourceManager);m||([m]=Do(p.node.name,n));let d=n.currentContext;x.isPromise(f)?c.push(f.then(h=>(o[m]=h,n.currentContext=d,this.checkTensorForDisposal(m,p.node,o,n,i,a,u),this.processChildNodes(p.node,e,n,o,s,l),h))):(o[m]=f,this.checkTensorForDisposal(m,p.node,o,n,i,a,u),this.processChildNodes(p.node,e,n,o,s,l))}else this.processChildNodes(p.node,e,n,o,s,l)}return c}processChildNodes(t,e,n,o,s,i){t.children.forEach(a=>{let[u]=Do(a.name,n);s[u]||!i.has(a.name)||(a.op==="Merge"?a.inputNames.some(l=>!!Cr(l,o,n))&&(s[u]=!0,e.push({contexts:n.currentContext,node:a})):a.inputNames.every(l=>!!Cr(l,o,n))&&(s[u]=!0,e.push({contexts:n.currentContext,node:a})))})}dispose(){Object.keys(this.weightMap).forEach(t=>this.weightMap[t].forEach(e=>e.dispose()))}checkInputShapeAndType(t){Object.keys(t).forEach(e=>{let n=t[e],[o]=Cn(e),s=this.graph.nodes[o];if(s.attrParams.shape&&s.attrParams.shape.value){let i=s.attrParams.shape.value,a=i.length===n.shape.length&&n.shape.every((u,l)=>i[l]===-1||i[l]===u);x.assert(a,()=>`The shape of dict['${s.name}'] provided in model.execute(dict) must be [${i}], but was [${n.shape}]`)}s.attrParams.dtype&&s.attrParams.dtype.value&&x.assert(n.dtype===s.attrParams.dtype.value,()=>`The dtype of dict['${s.name}'] provided in model.execute(dict) must be ${s.attrParams.dtype.value}, but was ${n.dtype}`)})}mapInputs(t){let e={};for(let n in t)if(this._signature!=null&&this._signature.inputs!=null&&this._signature.inputs[n]!=null){let o=this._signature.inputs[n];e[o.name]=t[n]}else e[n]=t[n];return e}checkInputs(t){let e=Object.keys(t).filter(n=>{let[o]=Cn(n);return this.graph.nodes[o]==null});if(e.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${e}] that are not part of graph`)}mapOutputs(t){return t.map(e=>this._signature!=null&&this._signature.outputs!=null&&this._signature.outputs[e]!=null?this._signature.outputs[e].name:e,{})}checkOutputs(t){t.forEach(e=>{let[n]=Cn(e);if(!this.graph.nodes[n])throw new Error(`The output '${e}' is not found in the graph`)})}};var Ib=class{constructor(t={},e={}){this.hashTableNameToHandle=t,this.hashTableMap=e}addHashTable(t,e){this.hashTableNameToHandle[t]=e.handle,this.hashTableMap[e.id]=e}getHashTableHandleByName(t){return this.hashTableNameToHandle[t]}getHashTableById(t){return this.hashTableMap[t]}dispose(){for(let t in this.hashTableMap)this.hashTableMap[t].clearAndClose(),delete this.hashTableMap[t];for(let t in this.hashTableNameToHandle)this.hashTableNameToHandle[t].dispose(),delete this.hashTableNameToHandle[t]}};var oZ="?tfjs-format=file",sZ="model.json",Sb=class{constructor(t,e={}){this.modelUrl=t,this.loadOptions=e,this.version="n/a",e==null&&(this.loadOptions={}),this.resourceManager=new Ib}get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}findIOHandler(){let t=this.modelUrl;if(t.load!=null)this.handler=t;else if(this.loadOptions.requestInit!=null)this.handler=Mr.browserHTTPRequest(t,this.loadOptions);else{let e=Mr.getLoadHandlers(t,this.loadOptions);if(e.length===0)e.push(Mr.browserHTTPRequest(t,this.loadOptions));else if(e.length>1)throw new Error(`Found more than one (${e.length}) load handlers for URL '${[t]}'`);this.handler=e[0]}}async load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let t=await this.handler.load();return this.loadSync(t)}loadSync(t){this.artifacts=t;let e=this.artifacts.modelTopology,n;this.artifacts.userDefinedMetadata!=null&&this.artifacts.userDefinedMetadata.signature!=null?n=this.artifacts.userDefinedMetadata.signature:n=this.artifacts.signature,this.signature=n,this.version=`${e.versions.producer}.${e.versions.minConsumer}`;let o=Mr.decodeWeights(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new Bc(og.Instance.transformGraph(e,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(o),this.executor.resourceManager=this.resourceManager,t.modelInitializer!=null&&t.modelInitializer.node!=null){let s=og.Instance.transformGraph(t.modelInitializer);this.initializer=new Bc(s),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializer.executeAsync({},[])}return!0}async save(t,e){if(typeof t=="string"){let n=Mr.getSaveHandlers(t);if(n.length===0)throw new Error(`Cannot find any save handlers for URL '${t}'`);if(n.length>1)throw new Error(`Found more than one (${n.length}) save handlers for URL '${t}'`);t=n[0]}if(t.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return t.save(this.artifacts)}predict(t,e){return this.execute(t,this.outputNodes)}normalizeInputs(t){if(!(t instanceof Pt)&&!Array.isArray(t))return t;if(t=Array.isArray(t)?t:[t],t.length!==this.inputNodes.length)throw new Error(`Input tensor count mismatch,the graph model has ${this.inputNodes.length} placeholders, while there are ${t.length} input tensors.`);return this.inputNodes.reduce((e,n,o)=>(e[n]=t[o],e),{})}normalizeOutputs(t){return t=t||this.outputNodes,Array.isArray(t)?t:[t]}execute(t,e){t=this.normalizeInputs(t),e=this.normalizeOutputs(e);let n=this.executor.execute(t,e);return n.length>1?n:n[0]}async executeAsync(t,e){t=this.normalizeInputs(t),e=this.normalizeOutputs(e);let n=await this.executor.executeAsync(t,e);return n.length>1?n:n[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(t){return Object.keys(t).reduce((e,n)=>(e[n]=[t[n]],e),{})}dispose(){this.executor.dispose(),this.initializer&&this.initializer.dispose(),this.resourceManager.dispose()}};async function iZ(r,t={}){if(r==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");t==null&&(t={}),t.fromTFHub&&r.load==null&&(r.endsWith("/")||(r=r+"/"),r=`${r}${sZ}${oZ}`);let e=new Sb(r,t);return await e.load(),e}var BD="3.15.0";var vR={};Yt(vR,{CSVDataset:()=>Kf,Dataset:()=>mi,FileDataSource:()=>Jf,TextLineDataset:()=>qf,URLDataSource:()=>Qf,array:()=>pR,csv:()=>gR,func:()=>xR,generator:()=>yR,microphone:()=>wR,version_data:()=>Gk,webcam:()=>bR,zip:()=>mR});var cR=Du(vk());var aR=Du(vk());function rR(r,t){return Nb(r,t)}function Nb(r,t,e=new Map,n=new Set){if(r==null)return null;if(typeof Blob=="function"&&r instanceof Blob)return r.slice();if(n.has(r))throw new Error("Circular references are not supported.");if(e.has(r))return e.get(r);let o=t(r);if(o.recurse&&o.value!==null)throw new Error("A deep map function may not return both a value and recurse=true.");if(o.recurse)if(du(r)){let s=Array.isArray(r)?[]:{};n.add(r);for(let i in r){let a=r[i],u=Nb(a,t,e,n);s[i]=u}return n.delete(r),r.__proto__&&(s.__proto__=r.__proto__),s}else throw new Error(`Can't recurse into non-iterable type: ${r}`);else return e.set(r,o.value),o.value}function nR(r,t=Ik){return oR(r,t)}function oR(r,t,e=new Set){let n=r[0];if(e.has(n))throw new Error("Circular references are not supported.");let o=t(r);if(o.recurse&&o.value!==null)throw new Error("A deep zip function may not return both a value and recurse=true.");if(o.recurse)if(du(n)){let s=Array.isArray(n)?[]:{};e.add(n);for(let i in n){let a=r.map(l=>l[i]),u=oR(a,t,e);s[i]=u}return e.delete(n),s}else throw new Error(`Can't recurse into non-iterable type: ${n}`);else return o.value}function Ik(r){return r===null?null:du(r[0])?{value:null,recurse:!0}:{value:r,recurse:!1}}async function Tb(r,t){let e=new Map;Nb(r,t,e);for(let o of Array.from(e.keys())){let s=e.get(o);if(x.isPromise(s)){let i=await s;e.set(o,i)}}return Nb(r,t,e)}function du(r){let t=!1;if(V().get("IS_BROWSER"))t=r instanceof TextDecoder;else{let{StringDecoder:e}=Ck();t=r instanceof e}return r!=null&&!ArrayBuffer.isView(r)&&(Array.isArray(r)||typeof r=="object"&&!(r instanceof Pt)&&!(r instanceof Promise)&&!t)}function sR(r){return r==null||fZ(r)||Array.isArray(r)||typeof r=="object"&&r instanceof Pt||x.isTypedArray(r)}function fZ(r){return r===null||typeof r!="object"&&typeof r!="function"}function iR(r){return rR(r,dZ)}function dZ(r){return r instanceof Pt?{value:r.clone(),recurse:!1}:du(r)?{value:null,recurse:!0}:{value:r,recurse:!1}}var Hf=class{constructor(t){if(this.capacity=t,this.begin=0,this.end=0,t==null)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(t<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(t),this.doubledCapacity=2*t}wrap(t){for(;t<0;)t+=this.doubledCapacity;return t%this.doubledCapacity}get(t){if(t<0)throw new RangeError("Can't get item at a negative index.");return this.data[t%this.capacity]}set(t,e){if(t<0)throw new RangeError("Can't set item at a negative index.");this.data[t%this.capacity]=e}length(){let t=this.end-this.begin;return t<0&&(t=this.doubledCapacity+t),t}isFull(){return this.length()===this.capacity}isEmpty(){return this.length()===0}push(t){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,t),this.end=this.wrap(this.end+1)}pushAll(t){for(let e of t)this.push(e)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);let t=this.get(this.end);return this.set(this.end,void 0),t}unshift(t){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,t)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let t=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),t}shuffleExcise(t){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let e=this.wrap(this.begin+t),n=this.get(e);return this.set(e,this.pop()),n}};var Gc=class extends Hf{constructor(){super(Gc.INITIAL_CAPACITY)}isFull(){return!1}push(t){super.isFull()&&this.expand(),super.push(t)}unshift(t){super.isFull()&&this.expand(),super.unshift(t)}expand(){let t=this.capacity*2,e=new Array(t),n=this.length();for(let o=0;o<n;o++)e[o]=this.get(this.wrap(this.begin+o));this.data=e,this.capacity=t,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=n}};Gc.INITIAL_CAPACITY=32;function Mk(r){return new Sk(r)}function ig(r){return new kk(r)}function lR(r,t){return new Eb(r,t)}function uR(r,t=xl.FAIL){return new Fk(r,t)}var rr=class{async toArray(){let t=[],e=await this.next();for(;!e.done;)t.push(e.value),e=await this.next();return t}async toArrayForTest(){let t=this.prefetch(100),e=[],n=await t.next();for(;!n.done;)e.push(n.value),n=await t.next();return e}async resolveFully(){let t=await this.next();for(;!t.done;)t=await this.next()}async resolveWhile(t){let e=await this.next(),n=t(e.value);for(;!e.done&&n;)e=await this.next(),n=t(e.value)}handleErrors(t){return new Dk(this,t)}filter(t){return new Ak(this,t)}map(t){return new $k(this,t)}mapAsync(t){return new _b(this,t)}serialMapAsync(t){return new _b(this,t).serial()}flatmap(t){return new Rk(this,t)}async forEachAsync(t){return this.map(t).resolveFully()}async serialForEach(t){return this.serialMapAsync(t).resolveWhile(e=>e===!0)}rowMajorBatch(t,e=!0){return new Ek(this,t,e)}columnMajorBatch(t,e=!0,n=Ik){return this.rowMajorBatch(t,e).map(s=>nR(s,n))}concatenate(t,e){return new Eb(Mk([this,t]),e)}take(t){return t<0||t==null?this:new _k(this,t)}skip(t){return t<0||t==null?this:new Tk(this,t)}prefetch(t){return new Ab(this,t)}shuffle(t,e){return new Ok(this,t,e)}serial(){return new Nk(this)}},Sk=class extends rr{constructor(t){super(),this.items=t,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};let t=this.items[this.trav];return this.trav++,{value:iR(t),done:!1}}},kk=class extends rr{constructor(t){super(),this.nextFn=t}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(t){throw t.message=`Error thrown while iterating through a dataset: ${t.message}`,t}}},Nk=class extends rr{constructor(t){super(),this.upstream=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){return this.upstream.next()}},Tk=class extends rr{constructor(t,e){super(),this.upstream=t,this.maxCount=e,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){let t=await this.upstream.next();if(t.done)return t;_t(t.value)}return this.upstream.next()}},_k=class extends rr{constructor(t,e){super(),this.upstream=t,this.maxCount=e,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}},Ek=class extends rr{constructor(t,e,n=!0){super(),this.upstream=t,this.batchSize=e,this.enableSmallLastBatch=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){let t=[];for(;t.length<this.batchSize;){let e=await this.upstream.next();if(e.done)return this.enableSmallLastBatch&&t.length>0?{value:t,done:!1}:{value:null,done:!0};t.push(e.value)}return{value:t,done:!1}}},Ak=class extends rr{constructor(t,e){super(),this.upstream=t,this.predicate=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;){let t=await this.upstream.next();if(t.done||this.predicate(t.value))return t;_t(t.value)}}},$k=class extends rr{constructor(t,e){super(),this.upstream=t,this.transform=e}summary(){return`${this.upstream.summary()} -> Map`}async next(){let t=await this.upstream.next();if(t.done)return{value:null,done:!0};let e=fo.getTensorsInContainer(t.value),n=this.transform(t.value),o=fo.getTensorsInContainer(n);for(let s of e)fo.isTensorInList(s,o)||s.dispose();return{value:n,done:!1}}},Dk=class extends rr{constructor(t,e){super(),this.upstream=t,this.handler=e,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(t){if(!this.handler(t))return{value:null,done:!0}}}},_b=class extends rr{constructor(t,e){super(),this.upstream=t,this.transform=e}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){let t=await this.upstream.next();if(t.done)return{value:null,done:!0};let e=fo.getTensorsInContainer(t.value),n=await this.transform(t.value),o=fo.getTensorsInContainer(n);for(let s of e)fo.isTensorInList(s,o)||s.dispose();return{value:n,done:!1}}},Wc=class extends rr{constructor(){super(),this.outputQueue=new Gc,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.outputQueue.length()===0;)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}},Rk=class extends Wc{constructor(t,e){super(),this.upstream=t,this.transform=e}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){let t=await this.upstream.next();if(t.done)return!1;let e=fo.getTensorsInContainer(t.value),n=this.transform(t.value),o=fo.getTensorsInContainer(n);this.outputQueue.pushAll(n);for(let s of e)fo.isTensorInList(s,o)||s.dispose();return!0}},Eb=class extends rr{constructor(t,e){super(),this.baseErrorHandler=e,this.lastRead=null,this.iterator=null,this.moreIterators=t}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(t){if(await t,this.iterator==null){let n=await this.moreIterators.next();if(n.done)return{value:null,done:!0};this.iterator=n.value,this.baseErrorHandler!=null&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}let e=await this.iterator.next();return e.done?(this.iterator=null,this.readFromChain(t)):e}},xl;(function(r){r[r.FAIL=0]="FAIL",r[r.SHORTEST=1]="SHORTEST",r[r.LONGEST=2]="LONGEST"})(xl||(xl={}));var Fk=class extends rr{constructor(t,e=xl.FAIL){super(),this.iterators=t,this.mismatchMode=e,this.count=0,this.currentPromise=null}summary(){return"{TODO: fill in upstream of zip summaries} -> Zip"}async nextState(t){await t;let e=0,n=0;function o(i){return i instanceof rr?{value:i.next().then(u=>(e++,u.done&&n++,u.value)),recurse:!1}:{value:null,recurse:!0}}let s=await Tb(this.iterators,o);if(e===n)return{value:null,done:!0};if(n>0)switch(this.mismatchMode){case xl.FAIL:throw new Error(`Zipped streams should have the same length. Mismatched at element ${this.count}.`);case xl.SHORTEST:return{value:null,done:!0};case xl.LONGEST:default:}return this.count++,{value:s,done:!1}}async next(){return this.currentPromise=this.nextState(this.currentPromise),this.currentPromise}},Ab=class extends rr{constructor(t,e){super(),this.upstream=t,this.bufferSize=e,this.buffer=new Hf(e)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){let t=this.upstream.next();this.buffer.push(t)}}next(){return this.refill(),this.buffer.shift()}},Ok=class extends Ab{constructor(t,e,n){super(t,e),this.upstream=t,this.windowSize=e,this.upstreamExhausted=!1,this.random=aR.alea(n||x.now().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}randomInt(t){return Math.floor(this.random()*t)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){let t=this.chooseIndex(),e=await this.buffer.shuffleExcise(t);if(e.done)this.upstreamExhausted=!0;else return this.refill(),e}return{value:null,done:!0}}};var mi=class{constructor(){this.size=null}batch(t,e=!0){let n=this;x.assert(t>0,()=>`batchSize needs to be positive, but it is
      ${t}`);let o;return this.size===1/0||this.size==null?o=this.size:e?o=Math.ceil(this.size/t):o=Math.floor(this.size/t),Dn(async()=>(await n.iterator()).columnMajorBatch(t,e,hZ),o)}concatenate(t){let e=this,n;return this.size===1/0||t.size===1/0?n=1/0:this.size!=null&&t.size!=null?n=this.size+t.size:n=null,Dn(async()=>(await e.iterator()).concatenate(await t.iterator()),n)}filter(t){let e=this,n;return this.size===1/0?n=1/0:n=null,Dn(async()=>(await e.iterator()).filter(o=>B(()=>t(o))),n)}async forEachAsync(t){return(await this.iterator()).forEachAsync(t)}map(t){let e=this;return Dn(async()=>(await e.iterator()).map(n=>B(()=>t(n))),this.size)}mapAsync(t){let e=this;return Dn(async()=>(await e.iterator()).mapAsync(t),this.size)}prefetch(t){if(t==null)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");let e=this;return Dn(async()=>(await e.iterator()).prefetch(t),this.size)}repeat(t){let e=this,n;return this.size!=null&&t>0?n=this.size*t:t===0?n=0:this.size!=null&&(t===void 0||t<0)?n=1/0:n=null,Dn(async()=>{let o=ig(async()=>({value:await e.iterator(),done:!1}));return lR(o.take(t))},n)}skip(t){let e=this,n;return this.size!=null&&t>=0&&this.size>=t?n=this.size-t:this.size!=null&&(this.size<t||t===void 0||t<0)?n=0:n=null,Dn(async()=>(await e.iterator()).skip(t),n)}shuffle(t,e,n=!0){if(t==null||t<0)throw this.size==null?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);let o=this,s=cR.alea(e||x.now().toString());return Dn(async()=>{let i=s.int32();return n&&(i+=s.int32()),(await o.iterator()).shuffle(t,i.toString())},this.size)}take(t){let e=this,n;return this.size!=null&&this.size>t?n=t:this.size!=null&&this.size<=t?n=this.size:n=null,Dn(async()=>(await e.iterator()).take(t),n)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}};mi.MAX_BUFFER_SIZE=1e4;function Dn(r,t=null){return new class extends mi{constructor(){super(...arguments),this.size=t}async iterator(){return r()}}}function pR(r){return Dn(async()=>Mk(r),r.length)}function mR(r){if(!du(r))throw new Error("The argument to zip() must be an object or array.");let t;if(Array.isArray(r))for(let e=0;e<r.length;e++)t=t==null?r[e].size:Math.min(t,r[e].size);else if(r instanceof Object)for(let e in r)t=t==null?r[e].size:Math.min(t,r[e].size);return Dn(async()=>{let e=await Tb(r,n=>{if(n instanceof mi)return{value:n.iterator(),recurse:!1};if(du(n))return{value:null,recurse:!0};throw new Error("Leaves of the structure passed to zip() must be Datasets, not primitives.")});return uR(e,xl.SHORTEST)},t)}function hZ(r){if(r===null)return null;let t=r[0];return sR(t)?{value:gZ(r),recurse:!1}:{value:null,recurse:!0}}function gZ(r){if(r.length===0)throw new Error("Can't make a batch of zero elements.");return r[0]instanceof Pt?Je(r):Ar(r)}var qf=class extends mi{constructor(t){super(),this.input=t}async iterator(){return(await this.input.iterator()).decodeUTF8().split(`
`).map(o=>(o.endsWith("\r")&&(o=o.slice(0,-1)),o))}};var $b='"',ag=Symbol("out"),fR=Symbol("field"),Db=Symbol("quote"),Pk=Symbol("quoteafterquote"),dR=Symbol("quoteinquote"),Kf=class extends mi{constructor(t,e){super(),this.input=t,this.hasHeader=!0,this.fullColumnNames=null,this.columnNamesValidated=!1,this.columnConfigs=null,this.configuredColumnsOnly=!1,this.delimiter=",",this.delimWhitespace=!1,this.base=new qf(t),e||(e={}),this.hasHeader=e.hasHeader!==!1,this.fullColumnNames=e.columnNames,this.columnConfigs=e.columnConfigs,this.configuredColumnsOnly=e.configuredColumnsOnly,e.delimWhitespace?(x.assert(e.delimiter==null,()=>"Delimiter should not be provided when delimWhitespace is true."),this.delimWhitespace=!0,this.delimiter=" "):this.delimiter=e.delimiter?e.delimiter:","}async columnNames(){return this.columnNamesValidated||await this.setColumnNames(),this.configuredColumnsOnly?Object.keys(this.columnConfigs):this.fullColumnNames}async setColumnNames(){let t=await this.maybeReadHeaderLine();if(!this.fullColumnNames&&!t)throw new Error("Column names must be provided if there is no header line.");this.fullColumnNames&&t&&x.assert(t.length===this.fullColumnNames.length,()=>"The length of provided columnNames ("+this.fullColumnNames.length.toString()+") does not match the length of the header line read from file ("+t.length.toString()+")."),this.fullColumnNames||(this.fullColumnNames=t);let e=this.fullColumnNames.reduce((o,s)=>(o[s]=o[s]+1||1,o),{}),n=Object.keys(e).filter(o=>e[o]>1);if(x.assert(n.length===0,()=>"Duplicate column names found: "+n.toString()),this.columnConfigs){for(let o of Object.keys(this.columnConfigs))if(this.fullColumnNames.indexOf(o)===-1)throw new Error('The key "'+o+'" provided in columnConfigs does not match any of the column names ('+this.fullColumnNames.toString()+").")}this.columnNamesValidated=!0}async maybeReadHeaderLine(){if(this.hasHeader){let e=await(await this.base.iterator()).next();if(e.done)throw new Error("No data was found for CSV parsing.");let n=e.value;return this.parseRow(n,!1)}else return null}async iterator(){this.columnNamesValidated||await this.setColumnNames();let t=await this.base.iterator();return this.hasHeader&&(t=t.skip(1)),t.map(e=>this.makeDataElement(e))}makeDataElement(t){let e=this.parseRow(t),n={},o={};for(let s=0;s<this.fullColumnNames.length;s++){let i=this.fullColumnNames[s],a=this.columnConfigs?this.columnConfigs[i]:null;if(!(this.configuredColumnsOnly&&!a)){let u=e[s],l=null;if(u==="")if(a&&a.default!==void 0)l=a.default;else{if(a&&(a.required||a.isLabel))throw new Error(`Required column ${i} is empty in this line: ${t}`);l=void 0}else{let c=Number(u);if(isNaN(c))a&&a.dtype==="bool"?l=this.getBoolean(u):l=u;else if(!a||!a.dtype)l=c;else switch(a.dtype){case"float32":l=c;break;case"int32":l=Math.floor(c);break;case"bool":l=this.getBoolean(u);break;default:l=c}}a&&a.isLabel?o[i]=l:n[i]=l}}return Object.keys(o).length===0?n:{xs:n,ys:o}}getBoolean(t){return t==="1"||t.toLowerCase()==="true"?1:0}parseRow(t,e=!0){let n=[],o=0,s=t.length,i=ag;for(let a=0;a<s;a++)switch(i){case ag:switch(t.charAt(a)){case $b:o=a+1,i=Db;break;case this.delimiter:if(o=a+1,this.delimiter===" "&&this.delimWhitespace)break;n.push(""),i=ag;break;default:i=fR,o=a;break}break;case fR:switch(t.charAt(a)){case this.delimiter:n.push(t.substring(o,a)),i=ag,o=a+1;break;default:}break;case Db:switch(t.charAt(a)){case $b:i=Pk;break;default:}break;case Pk:switch(t.charAt(a)){case this.delimiter:n.push(t.substring(o,a-1)),i=ag,o=a+1;break;case $b:i=Db;break;default:i=dR;break}break;case dR:switch(t.charAt(a)){case $b:i=Db;break;default:}break;default:}if(i===Pk?n.push(t.substring(o,s-1)):n.push(t.substring(o)),e&&n.length!==this.fullColumnNames.length)throw new Error(`Invalid row in csv file. Should have ${this.fullColumnNames.length} elements in a row, but got ${n}`);return n}};var jf=class extends rr{constructor(t){super(),this.microphoneConfig=t,this.isClosed=!1,this.fftSize=t.fftSize||1024;let e=Math.log2(this.fftSize);if(this.fftSize<0||e<4||e>14||!Number.isInteger(e))throw new Error(`Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got ${this.fftSize}`);if(this.numFrames=t.numFramesPerSpectrogram||43,this.sampleRateHz=t.sampleRateHz,this.columnTruncateLength=t.columnTruncateLength||this.fftSize,this.audioTrackConstraints=t.audioTrackConstraints,this.smoothingTimeConstant=t.smoothingTimeConstant||0,this.includeSpectrogram=t.includeSpectrogram!==!1,this.includeWaveform=t.includeWaveform===!0,!this.includeSpectrogram&&!this.includeWaveform)throw new Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.")}summary(){return"microphone"}static async create(t={}){if(!V().get("IS_BROWSER"))throw new Error("microphone API is only supported in browser environment.");let e=new jf(t);return await e.start(),e}async start(){try{this.stream=await navigator.mediaDevices.getUserMedia({audio:this.audioTrackConstraints==null?!0:this.audioTrackConstraints,video:!1})}catch(n){throw new Error(`Error thrown while initializing video stream: ${n.message}`)}if(!this.stream)throw new Error("Could not obtain audio from microphone.");let t=window.AudioContext||window.webkitAudioContext;if(this.audioContext=new t,!this.sampleRateHz)this.sampleRateHz=this.audioContext.sampleRate;else if(this.audioContext.sampleRate!==this.sampleRateHz)throw new Error(`Mismatch in sampling rate: Expected: ${this.sampleRateHz}; Actual: ${this.audioContext.sampleRate}`);let e=this.audioContext.createMediaStreamSource(this.stream);this.analyser=this.audioContext.createAnalyser(),this.analyser.fftSize=this.fftSize*2,this.analyser.smoothingTimeConstant=this.smoothingTimeConstant,e.connect(this.analyser),this.freqData=new Float32Array(this.fftSize),this.timeData=new Float32Array(this.fftSize)}async next(){if(this.isClosed)return{value:null,done:!0};let t,e,n=await this.getAudioData();if(this.includeSpectrogram){let o=this.flattenQueue(n.freqDataQueue);t=this.getTensorFromAudioDataArray(o,[this.numFrames,this.columnTruncateLength,1])}if(this.includeWaveform){let o=this.flattenQueue(n.timeDataQueue);e=this.getTensorFromAudioDataArray(o,[this.numFrames*this.fftSize,1])}return{value:{spectrogram:t,waveform:e},done:!1}}async capture(){return(await this.next()).value}async getAudioData(){let t=[],e=[],n=0;return new Promise(o=>{let s=setInterval(()=>{this.includeSpectrogram&&(this.analyser.getFloatFrequencyData(this.freqData),this.freqData[0]===-1/0&&o({freqDataQueue:t,timeDataQueue:e}),t.push(this.freqData.slice(0,this.columnTruncateLength))),this.includeWaveform&&(this.analyser.getFloatTimeDomainData(this.timeData),e.push(this.timeData.slice())),++n===this.numFrames&&(clearInterval(s),o({freqDataQueue:t,timeDataQueue:e}))},this.fftSize/this.sampleRateHz*1e3)})}stop(){this.isClosed||(this.isClosed=!0,this.analyser.disconnect(),this.audioContext.close(),this.stream!=null&&this.stream.getTracks().length>0&&this.stream.getTracks()[0].stop())}toArray(){throw new Error("Can not convert infinite audio stream to array.")}getSampleRate(){return this.sampleRateHz}flattenQueue(t){let e=t[0].length,n=new Float32Array(t.length*e);return t.forEach((o,s)=>n.set(o,s*e)),n}getTensorFromAudioDataArray(t,e){let n=new Float32Array(x.sizeFromShape(e));return n.set(t,n.length-t.length),Ar(n,e)}};var Xf=class extends rr{constructor(t,e){if(super(),this.webcamVideoElement=t,this.webcamConfig=e,this.isClosed=!0,this.resize=!1,this.needToResize())if(this.resize=!0,this.cropSize=[this.webcamConfig.resizeHeight,this.webcamConfig.resizeWidth],this.cropBoxInd=Re([0],"int32"),this.webcamConfig.centerCrop){let n=this.webcamConfig.resizeWidth*1/this.webcamVideoElement.width,o=this.webcamConfig.resizeHeight*1/this.webcamVideoElement.height,s=(1-n)/2,i=(1-o)/2,a=s+n,u=o+i;this.cropBox=Wi([i,s,u,a],[1,4])}else this.cropBox=Wi([0,0,1,1],[1,4])}summary(){return"webcam"}static async create(t,e={}){if(!V().get("IS_BROWSER"))throw new Error("tf.data.webcam is only supported in browser environment.");if(!t){if(t=document.createElement("video"),!e.resizeWidth||!e.resizeHeight)throw new Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");t.width=e.resizeWidth,t.height=e.resizeHeight}let n=new Xf(t,e);return await n.start(),n}async start(){this.webcamConfig.facingMode&&x.assert(this.webcamConfig.facingMode==="user"||this.webcamConfig.facingMode==="environment",()=>`Invalid webcam facing mode: ${this.webcamConfig.facingMode}. Please provide 'user' or 'environment'`);try{this.stream=await navigator.mediaDevices.getUserMedia({video:{deviceId:this.webcamConfig.deviceId,facingMode:this.webcamConfig.facingMode?this.webcamConfig.facingMode:"user",width:this.webcamVideoElement.width,height:this.webcamVideoElement.height}})}catch(t){throw t.message=`Error thrown while initializing video stream: ${t.message}`,t}if(!this.stream)throw new Error("Could not obtain video from webcam.");try{this.webcamVideoElement.srcObject=this.stream}catch(t){console.log(t),this.webcamVideoElement.src=window.URL.createObjectURL(this.stream)}return this.webcamVideoElement.play(),this.isClosed=!1,new Promise(t=>{this.webcamVideoElement.onloadedmetadata=()=>{t()}})}async next(){if(this.isClosed)return{value:null,done:!0};let t;try{t=Ex.fromPixels(this.webcamVideoElement)}catch(e){throw new Error(`Error thrown converting video to pixels: ${JSON.stringify(e)}`)}if(this.resize)try{return{value:this.cropAndResizeFrame(t),done:!1}}catch(e){throw new Error(`Error thrown cropping the video: ${e.message}`)}finally{t.dispose()}else return{value:t,done:!1}}needToResize(){return!!(this.webcamConfig.resizeWidth&&this.webcamConfig.resizeHeight&&(this.webcamVideoElement.width!==this.webcamConfig.resizeWidth||this.webcamVideoElement.height!==this.webcamConfig.resizeHeight))}cropAndResizeFrame(t){return B(()=>{let e=fr(Z(t,"float32"),0),n;n=dn.cropAndResize(e,this.cropBox,this.cropBoxInd,this.cropSize,"bilinear");let o=n.shape;return O(n,o.slice(1))})}async capture(){return(await this.next()).value}stop(){this.stream.getTracks().forEach(e=>e.stop());try{this.webcamVideoElement.srcObject=null}catch(e){console.log(e),this.webcamVideoElement.src=null}this.isClosed=!0}toArray(){throw new Error("Can not convert infinite video stream to array.")}};var Yf=class{};var lg=class extends rr{split(t){return new Lk(this,t)}},Lk=class extends lg{constructor(t,e){super(),this.upstream=t,this.impl=new zk(t,e)}summary(){return this.impl.summary()}async next(){return this.impl.next()}},zk=class extends Wc{constructor(t,e){super(),this.upstream=t,this.separator=e,this.carryover=""}summary(){return`${this.upstream.summary()} -> Split('${this.separator}')`}async pump(){let t=await this.upstream.next();if(t.done)return this.carryover===""?!1:(this.outputQueue.push(this.carryover),this.carryover="",!0);let e=t.value.split(this.separator);e[0]=this.carryover+e[0];for(let n of e.slice(0,-1))this.outputQueue.push(n);return this.carryover=e[e.length-1],!0}};var Rb=class extends rr{decodeUTF8(){return new Bk(this)}},Bk=class extends lg{constructor(t){super(),this.upstream=t,this.impl=new Vk(t)}summary(){return this.impl.summary()}async next(){return this.impl.next()}},Vk=class extends Wc{constructor(t){if(super(),this.upstream=t,V().get("IS_BROWSER"))this.decoder=new TextDecoder("utf-8");else{let{StringDecoder:e}=Ck();this.decoder=new e("utf8")}}summary(){return`${this.upstream.summary()} -> Utf8`}async pump(){let t=await this.upstream.next(),e;if(t.done)return!1;e=t.value;let n;return V().get("IS_BROWSER")?n=this.decoder.decode(e,{stream:!0}):n=this.decoder.write(Buffer.from(e.buffer)),this.outputQueue.push(n),!0}};var Zf=class extends Rb{constructor(t,e={}){super(),this.file=t,this.options=e,x.assert(t instanceof Uint8Array||(V().get("IS_BROWSER")?t instanceof File||t instanceof Blob:!1),()=>"FileChunkIterator only supports File, Blob and Uint8Array right now."),this.offset=e.offset||0,this.chunkSize=e.chunkSize||1024*1024}summary(){return`FileChunks ${this.file}`}async next(){return this.offset>=(this.file instanceof Uint8Array?this.file.byteLength:this.file.size)?{value:null,done:!0}:{value:await new Promise((e,n)=>{let o=this.offset+this.chunkSize;if(this.file instanceof Uint8Array)e(new Uint8Array(this.file.slice(this.offset,o)));else{let s=new FileReader;s.onload=a=>{let u=s.result;if(u instanceof ArrayBuffer&&(u=new Uint8Array(u)),!(u instanceof Uint8Array))return n(new TypeError("FileReader returned unknown type."));e(u)},s.onabort=a=>n(new Error("Aborted")),s.onerror=a=>n(new Error(a.type));let i=this.file.slice(this.offset,o);s.readAsArrayBuffer(i)}this.offset=o}),done:!1}}};async function hR(r,t={},e){let n,o;typeof r=="string"?n=r:(n=r.url,o=xZ(r));let s=await(e||x.fetch)(n,o);if(s.ok){let i=new Uint8Array(await s.arrayBuffer());return new Zf(i,t)}else throw new Error(s.statusText)}var xZ=r=>({method:r.method,headers:r.headers,body:r.body,mode:r.mode,credentials:r.credentials,cache:r.cache,redirect:r.redirect,referrer:r.referrer,integrity:r.integrity});function Fb(r){return typeof r=="string"&&r.substr(0,7)==="file://"}var Jf=class extends Yf{constructor(t,e={}){super(),this.input=t,this.options=e}async iterator(){if(Fb(this.input)&&V().get("IS_NODE")){let t=Ob();this.input=t.readFileSync(this.input.substr(7))}return new Zf(this.input,this.options)}};var Qf=class extends Yf{constructor(t,e={}){super(),this.url=t,this.fileOptions=e}async iterator(){return Fb(this.url)?new Jf(this.url,this.fileOptions).iterator():hR(this.url,this.fileOptions)}};function gR(r,t={}){return new Kf(new Qf(r),t)}function xR(r){let t=ig(r);return Dn(async()=>t)}function yR(r){return Dn(async()=>{let t=await r();return ig(()=>t.next())})}async function bR(r,t){return Xf.create(r,t)}async function wR(r){return jf.create(r)}var Gk="3.15.0";function nt(r,t){Array.isArray(r)||(r=[r]),r.forEach(e=>{e!=null&&x.assert(e.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the CPU backend.`)})}var yZ=Gr.whereImpl,hu=class extends jo{constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new Ji(this,go())}nextDataId(){return hu.nextDataId++}write(t,e,n){this.firstUse&&(this.firstUse=!1,V().get("IS_NODE")&&S.warn(`
============================
Hi there \u{1F44B}. Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.
============================`));let o={id:this.nextDataId()};return this.data.set(o,{values:t,dtype:n,refCount:1}),o}makeTensorInfo(t,e,n){let o;if(e==="string"&&n!=null&&n.length>0&&x.isString(n[0])){let s=n.map(i=>x.encodeString(i));o=this.write(s,t,e)}else o=this.write(n,t,e);return{dataId:o,shape:t,dtype:e}}refCount(t){return this.data.has(t)?this.data.get(t).refCount:0}incRef(t){let e=this.data.get(t);e.refCount++}decRef(t){if(this.data.has(t)){let e=this.data.get(t);e.refCount--}}move(t,e,n,o,s){this.data.set(t,{values:e,dtype:o,refCount:s})}numDataIds(){return this.data.numDataIds()}async read(t){return this.readSync(t)}readSync(t){let{dtype:e,complexTensorInfos:n}=this.data.get(t);if(e==="complex64"){let o=this.readSync(n.real.dataId),s=this.readSync(n.imag.dataId);return S.mergeRealAndImagArrays(o,s)}return this.data.get(t).values}bufferSync(t){let e=this.readSync(t.dataId),n=e;if(t.dtype==="string")try{n=e.map(o=>x.decodeString(o))}catch(o){throw new Error("Failed to decode encoded string bytes into utf-8")}return It(t.shape,t.dtype,n)}makeOutput(t,e,n){let o=this.write(t,e,n);return go().makeTensorFromDataId(o,e,n,this)}disposeData(t,e=!1){if(this.data.has(t)){if(this.data.get(t).refCount--,!e&&this.data.get(t).refCount>0)return!1;let{complexTensorInfos:n}=this.data.get(t);n!=null&&(this.disposeData(n.real.dataId,!0),this.disposeData(n.imag.dataId,!0)),this.data.delete(t)}return!0}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}async time(t){let e=x.now();return t(),{kernelMs:x.now()-e}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(t){nt([t],"where");let e=this.readSync(t.dataId);return yZ(t.shape,e)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}};hu.nextDataId=0;var Yb={};Yt(Yb,{addImpl:()=>Uk,bincountImpl:()=>rd,bincountReduceImpl:()=>Mb,ceilImpl:()=>Hk,concatImpl:()=>Uc,equalImpl:()=>qk,expImpl:()=>jk,expm1Impl:()=>Yk,floorImpl:()=>Zk,gatherNdImpl:()=>Pb,gatherV2Impl:()=>Lb,greaterEqualImpl:()=>Qk,greaterImpl:()=>Jk,lessEqualImpl:()=>eN,lessImpl:()=>tN,linSpaceImpl:()=>zb,logImpl:()=>rN,maxImpl:()=>Bb,maximumImpl:()=>nN,minimumImpl:()=>oN,multiplyImpl:()=>ug,negImpl:()=>sN,notEqualImpl:()=>iN,prodImpl:()=>aN,rangeImpl:()=>qc,rsqrtImpl:()=>lN,sigmoidImpl:()=>qR,simpleAbsImpl:()=>Wk,sliceImpl:()=>Kc,sparseFillEmptyRowsImpl:()=>Vb,sparseReshapeImpl:()=>Gb,sparseSegmentReductionImpl:()=>od,sqrtImpl:()=>XR,squaredDifferenceImpl:()=>cN,stridedSliceImpl:()=>Wb,stringNGramsImpl:()=>Ub,stringSplitImpl:()=>Hb,stringToHashBucketFastImpl:()=>qb,subImpl:()=>mN,tileImpl:()=>Kb,topKImpl:()=>jb,transposeImpl:()=>nd,uniqueImpl:()=>Xb});function Wk(r){let t=new Float32Array(r.length);for(let e=0;e<r.length;++e)t[e]=Math.abs(r[e]);return t}var bZ=r=>{let{x:t}=r.inputs,e=r.backend;nt(t,"abs");let n=new Float32Array(x.sizeFromShape(t.shape)),o=e.data.get(t.dataId).values;return n=Wk(o),e.makeOutput(n,t.shape,t.dtype)},CR={kernelName:bi,backendName:"cpu",kernelFunc:bZ};function te(r){return(t,e,n,o,s)=>{let i=S.assertAndGetBroadcastShape(t,e),a=i.length,u=x.computeStrides(i),l=x.sizeFromShape(i),c=x.getTypedArrayFromDType(s,l),p=t.length,m=e.length,f=x.computeStrides(t),d=x.computeStrides(e),h=S.getBroadcastDims(t,i),g=S.getBroadcastDims(e,i);if(h.length+g.length===0)for(let y=0;y<c.length;++y)c[y]=r(n[y%n.length],o[y%o.length]);else for(let y=0;y<c.length;++y){let b=x.indexToLoc(y,a,u),w=b.slice(-p);h.forEach($=>w[$]=0);let v=x.locToIndex(w,p,f),k=b.slice(-m);g.forEach($=>k[$]=0);let E=x.locToIndex(k,m,d);c[y]=r(n[v],o[E])}return[c,i]}}function Ir(r){let{inputs:t,backend:e}=r,{real:n,imag:o}=t,s=e.data.get(n.dataId).values,i=e.data.get(o.dataId).values,a=e.makeTensorInfo(n.shape,"complex64"),u=e.data.get(a.dataId);return u.complexTensorInfos={real:e.makeTensorInfo(n.shape,"float32",s),imag:e.makeTensorInfo(o.shape,"float32",i)},a}var IR={kernelName:Ap,backendName:"cpu",kernelFunc:Ir};function td(r,t,e="float32"){if(e==="complex64"){let o=td(r,t,"float32"),s=td(r,t,"float32");return Ir({inputs:{real:o,imag:s},backend:r})}let n=x.makeZerosTypedArray(x.sizeFromShape(t),e);return r.makeTensorInfo(t,e,n)}function qr(r){let{inputs:t,backend:e}=r,{x:n}=t;return e.incRef(n.dataId),{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}var SR={kernelName:lo,backendName:"cpu",kernelFunc:qr};function Ro(r){let{inputs:t,backend:e}=r,{input:n}=t,o=e.data.get(n.dataId).complexTensorInfos.real,s=e.data.get(o.dataId).values;return e.makeTensorInfo(o.shape,o.dtype,s)}var kR={kernelName:Xp,backendName:"cpu",kernelFunc:Ro};function Fo(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{dtype:s}=n;if(s==="complex64"){if(o.dtype==="complex64")return qr({inputs:{x:o},backend:e});let i=td(e,o.shape,o.dtype),a=Fo({inputs:{x:o},backend:e,attrs:{dtype:"float32"}}),u=Ir({inputs:{real:a,imag:i},backend:e});return e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(a),u}if(o.dtype==="complex64"){let i=Ro({inputs:{input:o},backend:e}),a=Fo({inputs:{x:i},backend:e,attrs:{dtype:s}});return e.disposeIntermediateTensorInfo(i),a}if(!x.hasEncodingLoss(o.dtype,s)){let i=qr({inputs:{x:o},backend:e});return{dataId:i.dataId,shape:i.shape,dtype:s}}if(s==="int32"){let i=e.data.get(o.dataId).values,a=Int32Array.from(i);return e.makeTensorInfo(o.shape,"int32",a)}if(s==="bool"){let i=e.data.get(o.dataId).values,a=x.toTypedArray([0],o.dtype),[u,l]=te((c,p)=>c!==p?1:0)(o.shape,[],i,a,"bool");return e.makeTensorInfo(l,"bool",u)}throw new Error(`Error in Cast: failed to cast ${o.dtype} to ${s}`)}var NR={kernelName:io,backendName:"cpu",kernelFunc:Fo};function ie(r,t,e,n){return e==null?({inputs:o,backend:s})=>{let{a:i,b:a}=o,u=s;nt([i,a],r);let l=u.data.get(i.dataId).values,c=u.data.get(a.dataId).values,p=i.dtype==="string"?S.fromUint8ToStringArray(l):l,m=i.dtype==="string"?S.fromUint8ToStringArray(c):c,f=n||i.dtype,[d,h]=t(i.shape,a.shape,p,m,f);return u.makeTensorInfo(h,f,d)}:({inputs:o,backend:s})=>{let{a:i,b:a}=o,u=s;if(i.dtype==="complex64"||a.dtype==="complex64"){let l=Fo({inputs:{x:i},backend:u,attrs:{dtype:"complex64"}}),c=u.data.get(l.dataId),p=c.complexTensorInfos.real,m=c.complexTensorInfos.imag,f=u.data.get(p.dataId).values,d=u.data.get(m.dataId).values,h=Fo({inputs:{x:a},backend:u,attrs:{dtype:"complex64"}}),g=u.data.get(h.dataId),y=g.complexTensorInfos.real,b=g.complexTensorInfos.imag,w=u.data.get(y.dataId).values,v=u.data.get(b.dataId).values,[k,E,$]=e(i.shape,a.shape,f,d,w,v),D=u.makeTensorInfo($,"float32",k),R=u.makeTensorInfo($,"float32",E),P=Ir({inputs:{real:D,imag:R},backend:u});return u.disposeIntermediateTensorInfo(l),u.disposeIntermediateTensorInfo(h),u.disposeIntermediateTensorInfo(D),u.disposeIntermediateTensorInfo(R),P}else{let l=u.data.get(i.dataId).values,c=u.data.get(a.dataId).values,p=n||i.dtype,[m,f]=t(i.shape,a.shape,l,c,p);return u.makeTensorInfo(f,p,m)}}}function ed(r){return(t,e,n,o,s,i)=>{let a=S.assertAndGetBroadcastShape(t,e),u=x.sizeFromShape(a),l=a.length,c=x.computeStrides(a),p=x.getTypedArrayFromDType("float32",u),m=x.getTypedArrayFromDType("float32",u),f=S.getBroadcastDims(t,a),d=S.getBroadcastDims(e,a),h=S.mergeRealAndImagArrays(n,o),g=S.mergeRealAndImagArrays(s,i),y=t.length,b=x.computeStrides(t),w=e.length,v=x.computeStrides(e);if(f.length+d.length===0)for(let k=0;k<p.length;k++){let E=k%h.length,$=k%g.length,D=r(h[E*2],h[E*2+1],g[$*2],g[$*2+1]);p[k]=D.real,m[k]=D.imag}else for(let k=0;k<p.length;k++){let E=x.indexToLoc(k,l,c),$=E.slice(-y);f.forEach(U=>$[U]=0);let D=x.locToIndex($,y,b),R=E.slice(-w);d.forEach(U=>R[U]=0);let P=x.locToIndex(R,w,v),W=r(h[D*2],h[D*2+1],g[P*2],g[P*2+1]);p[k]=W.real,m[k]=W.imag}return[p,m,a]}}var Uk=te((r,t)=>r+t),wZ=ed((r,t,e,n)=>({real:r+e,imag:t+n})),yl=ie(Xn,Uk,wZ),TR={kernelName:Xn,backendName:"cpu",kernelFunc:yl};function rd(r,t,e,n,o){let s=x.sizeFromShape(n),i=x.makeZerosTypedArray(o,e);for(let a=0;a<r.length;a++){let u=r[a];if(u<0)throw new Error("Input x must be non-negative!");u>=o||(s>0?i[u]+=t[a]:i[u]+=1)}return i}function Mb(r,t,e,n=!1){let o=r.shape[0],s=r.shape[1],i=It([o,e],t.dtype);for(let a=0;a<o;a++)for(let u=0;u<s;u++){let l=r.get(a,u);if(l<0)throw new Error("Input x must be non-negative!");l>=e||(n?i.set(1,a,l):t.size>0?i.set(i.get(a,l)+t.get(a,u),a,l):i.set(i.get(a,l)+1,a,l))}return i}function In(r){return(t,e,n)=>{let o=x.getTypedArrayFromDType(e,t.length);for(let s=0;s<t.length;++s)o[s]=r(t[s],n);return o}}function Et(r,t,e){return({inputs:n,attrs:o,backend:s})=>{let{x:i}=n;if(nt(i,r),i.dtype==="string"||e==="string")throw new Error("unaryKernelFunc does not support string input/output");let a=s,u=a.data.get(i.dataId).values,l=x.sizeFromShape(i.shape),c=e||i.dtype,p=x.getArrayFromDType(c,l);for(let m=0;m<l;++m)p[m]=t(u[m],o);return a.makeTensorInfo(i.shape,c,p)}}function Oo(r,t,e){return({inputs:n,attrs:o,backend:s})=>{let{x:i}=n;if(nt(i,r),i.dtype==="string"||e==="string")throw new Error("unaryKernelFunc does not support string input/output");let a=s,u=a.data.get(i.dataId).values,l=e||i.dtype,c=t(u,l,o);return a.makeTensorInfo(i.shape,l,c)}}var Hk=In(r=>Math.ceil(r)),vZ=Oo(es,Hk),_R={kernelName:es,backendName:"cpu",kernelFunc:vZ};function Uc(r,t,e,n){let o=x.getArrayFromDType(e,x.sizeFromShape(t));if(n&&e!=="string"){let s=0;r.forEach(i=>{let a=x.sizeFromShape(i.shape);o.set(i.vals,s),s+=a})}else{let s=0;r.forEach(i=>{let a=e==="string"?S.fromUint8ToStringArray(i.vals):i.vals,u=0;for(let l=0;l<i.shape[0];++l){let c=l*t[1]+s;for(let p=0;p<i.shape[1];++p)o[c+p]=a[u++]}s+=i.shape[1]})}return o}var qk=te((r,t)=>r===t?1:0),Kk=ie(fa,qk,null,"bool"),ER={kernelName:fa,backendName:"cpu",kernelFunc:Kk};var jk=In(r=>Math.exp(r)),Xk=Oo(cs,jk,"float32"),AR={kernelName:cs,backendName:"cpu",kernelFunc:Xk};var Yk=In(r=>Math.expm1(r)),CZ=Oo(da,Yk),$R={kernelName:da,backendName:"cpu",kernelFunc:CZ};var Zk=In(r=>Math.floor(r)),IZ=Oo(ps,Zk),DR={kernelName:ps,backendName:"cpu",kernelFunc:IZ};function Pb(r,t,e,n,o,s,i,a,u){let l=It([n,s],e);for(let c=0;c<n;c++){let p=[],m=0;for(let f=0;f<o;f++){let d=r[c*o+f];m+=d*i[f],p.push(d)}if(m<0||m>=u/s)throw new Error(`Invalid indices: ${p} does not index into ${a}`);for(let f=0;f<s;f++)l.values[c*s+f]=t.get(...t.indexToLoc(m*s+f))}return l}function Lb(r,t,e){let n=It(e,r.dtype);for(let o=0;o<n.size;++o){let i=n.indexToLoc(o).slice(),a=i[0],u=i[2],l=t.locToIndex([a,u]);i[2]=t.values[l];let c=r.locToIndex(i);0<=c&&c<r.values.length&&(n.values[o]=r.values[c])}return n}var Jk=te((r,t)=>r>t?1:0),SZ=ie(xa,Jk,null,"bool"),RR={kernelName:xa,backendName:"cpu",kernelFunc:SZ};var Qk=te((r,t)=>r>=t?1:0),kZ=ie(ds,Qk,null,"bool"),FR={kernelName:ds,backendName:"cpu",kernelFunc:kZ};var tN=te((r,t)=>r<t?1:0),NZ=ie(va,tN,null,"bool"),OR={kernelName:va,backendName:"cpu",kernelFunc:NZ};var eN=te((r,t)=>r<=t?1:0),TZ=ie(Ca,eN,null,"bool"),MR={kernelName:Ca,backendName:"cpu",kernelFunc:TZ};function zb(r,t,e){let n=(t-r)/(e-1),o=x.makeZerosTypedArray(e,"float32");o[0]=r;for(let s=1;s<o.length;s++)o[s]=o[s-1]+n;return o}var rN=In(r=>Math.log(r)),_Z=Oo(gs,rN),PR={kernelName:gs,backendName:"cpu",kernelFunc:_Z};function Bb(r,t,e,n){let o=x.getTypedArrayFromDType(n,x.sizeFromShape(e));for(let s=0;s<o.length;++s){let i=s*t,a=r[i];for(let u=0;u<t;++u){let l=r[i+u];(Number.isNaN(l)||l>a)&&(a=l)}o[s]=a}return o}var nN=te((r,t)=>Math.max(r,t)),EZ=ie(ys,nN),LR={kernelName:ys,backendName:"cpu",kernelFunc:EZ};var oN=te((r,t)=>Math.min(r,t)),AZ=ie(Cs,oN),zR={kernelName:Cs,backendName:"cpu",kernelFunc:AZ};var ug=te((r,t)=>r*t),$Z=ed((r,t,e,n)=>({real:r*e-t*n,imag:r*n+t*e})),Hc=ie(Ss,ug,$Z),BR={kernelName:Ss,backendName:"cpu",kernelFunc:Hc};function sN(r,t,e){let n=x.createScalarValue(-1,e);return ug([],t,n,r,e)}function DZ(r){let{inputs:t,backend:e}=r,{x:n}=t;nt(n,"neg");let o=e.data.get(n.dataId).values,[s,i]=sN(o,n.shape,n.dtype);return e.makeTensorInfo(i,n.dtype,s)}var VR={kernelName:Si,backendName:"cpu",kernelFunc:DZ};var iN=te((r,t)=>r!==t?1:0),RZ=ie(Na,iN,null,"bool"),GR={kernelName:Na,backendName:"cpu",kernelFunc:RZ};function nd(r,t,e,n,o){let s=t.length,i=x.sizeFromShape(t),a=x.computeStrides(t),u=x.computeStrides(o),l=x.getTypedArrayFromDType(e,x.sizeFromShape(o));for(let c=0;c<i;++c){let p=x.indexToLoc(c,s,a),m=new Array(p.length);for(let d=0;d<m.length;d++)m[d]=p[n[d]];let f=x.locToIndex(m,s,u);l[f]=r[c]}return l}function He(r){let{inputs:t,attrs:e,backend:n}=r,{x:o}=t,{perm:s}=e;nt(o,"transpose");let i=o.shape.length,a=new Array(i);for(let p=0;p<a.length;p++)a[p]=o.shape[s[p]];let u=n.data.get(o.dataId).values,l=nd(u,o.shape,o.dtype,s,a);return{dataId:n.write(l,a,o.dtype),shape:a,dtype:o.dtype}}var WR={kernelName:Us,backendName:"cpu",kernelFunc:He};function aN(r,t,e,n){let[o,s]=S.computeOutAndReduceShapes(r,n),i=ar(t,"int32"),a=x.makeZerosTypedArray(x.sizeFromShape(o),i),u=x.sizeFromShape(s);for(let l=0;l<a.length;++l){let c=l*u,p=1;for(let m=0;m<u;++m)p*=e[c+m];a[l]=p}return{outVals:a,outShape:o,outDtype:i}}function FZ(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,keepDims:i}=n;nt(o,"prod");let a=o.shape.length,u=x.parseAxisParam(s,o.shape),l=S.getAxesPermutation(u,a),c=u,p=o,m=[];l!=null&&(p=He({inputs:{x:o},backend:e,attrs:{perm:l}}),m.push(p),c=S.getInnerMostAxes(c.length,a));let f=e.data.get(p.dataId).values,{outVals:d,outShape:h,outDtype:g}=aN(p.shape,p.dtype,f,c),y=h;return i&&(y=S.expandShapeToKeepDim(h,u)),m.forEach(b=>e.disposeIntermediateTensorInfo(b)),e.makeTensorInfo(y,g,d)}var UR={kernelName:Aa,backendName:"cpu",kernelFunc:FZ};function qc(r,t,e,n){let o=r===t,s=r<t&&e<0,i=t<r&&e>1;if(o||s||i)return x.makeZerosTypedArray(0,n);let a=Math.abs(Math.ceil((t-r)/e)),u=x.makeZerosTypedArray(a,n);t<r&&e===1&&(e=-1),u[0]=r;for(let l=1;l<u.length;l++)u[l]=u[l-1]+e;return u}var lN=In(r=>1/Math.sqrt(r)),OZ=Oo(Fs,lN),HR={kernelName:Fs,backendName:"cpu",kernelFunc:OZ};var qR=In(r=>1/(1+Math.exp(-r))),uN=Et(Ms,r=>1/(1+Math.exp(-r))),KR={kernelName:Ms,backendName:"cpu",kernelFunc:uN};function Kc(r,t,e,n,o){let s=Ve.isSliceContinous(n,t,e),i=x.sizeFromShape(e),a=x.computeStrides(n);if(s){let p=Ve.computeFlatOffset(t,a);return o==="string"?r.slice(p,p+i):r.subarray(p,p+i)}let u=o==="string"?S.fromUint8ToStringArray(r):r,l=It(n,o,u),c=It(e,o);for(let p=0;p<c.size;++p){let m=c.indexToLoc(p),f=m.map((d,h)=>d+t[h]);c.set(l.get(...f),...m)}return o==="string"?S.fromStringArrayToUint8(c.values):c.values}function Mo(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{begin:s,size:i}=n;nt(o,"slice");let[a,u]=Ve.parseSliceParams(o,s,i);Ve.assertParamsValid(o,a,u);let l=e.data.get(o.dataId).values,c=Kc(l,a,u,o.shape,o.dtype);return e.makeTensorInfo(u,o.dtype,c)}var jR={kernelName:Ei,backendName:"cpu",kernelFunc:Mo};function Vb(r,t,e,n,o,s,i){let a=t[0],u=s[0],l=new Array(u),c=new Array(a),p=t[1];if(u===0){if(a!==0)throw new Error(S.getSparseFillEmptyRowsIndicesDenseShapeMismatch(a));let g=x.getArrayFromDType(e,0),y=x.getArrayFromDType(o,0);return[g,[0,p],y,l,c]}let m=!0,f=0,d=new Array(u).fill(0);for(let g=0;g<a;++g){let y=r[g*p];if(y<0)throw new Error(S.getSparseFillEmptyRowsNegativeIndexErrorMessage(g,y));if(y>=u)throw new Error(S.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(g,y,u));++d[y],m=m&&y>=f,f=y}let h=!0;for(let g=0;g<u;++g){let y=d[g]===0;l[g]=y,h=h&&!y,d[g]=Math.max(d[g],1),g>0&&(d[g]+=d[g-1])}if(h&&m){let g=r,y=n;for(let b=0;b<a;++b)c[b]=b;return[g,[a,p],y,l,c]}else{let g=d[u-1],y=x.getArrayFromDType(e,g*p),b=x.getArrayFromDType(o,g),w=new Array(u).fill(0);for(let v=0;v<a;++v){let k=r[v*p],E=w[k],$=(k===0?0:d[k-1])+E;w[k]++;for(let D=0;D<p;++D)y[$*p+D]=r[v*p+D];b[$]=n[v],c[v]=$}for(let v=0;v<u;++v)if(w[v]===0){let E=v===0?0:d[v-1];y[E*p+0]=v;for(let $=1;$<p;++$)y[E*p+$]=0;b[E]=i}return[y,[g,p],b,l,c]}}function Gb(r,t,e,n,o){let s=x.sizeFromShape(n),i=t[0],a=o.length,u=[],l=1,c=-1;for(let g=0;g<a;++g){let y=o[g];if(y===-1){if(c!==-1)throw new Error(S.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(c,g));c=g,u.push(1)}else{if(y<0)throw new Error(S.getSparseReshapeNegativeOutputDimErrorMessage(g,y));l*=y,u.push(y)}}if(c!==-1){if(l<=0)throw new Error(S.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());let g=Math.trunc(s/l);if(l*g!==s)throw new Error(S.getSparseReshapeInputOutputMultipleErrorMessage(n,u));u[c]=g}if(x.sizeFromShape(u)!==s)throw new Error(S.getSparseReshapeInputOutputMismatchErrorMessage(n,u));let m=n.length,f=[];if(m>0){f[m-1]=1;for(let g=m-2;g>=0;--g)f[g]=f[g+1]*n[g+1]}let d=[];if(a>0){d[a-1]=1;for(let g=a-2;g>=0;--g)d[g]=d[g+1]*u[g+1]}let h=x.getArrayFromDType(e,i*a);for(let g=0;g<i;++g){let y=0;for(let b=0;b<m;++b)y+=r[g*m+b]*f[b];for(let b=0;b<a;++b)h[g*a+b]=Math.trunc(y/d[b]),y%=d[b]}return[h,[i,a],u]}function od(r,t,e,n,o,s=!1,i=0){let a=n.length,u=[t[0],r.length/t[0]],l=u[1],p=a>0?o[a-1]+1:0;if(p<0)throw new Error(S.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let m=t.slice();m[0]=p;let f=m.reduce((w,v)=>w*v,1),d=x.getArrayFromDType(e,f);if(a===0)return p>0&&d.fill(i),[d,m];if(p<=0)throw new Error(S.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let h=0,g=1,y=0,b=o[h];for(;;){let w=0;if(g<a){if(w=o[g],b===w){++g;continue}if(b>=w)throw new Error(S.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage())}if(b<0||b>=p)throw new Error(S.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(b,p));b>y&&d.fill(i,y*l,b*l);for(let v=h;v<g;++v){let k=n[v];if(k<0||k>=u[0])throw new Error(S.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(v,n[v],u[0]));for(let E=0;E<l;E++)d[b*l+E]+=r[k*l+E]}if(s)for(let v=0;v<l;v++)d[b*l+v]/=g-h;if(h=g,++g,y=b+1,b=w,g>a)break}return y<p&&d.fill(i,y*l,p*l),[d,m]}var XR=In(r=>Math.sqrt(r)),MZ=Et(Ps,r=>Math.sqrt(r)),YR={kernelName:Ps,backendName:"cpu",kernelFunc:MZ};var cN=te((r,t)=>{let e=r-t;return e*e}),PZ=ie(Bs,cN),ZR={kernelName:Bs,backendName:"cpu",kernelFunc:PZ};function Wb(r,t,e,n){let o=It(r,t.dtype);for(let s=0;s<o.size;s++){let i=o.indexToLoc(s),a=new Array(i.length);for(let u=0;u<a.length;u++)a[u]=i[u]*e[u]+n[u];o.set(t.get(...a),...i)}return o}var pN=class{constructor(t,e,n,o,s,i){this.separator=x.encodeString(t),this.nGramWidths=e,this.leftPad=x.encodeString(n),this.rightPad=x.encodeString(o),this.padWidth=s,this.preserveShort=i}getPadWidth(t){return Math.min(this.padWidth<0?t-1:this.padWidth,t-1)}getNumNGrams(t,e){let n=this.getPadWidth(e);return Math.max(0,t+2*n-e+1)}createNGrams(t,e,n,o,s,i){for(let a=0;a<s;++a){let u=this.getPadWidth(i),l=Math.max(0,u-a),c=Math.max(0,u-(s-(a+1))),p=i-(l+c),m=e+(l>0?0:a-u),f=0;f+=l*this.leftPad.length;for(let b=0;b<p;++b)f+=t[m+b].length;f+=c*this.rightPad.length,f+=(l+c+p-1)*this.separator.length,n[o+a]=new Uint8Array(f);let h=n[o+a],g=0,y=b=>b.forEach(w=>h[g++]=w);for(let b=0;b<l;++b)y(this.leftPad),y(this.separator);for(let b=0;b<p-1;++b)y(t[m+b]),y(this.separator);if(p>0){y(t[m+p-1]);for(let b=0;b<c;++b)y(this.separator),y(this.rightPad)}else{for(let b=0;b<c-1;++b)y(this.rightPad),y(this.separator);y(this.rightPad)}}}compute(t,e){let n=t.length,o=e.length;if(o>0){let u=e[0];if(u!==0)throw new Error(`First split value must be 0, got ${u}`);for(let l=1;l<o;++l){let c=e[l]>=u;if(c=c&&e[l]<=n,!c)throw new Error(`Invalid split value ${e[l]}, must be in [${u}, ${n}]`);u=e[l]}if(u!==n)throw new Error(`Last split value must be data size. Expected ${n}, got ${u}`)}let s=o-1,i=x.getArrayFromDType("int32",o);if(n===0||o===0){let u=new Array(n);for(let l=0;l<=s;++l)i[l]=0;return[u,i]}i[0]=0;for(let u=1;u<=s;++u){let l=e[u]-e[u-1],c=0;this.nGramWidths.forEach(p=>{c+=this.getNumNGrams(l,p)}),this.preserveShort&&l>0&&c===0&&(c=1),i[u]=i[u-1]+c}let a=new Array(i[s]);for(let u=0;u<s;++u){let l=e[u],c=i[u];if(this.nGramWidths.forEach(p=>{let m=e[u+1]-e[u],f=this.getNumNGrams(m,p);this.createNGrams(t,l,a,c,f,p),c+=f}),this.preserveShort&&c===i[u]){let p=e[u+1]-e[u];if(p===0)continue;let m=p+2*this.padWidth,f=1;this.createNGrams(t,l,a,c,f,m)}}return[a,i]}};function Ub(r,t,e,n,o,s,i,a){return new pN(e,n,o,s,i,a).compute(r,t)}function LZ(r,t,e,n){if(!r.length)return;if(t.length===0){for(let s=0;s<r.length;++s)n.push(r.subarray(s,s+1));return}if(t.length===1){let s=t[0],i=r.indexOf(s);for(;i!==-1;){let a=r.subarray(0,i);(!e||a.length!==0)&&n.push(a),r=r.subarray(i+1),i=r.indexOf(s)}(!e||r.length!==0)&&n.push(r);return}let o=0;for(let s=0;s<r.length+1;s++)if(s===r.length||t.indexOf(r[s])!==-1){let i=r.subarray(o,s);(!e||i.length!==0)&&n.push(i),o=s+1}}function Hb(r,t,e){let n=r.length,o=[],s=0,i=0,a=new Array(n);for(let m=0;m<n;++m){let f=o.length;LZ(r[m],t,e,o);let d=o.length-f;a[m]=d,s+=d,i=Math.max(i,d)}let u=x.getArrayFromDType("int32",s*2),l=new Array(s),c=[n,i],p=0;for(let m=0;m<n;++m)for(let f=0;f<a[m];++f)u[p*2]=m,u[p*2+1]=f,l[p]=o[p],++p;return[u,l,c]}function qb(r,t){let e=x.getArrayFromDType("int32",r.length);for(let n=0;n<r.length;++n)e[n]=x.fingerPrint64(r[n]).modulo(t).getLowBitsUnsigned();return e}var mN=te((r,t)=>r-t),zZ=ed((r,t,e,n)=>({real:r-e,imag:t-n})),cg=ie(Vs,mN,zZ),JR={kernelName:Vs,backendName:"cpu",kernelFunc:cg};function Kb(r,t){let e=new Array(r.rank);for(let o=0;o<e.length;o++)e[o]=r.shape[o]*t[o];let n=It(e,r.dtype);for(let o=0;o<n.values.length;++o){let s=n.indexToLoc(o),i=new Array(r.rank);for(let u=0;u<i.length;u++)i[u]=s[u]%r.shape[u];let a=r.locToIndex(i);n.values[o]=r.values[a]}return n}var pg=(r,t)=>{let e=t.value-r.value;return e===0?r.index-t.index:e};function QR(r,t,e=0,n=r.length-1){for(;n>e;){if(n-e>600){let a=n-e+1,u=t-e+1,l=Math.log(a),c=.5*Math.exp(2*l/3),p=.5*Math.sqrt(l*c*(a-c)/a)*Math.sign(u-a/2),m=Math.max(e,Math.floor(t-u*c/a+p)),f=Math.min(n,Math.floor(t+(a-u)*c/a+p));QR(r,t,m,f)}let o=r[t],s=e,i=n;for(x.swap(r,e,t),pg(r[n],o)>0&&x.swap(r,e,n);s<i;){for(x.swap(r,s,i),s++,i--;pg(r[s],o)<0;)s=s+1;for(;pg(r[i],o)>0;)i=i-1}pg(r[e],o)===0?x.swap(r,e,i):(i=i+1,x.swap(r,i,n)),i<=t&&(e=i+1),t<=i&&(n=i-1)}}function jb(r,t,e,n,o){let s=t[t.length-1],[i,a]=[r.length/s,s],u=x.getTypedArrayFromDType(e,i*n),l=x.getTypedArrayFromDType("int32",i*n);for(let p=0;p<i;p++){let m=p*a,f=r.subarray(m,m+a),d=new Array(f.length);f.forEach((b,w)=>d[w]={value:b,index:w}),n<d.length&&(QR(d,n),d=d.slice(0,n)),o&&d.sort(pg);let h=p*n,g=u.subarray(h,h+n),y=l.subarray(h,h+n);for(let b=0;b<n;b++)g[b]=d[b].value,y[b]=d[b].index}let c=t.slice();return c[c.length-1]=n,[It(c,e,u),It(c,"int32",l)]}function Xb(r,t,e,n){let o=x.parseAxisParam(t,e)[0],s=[1,e[0],1];for(let d=0;d<o;d++)s[0]*=e[d];s[1]=e[o];for(let d=o+1;d<e.length;d++)s[2]*=e[d];let i={},a=new Int32Array(e[o]),u=new pe(s,n,r),l=[],c=s[0]===1&&s[2]===1;for(let d=0;d<e[o];d++){let h;if(c)h=r[d].toString();else{let g=[];for(let y=0;y<s[0];y++)for(let b=0;b<s[2];b++)g.push(u.get(y,d,b));h=g.join(",")}if(i[h]!==void 0)a[d]=i[h];else{let g=Object.keys(i).length;i[h]=g,a[d]=g,l.push(d)}}let p=s.slice();p[1]=Object.keys(i).length;let m=new pe(p,n);l.forEach((d,h)=>{for(let g=0;g<s[0];g++)for(let y=0;y<s[2];y++)m.set(u.get(g,d,y),g,h,y)});let f=e.slice();return f[o]=p[1],{outputValues:m.values,outputShape:f,indices:a}}fm("cpu",()=>new hu,1);var fN=Et(us,r=>r>=0?r:Math.exp(r)-1),tF={kernelName:us,backendName:"cpu",kernelFunc:fN};function dN(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{alpha:s}=n;nt([o],"leakyRelu");let i=x.sizeFromShape(o.shape),a=e.data.get(o.dataId).values,u=x.getTypedArrayFromDType("float32",i);for(let l=0;l<a.length;l++)u[l]=a[l]<0?s*a[l]:a[l];return e.makeTensorInfo(o.shape,"float32",u)}var eF={kernelName:hs,backendName:"cpu",kernelFunc:dN};var VZ=te((r,t)=>r<0?t*r:r);function hN(r){let{inputs:t,backend:e}=r,{x:n,alpha:o}=t;nt([n,o],"prelu");let s=e.data.get(n.dataId).values,i=e.data.get(o.dataId).values,[a,u]=VZ(n.shape,o.shape,s,i,"float32");return e.makeTensorInfo(u,"float32",a)}var rF={kernelName:_s,backendName:"cpu",kernelFunc:hN};var gN=Et(Es,r=>Math.max(0,r)),nF={kernelName:Es,backendName:"cpu",kernelFunc:gN};var xN=Et($s,r=>Math.min(Math.max(0,r),6)),oF={kernelName:$s,backendName:"cpu",kernelFunc:xN};function sd(r,t,e,n,o){if(e==="linear")return qr({inputs:{x:t},backend:r});if(e==="relu")return gN({inputs:{x:t},backend:r});if(e==="elu")return fN({inputs:{x:t},backend:r});if(e==="relu6")return xN({inputs:{x:t},backend:r});if(e==="prelu")return hN({inputs:{x:t,alpha:n},backend:r});if(e==="leakyrelu")return dN({inputs:{x:t},backend:r,attrs:{alpha:o}});if(e==="sigmoid")return uN({inputs:{x:t},backend:r});throw new Error(`Activation ${e} has not been implemented for the CPU backend.`)}function ne(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{shape:s}=n,i=x.sizeFromShape(o.shape),a=x.inferFromImplicitShape(s,i),u=x.sizeFromShape(a);x.assert(i===u,()=>`The new shape (${a}) has ${u} elements and the old shape (${o.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`),e.incRef(o.dataId);let l=e.data.get(o.dataId);if(l.complexTensorInfos!=null){let c=l.complexTensorInfos.real,p=l.complexTensorInfos.imag;c.shape=a,p.shape=a}return{dataId:o.dataId,shape:a,dtype:o.dtype}}var sF={kernelName:Ti,backendName:"cpu",kernelFunc:ne};function yN(r){let{inputs:t,backend:e,attrs:n}=r,{a:o,b:s}=t,{transposeA:i,transposeB:a}=n;nt([o,s],"matMul");let u=o.shape.length,l=s.shape.length,c=i?o.shape[u-2]:o.shape[u-1],p=a?s.shape[l-1]:s.shape[l-2],m=i?o.shape[u-1]:o.shape[u-2],f=a?s.shape[l-2]:s.shape[l-1],d=o.shape.slice(0,-2),h=s.shape.slice(0,-2),g=x.sizeFromShape(d),y=x.sizeFromShape(h),w=Pr.assertAndGetBroadcastShape(o.shape.slice(0,-2),s.shape.slice(0,-2)).concat([m,f]);x.assert(c===p,()=>`Error in matMul: inner shapes (${c}) and (${p}) of Tensors with shapes ${o.shape} and ${s.shape} and transposeA=${i} and transposeB=${a} must match.`);let v=i?[g,c,m]:[g,m,c],k=a?[y,f,p]:[y,p,f],E=ne({inputs:{x:o},backend:e,attrs:{shape:v}}),$=ne({inputs:{x:s},backend:e,attrs:{shape:k}}),D=i?E.shape[1]:E.shape[2],R=i?E.shape[2]:E.shape[1],P=a?$.shape[1]:$.shape[2],W=Math.max(g,y),U=e.data.get(E.dataId).values,q=e.data.get($.dataId).values,K=x.computeStrides(E.shape),j=x.computeStrides($.shape),[Q,rt,X]=i?[K[0],1,K[1]]:[K[0],K[1],1],[ot,st,it]=a?[1,j[1],j[0]]:[j[1],1,j[0]],ft=R*P,at=It([W,R,P],E.dtype),xt=at.values,dt=e.blockSize;for(let bt=0;bt<W;bt++)for(let kt=0;kt<R;kt+=dt)for(let At=0;At<P;At+=dt)for(let Dt=0;Dt<D;Dt+=dt){let qt=Math.min(kt+dt,R),Kt=Math.min(At+dt,P),ce=Math.min(Dt+dt,D);for(let Ot=kt;Ot<qt;Ot++)for(let $e=At;$e<Kt;$e++){let Se=0;for(let ae=Dt;ae<ce;ae++){let je=Math.min(bt,g-1)*Q,Fe=Math.min(bt,y-1)*it,rn=U[je+Ot*rt+ae*X],ze=q[ae*ot+$e*st+Fe];Se+=rn*ze}xt[bt*ft+(Ot*P+$e)]+=Se}}return e.disposeIntermediateTensorInfo(E),e.disposeIntermediateTensorInfo($),e.makeTensorInfo(w,at.dtype,at.values)}var iF={kernelName:ts,backendName:"cpu",kernelFunc:yN};function GZ(r){let{inputs:t,backend:e,attrs:n}=r,{a:o,b:s,bias:i,preluActivationWeights:a}=t,{transposeA:u,transposeB:l,activation:c,leakyreluAlpha:p}=n,m,f,d,h=[];m=yN({inputs:{a:o,b:s},attrs:{transposeA:u,transposeB:l},backend:e}),i&&(f=yl({inputs:{a:m,b:i},backend:e}),h.push(m),m=f),c&&(d=sd(e,m,c,a,p),h.push(m),m=d);for(let y of h)e.disposeIntermediateTensorInfo(y);return m}var aF={kernelName:Fi,backendName:"cpu",kernelFunc:GZ};var WZ=Et(ta,r=>Math.acos(r)),lF={kernelName:ta,backendName:"cpu",kernelFunc:WZ};var UZ=Et(ea,r=>Math.acosh(r)),uF={kernelName:ea,backendName:"cpu",kernelFunc:UZ};function HZ(r){let{inputs:t,backend:e}=r,n=t;nt(t,"addN");let o=n.map(a=>e.data.get(a.dataId).values),s=It(n[0].shape,n[0].dtype),i=s.values;for(let a=0;a<n.length;a++){let u=o[a];for(let l=0;l<i.length;l++)i[l]+=u[l]}return e.makeTensorInfo(s.shape,s.dtype,s.values)}var cF={kernelName:Zo,backendName:"cpu",kernelFunc:HZ};function qZ(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,keepDims:i}=n;nt(o,"all");let a=x.parseAxisParam(s,o.shape),u=a,l=S.getAxesPermutation(u,o.shape.length),c=o;l!=null&&(c=He({inputs:{x:o},backend:e,attrs:{perm:l}}),u=S.getInnerMostAxes(u.length,o.shape.length)),S.assertAxesAreInnerMostDims("all",u,c.shape.length);let[p,m]=S.computeOutAndReduceShapes(c.shape,u),f=x.sizeFromShape(m),d=x.makeZerosTypedArray(x.sizeFromShape(p),c.dtype),h=e.data.get(c.dataId).values;for(let y=0;y<d.length;++y){let b=y*f,w=h[b];for(let v=0;v<f;++v){let k=h[b+v];w=w&&k}d[y]=w}l!=null&&e.disposeIntermediateTensorInfo(c);let g=e.makeTensorInfo(p,c.dtype,d);if(i){let y=S.expandShapeToKeepDim(p,a),b=ne({inputs:{x:g},backend:e,attrs:{shape:y}});return e.disposeIntermediateTensorInfo(g),b}return g}var pF={kernelName:ra,backendName:"cpu",kernelFunc:qZ};function KZ(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,keepDims:i}=n;nt(o,"any");let a=x.parseAxisParam(s,o.shape),u=a,l=S.getAxesPermutation(u,o.shape.length),c=o;l!=null&&(c=He({inputs:{x:o},backend:e,attrs:{perm:l}}),u=S.getInnerMostAxes(u.length,o.shape.length)),S.assertAxesAreInnerMostDims("any",u,c.shape.length);let[p,m]=S.computeOutAndReduceShapes(c.shape,u),f=x.sizeFromShape(m),d=x.makeZerosTypedArray(x.sizeFromShape(p),c.dtype),h=e.data.get(c.dataId).values;for(let y=0;y<d.length;++y){let b=y*f,w=h[b];for(let v=0;v<f;++v){let k=h[b+v];w=w||k}d[y]=w}l!=null&&e.disposeIntermediateTensorInfo(c);let g=e.makeTensorInfo(p,c.dtype,d);if(i){let y=S.expandShapeToKeepDim(p,a),b=ne({inputs:{x:g},backend:e,attrs:{shape:y}});return e.disposeIntermediateTensorInfo(g),b}return g}var mF={kernelName:na,backendName:"cpu",kernelFunc:KZ};function jZ(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s}=n;nt(o,"argMax");let i=x.parseAxisParam(s,o.shape),a=S.getAxesPermutation(i,o.shape.length),u=o,l=[];a!=null&&(u=He({inputs:{x:o},backend:e,attrs:{perm:a}}),l.push(u),i=S.getInnerMostAxes(i.length,u.shape.length)),i=[i[0]],S.assertAxesAreInnerMostDims("argMax",i,u.shape.length);let[c,p]=S.computeOutAndReduceShapes(u.shape,i),m=x.sizeFromShape(c),f=x.makeZerosTypedArray(m,"int32"),d=x.sizeFromShape(p),h=e.data.get(u.dataId).values;for(let g=0;g<f.length;++g){let y=g*d,b=h[y],w=0;for(let v=0;v<d;++v){let k=h[y+v];k>b&&(b=k,w=v)}f[g]=w}return l.forEach(g=>e.disposeIntermediateTensorInfo(g)),e.makeTensorInfo(c,"int32",f)}var fF={kernelName:Jo,backendName:"cpu",kernelFunc:jZ};function XZ(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s}=n;nt(o,"argMin");let i=x.parseAxisParam(s,o.shape),a=S.getAxesPermutation(i,o.shape.length),u=o,l=[];a!=null&&(u=He({inputs:{x:o},backend:e,attrs:{perm:a}}),l.push(u),i=S.getInnerMostAxes(i.length,u.shape.length)),i=[i[0]],S.assertAxesAreInnerMostDims("argMin",i,u.shape.length);let[c,p]=S.computeOutAndReduceShapes(u.shape,i),m=x.sizeFromShape(c),f=x.makeZerosTypedArray(m,"int32"),d=x.sizeFromShape(p),h=e.data.get(u.dataId).values;for(let g=0;g<f.length;++g){let y=g*d,b=h[y],w=0;for(let v=0;v<d;++v){let k=h[y+v];k<b&&(b=k,w=v)}f[g]=w}return l.forEach(g=>e.disposeIntermediateTensorInfo(g)),e.makeTensorInfo(c,"int32",f)}var dF={kernelName:Al,backendName:"cpu",kernelFunc:XZ};var YZ=Et(oa,r=>Math.asin(r)),hF={kernelName:oa,backendName:"cpu",kernelFunc:YZ};var ZZ=Et(sa,r=>Math.asinh(r)),gF={kernelName:sa,backendName:"cpu",kernelFunc:ZZ};var JZ=Et(ia,r=>Math.atan(r)),xF={kernelName:ia,backendName:"cpu",kernelFunc:JZ};var QZ=te((r,t)=>Math.atan2(r,t)),t9=ie(la,QZ),yF={kernelName:la,backendName:"cpu",kernelFunc:t9};var e9=Et(aa,r=>Math.atanh(r)),bF={kernelName:aa,backendName:"cpu",kernelFunc:e9};function id(r,t,e,n,o,s){let i=o.strideHeight,a=o.strideWidth,u=o.dilationHeight,l=o.dilationWidth,c=o.effectiveFilterHeight,p=o.effectiveFilterWidth,m=o.padInfo.top,f=o.padInfo.left,d=s==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,h=It(o.outShape,e),g=h.values,y=o.outShape[1]*o.outShape[2]*o.outShape[3],b=o.outShape[2]*o.outShape[3],w=o.outShape[3];for(let v=0;v<o.batchSize;++v){let k=v*y,E=v*n[0];for(let $=0;$<o.inChannels;++$)for(let D=0;D<o.outHeight;++D){let R=D*i-m,P=Math.max(0,R),W=Math.min(o.inHeight,c+R),U=k+D*b;for(let q=0;q<o.outWidth;++q){let K=q*a-f,j=Math.max(0,K),Q=Math.min(o.inWidth,p+K),rt=d,X=0,ot=0;for(let it=P;it<W;it+=u){let ft=E+it*n[1];for(let at=j;at<Q;at+=l){let xt=ft+at*n[2],dt=r[xt+$];s==="max"&&dt>rt?rt=dt:s==="avg"&&(X+=dt,ot++)}if(isNaN(rt))break}let st=U+q*w+$;g[st]=s==="avg"?X/ot:rt}}}return h}function Zb(r,t,e,n,o=!1,s=!1){let i=It(n.outShape,"int32"),a=n.strideHeight,u=n.strideWidth,l=n.dilationHeight,c=n.dilationWidth,p=n.effectiveFilterHeight,m=n.effectiveFilterWidth,f=n.padInfo.top,d=n.padInfo.left,h=It(t,e,r);for(let g=0;g<n.batchSize;++g)for(let y=0;y<n.inChannels;++y)for(let b=0;b<n.outHeight;++b){let w=b*a-f,v=w;for(;v<0;)v+=l;let k=Math.min(n.inHeight,p+w);for(let E=0;E<n.outWidth;++E){let $=E*u-d,D=$;for(;D<0;)D+=c;let R=Math.min(n.inWidth,m+$),P=Number.NEGATIVE_INFINITY,W=-1;for(let U=v;U<k;U+=l){let q=U-w;for(let K=D;K<R;K+=c){let j=K-$,Q=h.get(g,U,K,y);Q>P&&(P=Q,o?W=s?((g*n.inHeight+U)*n.inWidth+K)*n.inChannels+y:(U*n.inWidth+K)*n.inChannels+y:W=q*m+j)}}i.set(W,g,b,E,y)}}return i}function Jb(r,t,e,n,o,s){let i=o.strideDepth,a=o.strideHeight,u=o.strideWidth,l=o.dilationDepth,c=o.dilationHeight,p=o.dilationWidth,m=o.effectiveFilterDepth,f=o.effectiveFilterHeight,d=o.effectiveFilterWidth,h=o.padInfo.front,g=o.padInfo.top,y=o.padInfo.left,b=s==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,w=It(o.outShape,e),v=w.values,k=o.outShape[1]*o.outShape[2]*o.outShape[3]*o.outShape[4],E=o.outShape[2]*o.outShape[3]*o.outShape[4],$=o.outShape[3]*o.outShape[4],D=o.outShape[4];for(let R=0;R<o.batchSize;++R){let P=R*k,W=R*n[0];for(let U=0;U<o.inChannels;++U)for(let q=0;q<o.outDepth;++q){let K=q*i-h,j=K;for(;j<0;)j+=l;let Q=Math.min(o.inDepth,m+K),rt=P+q*E;for(let X=0;X<o.outHeight;++X){let ot=X*a-g,st=ot;for(;st<0;)st+=c;let it=Math.min(o.inHeight,f+ot),ft=rt+X*$;for(let at=0;at<o.outWidth;++at){let xt=at*u-y,dt=xt;for(;dt<0;)dt+=p;let bt=Math.min(o.inWidth,d+xt),kt=ft+at*D,At=b,Dt=0,qt=0;for(let ce=j;ce<Q;ce+=l){let Ot=W+ce*n[1];for(let $e=st;$e<it;$e+=c){let Se=Ot+$e*n[2];for(let ae=dt;ae<bt;ae+=p){let je=Se+ae*n[3],Fe=r[je+U];if(s==="max"&&Fe>At?At=Fe:s==="avg"&&(Dt+=Fe,qt++),isNaN(At))break}if(isNaN(At))break}if(isNaN(At))break}let Kt=kt+U;v[Kt]=s==="avg"?Dt/qt:At}}}}return w}function wF(r,t){let e=It(t.outShape,"int32"),n=t.strideDepth,o=t.strideHeight,s=t.strideWidth,i=t.dilationDepth,a=t.dilationHeight,u=t.dilationWidth,l=t.effectiveFilterDepth,c=t.effectiveFilterHeight,p=t.effectiveFilterWidth,m=t.padInfo.front,f=t.padInfo.top,d=t.padInfo.left;for(let h=0;h<t.batchSize;++h)for(let g=0;g<t.inChannels;++g)for(let y=0;y<t.outDepth;++y){let b=y*n-m,w=b;for(;w<0;)w+=i;let v=Math.min(t.inDepth,l+b);for(let k=0;k<t.outHeight;++k){let E=k*o-f,$=E;for(;$<0;)$+=a;let D=Math.min(t.inHeight,c+E);for(let R=0;R<t.outWidth;++R){let P=R*s-d,W=P;for(;W<0;)W+=u;let U=Math.min(t.inWidth,p+P),q=Number.NEGATIVE_INFINITY,K=-1;for(let j=w;j<v;j+=i){let Q=j-b;for(let rt=$;rt<D;rt+=a){let X=rt-E;for(let ot=W;ot<U;ot+=u){let st=ot-P,it=r.get(h,j,rt,ot,g);it>=q&&(q=it,K=Q*c*p+X*c+st)}}}e.set(K,h,y,k,R,g)}}}return e}function r9(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t;nt(o,"avgPool");let{filterSize:s,strides:i,pad:a,dimRoundingMode:u}=n,l=1;x.assert(S.eitherStridesOrDilationsAreOne(i,l),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${l}'`);let c=S.computePool2DInfo(o.shape,s,i,l,a,u),p;if(c.filterWidth===1&&c.filterHeight===1&&x.arraysEqual(c.inShape,c.outShape))p=qr({inputs:{x:o},backend:e});else{let m=e.data.get(o.dataId).values,f=x.computeStrides(o.shape),d=id(m,o.shape,o.dtype,f,c,"avg");p=e.makeTensorInfo(c.outShape,o.dtype,d.values)}return p}var vF={kernelName:Qo,backendName:"cpu",kernelFunc:r9};function n9(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{filterSize:s,strides:i,pad:a,dimRoundingMode:u,dataFormat:l}=n;nt(o,"avgPool3d");let c=S.computePool3DInfo(o.shape,s,i,1,a,u,l),p=e.data.get(o.dataId).values,m=Jb(p,o.shape,o.dtype,x.computeStrides(o.shape),c,"avg");return e.makeTensorInfo(m.shape,"float32",m.values)}var CF={kernelName:$l,backendName:"cpu",kernelFunc:n9};function o9(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,input:s}=t,{filterSize:i,strides:a,pad:u,dimRoundingMode:l}=n;nt([o,s],"avgPool3DGrad");let c=S.computePool3DInfo(s.shape,i,a,1,u,l),p=c.strideDepth,m=c.strideHeight,f=c.strideWidth,d=c.filterDepth,h=c.filterHeight,g=c.filterWidth,y=c.dilationDepth,b=c.dilationHeight,w=c.dilationWidth,v=c.effectiveFilterDepth,k=c.effectiveFilterHeight,E=c.effectiveFilterWidth,$=v-1-c.padInfo.front,D=E-1-c.padInfo.left,R=k-1-c.padInfo.top,P=It(s.shape,"float32"),W=1/(d*h*g),U=e.bufferSync(o);for(let q=0;q<c.batchSize;++q)for(let K=0;K<c.inChannels;++K)for(let j=0;j<c.inDepth;++j)for(let Q=0;Q<c.inHeight;++Q)for(let rt=0;rt<c.inWidth;++rt){let X=j-$,ot=Q-R,st=rt-D,it=0;for(let ft=0;ft<v;ft+=y){let at=(X+ft)/p;if(!(at<0||at>=c.outDepth||Math.floor(at)!==at))for(let xt=0;xt<k;xt+=b){let dt=(ot+xt)/m;if(!(dt<0||dt>=c.outHeight||Math.floor(dt)!==dt))for(let bt=0;bt<E;bt+=w){let kt=(st+bt)/f;if(kt<0||kt>=c.outWidth||Math.floor(kt)!==kt)continue;it+=U.get(q,at,dt,kt,K)}}}P.set(it*W,q,j,Q,rt,K)}return e.makeTensorInfo(P.shape,P.dtype,P.values)}var IF={kernelName:Tp,backendName:"cpu",kernelFunc:o9};function s9(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,input:s}=t,i=s;nt([o,s],"avgPoolGrad");let{filterSize:a,strides:u,pad:l}=n,c=S.computePool2DInfo(i.shape,a,u,1,l),p=c.strideHeight,m=c.strideWidth,f=c.filterHeight,d=c.filterWidth,h=c.dilationHeight,g=c.dilationWidth,y=c.effectiveFilterHeight,b=c.effectiveFilterWidth,w=b-1-c.padInfo.left,v=y-1-c.padInfo.top,k=It(i.shape,"float32"),E=1/(f*d),$=e.data.get(o.dataId).values,D=It(o.shape,"float32",$);for(let R=0;R<c.batchSize;++R)for(let P=0;P<c.inChannels;++P)for(let W=0;W<c.inHeight;++W)for(let U=0;U<c.inWidth;++U){let q=W-v,K=U-w,j=0;for(let Q=0;Q<y;Q+=h){let rt=(q+Q)/p;if(!(rt<0||rt>=c.outHeight||Math.floor(rt)!==rt))for(let X=0;X<b;X+=g){let ot=(K+X)/m;if(ot<0||ot>=c.outWidth||Math.floor(ot)!==ot)continue;j+=D.get(R,rt,ot,P)}}k.set(j*E,R,W,U,P)}return e.makeTensorInfo(k.shape,k.dtype,k.values)}var SF={kernelName:Np,backendName:"cpu",kernelFunc:s9};function i9(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,scale:s,offset:i,mean:a,variance:u}=t;x.assert(a.shape.length===u.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),x.assert(i==null||a.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),x.assert(s==null||a.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),nt([o,a,u,s,i],"batchNorm");let{varianceEpsilon:l}=n;l==null&&(l=.001);let c=e.data.get(o.dataId).values,p=e.data.get(a.dataId).values,m=e.data.get(u.dataId).values,f=s?e.data.get(s.dataId).values:new Float32Array([1]),d=i?e.data.get(i.dataId).values:new Float32Array([0]),h=new Float32Array(c.length),g=d.length,y=f.length,b=m.length,w=p.length,v=0,k=0,E=0,$=0;for(let D=0;D<c.length;++D)h[D]=d[v++]+(c[D]-p[k++])*f[E++]/Math.sqrt(m[$++]+l),v>=g&&(v=0),k>=w&&(k=0),E>=y&&(E=0),$>=b&&($=0);return e.makeTensorInfo(o.shape,o.dtype,h)}var kF={kernelName:fs,backendName:"cpu",kernelFunc:i9};function a9(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{blockShape:s,crops:i}=n;nt([o],"batchToSpaceND");let a=s.reduce((y,b)=>y*b),u=S.getReshaped(o.shape,s,a),l=S.getPermuted(u.length,s.length),c=S.getReshapedPermuted(o.shape,s,a),p=S.getSliceBeginCoords(i,s.length),m=S.getSliceSize(c,i,s.length),f=ne({inputs:{x:o},backend:e,attrs:{shape:u}}),d=He({inputs:{x:f},backend:e,attrs:{perm:l}}),h=ne({inputs:{x:d},backend:e,attrs:{shape:c}}),g=Mo({inputs:{x:h},backend:e,attrs:{begin:p,size:m}});return e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(h),g}var NF={kernelName:wi,backendName:"cpu",kernelFunc:a9};function l9(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,weights:s}=t,{size:i}=n,a=e.data.get(o.dataId).values,u=e.data.get(s.dataId).values,l=rd(a,u,s.dtype,s.shape,i);return e.makeTensorInfo([i],s.dtype,l)}var TF={kernelName:_p,backendName:"cpu",kernelFunc:l9};function u9(r){let{inputs:t,backend:e}=r,{s0:n,s1:o}=t,s=e.data.get(n.dataId).values,i=e.data.get(o.dataId).values,a=S.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return e.makeTensorInfo([a.length],"int32",Int32Array.from(a))}var _F={kernelName:Ep,backendName:"cpu",kernelFunc:u9};var c9=Et(ao,(r,t)=>{let e=t;return r>e.clipValueMax?e.clipValueMax:r<e.clipValueMin?e.clipValueMin:r}),EF={kernelName:ao,backendName:"cpu",kernelFunc:c9};var p9=r=>{let{x:t}=r.inputs,e=r.backend,n=new Float32Array(x.sizeFromShape(t.shape)),o=e.data.get(t.dataId),s=o.complexTensorInfos.real,i=o.complexTensorInfos.imag,a=e.data.get(s.dataId).values,u=e.data.get(i.dataId).values;for(let l=0;l<a.length;l++){let c=a[l],p=u[l];n[l]=Math.hypot(c,p)}return e.makeOutput(n,t.shape,"float32")},AF={kernelName:Dl,backendName:"cpu",kernelFunc:p9};function Yi(r){let{inputs:t,backend:e}=r,{input:n}=t,o=e.data.get(n.dataId).complexTensorInfos.imag,s=e.data.get(o.dataId).values;return e.makeTensorInfo(o.shape,o.dtype,s)}var $F={kernelName:Gp,backendName:"cpu",kernelFunc:Yi};function gu(r){let{inputs:t,backend:e,attrs:n}=r,{axis:o}=n,s=x.parseAxisParam(o,t[0].shape)[0],i=S.computeOutShape(t.map(h=>h.shape),s);if(x.sizeFromShape(i)===0)return e.makeTensorInfo(i,t[0].dtype,[]);let a=t.filter(h=>x.sizeFromShape(h.shape)>0);if(a.length===1)return qr({inputs:{x:a[0]},backend:e});let u=a.map(h=>h.shape);if(S.assertParamsConsistent(u,s),a[0].dtype==="complex64"){let h=a.map(v=>Ro({inputs:{input:v},backend:e})),g=a.map(v=>Yi({inputs:{input:v},backend:e})),y=gu({inputs:h,backend:e,attrs:{axis:s}}),b=gu({inputs:g,backend:e,attrs:{axis:s}}),w=Ir({inputs:{real:y,imag:b},backend:e});return h.forEach(v=>e.disposeIntermediateTensorInfo(v)),g.forEach(v=>e.disposeIntermediateTensorInfo(v)),e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(b),w}let l=a.map(h=>{let g=x.sizeFromShape(h.shape.slice(s));return ne({inputs:{x:h},backend:e,attrs:{shape:[-1,g]}})}),c=l.map(h=>({vals:e.data.get(h.dataId).values,shape:h.shape}));i=S.computeOutShape(l.map(h=>h.shape),1);let p=l[0].shape[0]===1,m=Uc(c,i,t[0].dtype,p),f=S.computeOutShape(a.map(h=>h.shape),s),d=e.makeTensorInfo(f,t[0].dtype,m);return l.forEach(h=>e.disposeIntermediateTensorInfo(h)),d}var DF={kernelName:vi,backendName:"cpu",kernelFunc:gu};function bN(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,filter:s}=t,{strides:i,pad:a,dataFormat:u,dilations:l,dimRoundingMode:c}=n;nt([o,s],"conv2d");let p=S.convertConv2DDataFormat(u),m=S.computeConv2DInfo(o.shape,s.shape,i,l,a,c,!1,p),f=m.filterHeight,d=m.filterWidth,h=m.dilationHeight,g=m.dilationWidth,y=m.padInfo.left,b=m.padInfo.top,w=m.dataFormat==="channelsLast",v=new pe(m.outShape,o.dtype),k=x.computeStrides(o.shape),E=x.computeStrides(s.shape),$=k[0],D=w?k[1]:k[2],R=w?k[2]:1,P=w?1:k[1],W=v.strides[0],U=w?v.strides[1]:v.strides[2],q=w?v.strides[2]:1,K=w?1:v.strides[1],j=e.data.get(o.dataId).values,Q=e.data.get(s.dataId).values,rt=v.values;for(let X=0;X<m.batchSize;++X){let ot=X*$,st=X*W;for(let it=0;it<m.outHeight;++it){let ft=st+it*U,at=it*m.strideHeight-b;for(let xt=0;xt<f;++xt){let dt=at+xt*h;if(dt<0||dt>=m.inHeight)continue;let bt=xt*E[0],kt=ot+dt*D;for(let At=0;At<m.outWidth;++At){let Dt=ft+At*q,qt=At*m.strideWidth-y;for(let Kt=0;Kt<d;++Kt){let ce=qt+Kt*g;if(ce<0||ce>=m.inWidth)continue;let Ot=bt+Kt*E[1],$e=kt+ce*R,Se=Ot;for(let ae=0;ae<m.inChannels;++ae){let je=j[$e+ae*P];for(let Fe=0;Fe<m.outChannels;++Fe)rt[Dt+Fe*K]+=je*Q[Se+Fe];Se+=m.outChannels}}}}}}return e.makeTensorInfo(v.shape,v.dtype,rt)}var RF={kernelName:rs,backendName:"cpu",kernelFunc:bN};function m9(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,dy:s}=t,{strides:i,pad:a,dataFormat:u,dimRoundingMode:l,filterShape:c}=n;nt([o,s],"conv2dBackpropFilter");let p=S.convertConv2DDataFormat(u),m=S.computeConv2DInfo(o.shape,c,i,1,a,l,!1,p),{strideHeight:f,strideWidth:d,filterHeight:h,filterWidth:g}=m,y=m.dataFormat==="channelsLast",b=new pe(m.filterShape,"float32"),w=m.padInfo.left,v=m.padInfo.top,k=e.data.get(o.dataId).values,E=e.data.get(s.dataId).values,$=new pe(o.shape,o.dtype,k),D=new pe(s.shape,s.dtype,E);for(let R=0;R<h;++R){let P=Math.max(0,Math.ceil((v-R)/f)),W=Math.min(m.outHeight,(m.inHeight+v-R)/f);for(let U=0;U<g;++U){let q=Math.max(0,Math.ceil((w-U)/d)),K=Math.min(m.outWidth,(m.inWidth+w-U)/d);for(let j=0;j<m.inChannels;++j)for(let Q=0;Q<m.outChannels;++Q){let rt=0;for(let X=0;X<m.batchSize;++X)for(let ot=P;ot<W;++ot){let st=R+ot*f-v;for(let it=q;it<K;++it){let ft=U+it*d-w;y?rt+=$.get(X,st,ft,j)*D.get(X,ot,it,Q):rt+=$.get(X,j,st,ft)*D.get(X,Q,ot,it)}}b.set(rt,R,U,j,Q)}}}return e.makeTensorInfo(b.shape,b.dtype,b.values)}var FF={kernelName:$p,backendName:"cpu",kernelFunc:m9};function f9(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,filter:s}=t,{inputShape:i,strides:a,pad:u,dataFormat:l,dimRoundingMode:c}=n;nt([o,s],"conv2dBackpropInput");let p=x.computeStrides(s.shape),m=x.computeStrides(o.shape),f=S.convertConv2DDataFormat(l),d=S.computeConv2DInfo(i,s.shape,a,1,u,c,!1,f),h=new pe(d.inShape,"float32"),g=h.values,y=e.data.get(o.dataId).values,b=e.data.get(s.dataId).values,[w,v,k]=p,{batchSize:E,filterHeight:$,filterWidth:D,inChannels:R,inHeight:P,inWidth:W,outChannels:U,outHeight:q,outWidth:K,strideHeight:j,strideWidth:Q}=d;f=d.dataFormat;let rt=$-1-d.padInfo.top,X=D-1-d.padInfo.left,ot=f==="channelsLast",st=h.strides[0],it=ot?h.strides[1]:h.strides[2],ft=ot?h.strides[2]:1,at=ot?1:h.strides[1],xt=m[0],dt=ot?m[1]:m[2],bt=ot?m[2]:1,kt=ot?1:m[1];for(let At=0;At<E;++At)for(let Dt=0;Dt<R;++Dt)for(let qt=0;qt<P;++qt){let Kt=qt-rt,ce=Math.max(0,Math.ceil(Kt/j)),Ot=Math.min(q,($+Kt)/j);for(let $e=0;$e<W;++$e){let Se=$e-X,ae=Math.max(0,Math.ceil(Se/Q)),je=Math.min(K,(D+Se)/Q),Fe=0;for(let ze=ce;ze<Ot;++ze){let Bo=ze*j-Kt;for(let Fr=ae;Fr<je;++Fr){let nn=Fr*Q-Se,on=xt*At+dt*ze+bt*Fr,jr=w*($-1-Bo)+v*(D-1-nn)+k*Dt;for(let oo=0;oo<U;++oo){let Fn=y[on+kt*oo],Vo=b[jr+oo];Fe+=Fn*Vo}}}let rn=st*At+it*qt+ft*$e+at*Dt;g[rn]=Fe}}return e.makeTensorInfo(h.shape,h.dtype,h.values)}var OF={kernelName:ns,backendName:"cpu",kernelFunc:f9};function d9(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,filter:s}=t,{strides:i,pad:a,dilations:u}=n;nt([o,s],"conv3d");let l=S.computeConv3DInfo(o.shape,s.shape,i,u,a),{filterDepth:c,filterHeight:p,filterWidth:m,dilationDepth:f,dilationHeight:d,dilationWidth:h,padInfo:g}=l,y=g.front,b=g.left,w=g.top,v=new pe(l.outShape,o.dtype),k=e.data.get(o.dataId).values,E=e.data.get(s.dataId).values,$=v.values,D=x.computeStrides(o.shape),R=x.computeStrides(s.shape);for(let P=0;P<l.batchSize;++P){let W=P*D[0],U=P*v.strides[0];for(let q=0;q<l.outDepth;++q){let K=U+q*v.strides[1],j=q*l.strideDepth-y;for(let Q=0;Q<c;++Q){let rt=j+Q*f;if(rt<0||rt>=l.inDepth)continue;let X=Q*R[0],ot=W+rt*D[1];for(let st=0;st<l.outHeight;++st){let it=K+st*v.strides[2],ft=st*l.strideHeight-w;for(let at=0;at<p;++at){let xt=ft+at*d;if(xt<0||xt>=l.inHeight)continue;let dt=X+at*R[1],bt=ot+xt*D[2];for(let kt=0;kt<l.outWidth;++kt){let At=it+kt*l.outChannels,Dt=kt*l.strideWidth-b;for(let qt=0;qt<m;++qt){let Kt=Dt+qt*h;if(Kt<0||Kt>=l.inWidth)continue;let ce=dt+qt*R[2],Ot=bt+Kt*l.inChannels,$e=ce;for(let Se=0;Se<l.inChannels;++Se){let ae=k[Ot+Se];for(let je=0;je<l.outChannels;++je)$[At+je]+=ae*E[$e+je];$e+=l.outChannels}}}}}}}}return e.makeTensorInfo(v.shape,v.dtype,v.values)}var MF={kernelName:Rl,backendName:"cpu",kernelFunc:d9};function h9(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,dy:s}=t,{strides:i,pad:a,filterShape:u}=n;nt([o,s],"conv3dBackpropFilterV2");let l=x.computeStrides(o.shape),c=x.computeStrides(s.shape),p=S.computeConv3DInfo(o.shape,u,i,1,a),m=p.strideDepth,f=p.strideHeight,d=p.strideWidth,h=p.filterDepth,g=p.filterHeight,y=p.filterWidth,b=new pe(p.filterShape,"float32"),w=b.values,[v,k,E,$]=b.strides,D=e.data.get(s.dataId).values,[R,P,W,U]=c,q=e.data.get(o.dataId).values,[K,j,Q,rt]=l,X=p.padInfo.front,ot=p.padInfo.left,st=p.padInfo.top;for(let it=0;it<h;++it){let ft=Math.max(0,Math.ceil((X-it)/m)),at=Math.min(p.outDepth,(p.inDepth+X-it)/m),xt=it*v;for(let dt=0;dt<g;++dt){let bt=Math.max(0,Math.ceil((st-dt)/f)),kt=Math.min(p.outHeight,(p.inHeight+st-dt)/f),At=dt*k+xt;for(let Dt=0;Dt<y;++Dt){let qt=Math.max(0,Math.ceil((ot-Dt)/d)),Kt=Math.min(p.outWidth,(p.inWidth+ot-Dt)/d),ce=Dt*E+At;for(let Ot=0;Ot<p.inChannels;++Ot){let $e=Ot*$+ce;for(let Se=0;Se<p.outChannels;++Se){let ae=0;for(let je=0;je<p.batchSize;++je){let Fe=je*K,rn=je*R;for(let ze=ft;ze<at;++ze){let Fr=(it+ze*m-X)*j+Fe,nn=ze*P+rn;for(let on=bt;on<kt;++on){let oo=(dt+on*f-st)*Q+Fr,Fn=on*W+nn;for(let Vo=qt;Vo<Kt;++Vo){let Nl=(Dt+Vo*d-ot)*rt+oo,ku=Vo*U+Fn;ae+=q[Nl+Ot]*D[ku+Se]}}}}w[$e+Se]=ae}}}}}return e.makeTensorInfo(b.shape,b.dtype,b.values)}var PF={kernelName:Dp,backendName:"cpu",kernelFunc:h9};function g9(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,filter:s}=t,{pad:i,strides:a,inputShape:u}=n;nt([o],"conv3dBackpropInputV2");let l=x.computeStrides(o.shape),c=x.computeStrides(s.shape),p=S.computeConv3DInfo(u,s.shape,a,1,i),m=new pe(p.inShape,"float32"),f=m.values,[d,h,g,y]=m.strides,b=e.data.get(o.dataId).values,[w,v,k,E]=l,$=e.data.get(s.dataId).values,[D,R,P,W]=c,{batchSize:U,filterDepth:q,filterHeight:K,filterWidth:j,inChannels:Q,inDepth:rt,inHeight:X,inWidth:ot,outChannels:st,outDepth:it,outHeight:ft,outWidth:at,strideDepth:xt,strideHeight:dt,strideWidth:bt}=p,kt=q-1-p.padInfo.front,At=K-1-p.padInfo.top,Dt=j-1-p.padInfo.left;for(let qt=0;qt<U;++qt)for(let Kt=0;Kt<Q;++Kt)for(let ce=0;ce<rt;++ce){let Ot=ce-kt,$e=Math.max(0,Math.ceil(Ot/xt)),Se=Math.min(it,(q+Ot)/xt);for(let ae=0;ae<X;++ae){let je=ae-At,Fe=Math.max(0,Math.ceil(je/dt)),rn=Math.min(ft,(K+je)/dt);for(let ze=0;ze<ot;++ze){let Bo=ze-Dt,Fr=Math.max(0,Math.ceil(Bo/bt)),nn=Math.min(at,(j+Bo)/bt),on=0;for(let jr=$e;jr<Se;++jr){let oo=jr*xt-Ot;for(let Fn=Fe;Fn<rn;++Fn){let Vo=Fn*dt-je;for(let so=Fr;so<nn;++so){let Nl=so*bt-Bo,ku=w*qt+v*jr+k*Fn+E*so,ap=D*(q-1-oo)+R*(K-1-Vo)+P*(j-1-Nl)+W*Kt;for(let gr=0;gr<st;++gr){let lp=b[ku+gr],up=$[ap+gr];on+=lp*up}}}}f[d*qt+h*ce+g*ae+y*ze+Kt]=on}}}return e.makeTensorInfo(m.shape,m.dtype,m.values)}var LF={kernelName:Rp,backendName:"cpu",kernelFunc:g9};var x9=Et(os,r=>Math.cos(r)),zF={kernelName:os,backendName:"cpu",kernelFunc:x9};var y9=Et(ss,r=>Math.cosh(r)),BF={kernelName:ss,backendName:"cpu",kernelFunc:y9};function b9(r){let{inputs:t,backend:e,attrs:n}=r,{image:o,boxes:s,boxInd:i}=t,{cropSize:a,method:u,extrapolationValue:l}=n,[c,p,m,f]=o.shape,d=s.shape[0],[h,g]=a,y=It([d,h,g,f],"float32"),b=e.data.get(s.dataId).values,w=e.data.get(i.dataId).values,v=e.data.get(o.dataId).values,k=x.computeStrides(o.shape),E=x.computeStrides(y.shape);for(let $=0;$<d;$++){let D=$*4,R=b[D],P=b[D+1],W=b[D+2],U=b[D+3],q=w[$];if(q>=c)continue;let K=h>1?(W-R)*(p-1)/(h-1):0,j=g>1?(U-P)*(m-1)/(g-1):0;for(let Q=0;Q<h;Q++){let rt=h>1?R*(p-1)+Q*K:.5*(R+W)*(p-1);if(rt<0||rt>p-1){for(let X=0;X<g;X++)for(let ot=0;ot<f;ot++){let st=ot+X*E[2]+Q*E[1]+$*E[0];y.values[st]=l}continue}if(u==="bilinear"){let X=Math.floor(rt),ot=Math.ceil(rt),st=rt-X;for(let it=0;it<g;it++){let ft=g>1?P*(m-1)+it*j:.5*(P+U)*(m-1);if(ft<0||ft>m-1){for(let bt=0;bt<f;bt++){let kt=bt+it*E[2]+Q*E[1]+$*E[0];y.values[kt]=l}continue}let at=Math.floor(ft),xt=Math.ceil(ft),dt=ft-at;for(let bt=0;bt<f;bt++){let kt=bt+at*k[2]+X*k[1]+q*k[0],At=v[kt];kt=bt+xt*k[2]+X*k[1]+q*k[0];let Dt=v[kt];kt=bt+at*k[2]+ot*k[1]+q*k[0];let qt=v[kt];kt=bt+xt*k[2]+ot*k[1]+q*k[0];let Kt=v[kt],ce=At+(Dt-At)*dt,Ot=qt+(Kt-qt)*dt;kt=bt+it*E[2]+Q*E[1]+$*E[0],y.values[kt]=ce+(Ot-ce)*st}}}else for(let X=0;X<g;++X){let ot=g>1?P*(m-1)+X*j:.5*(P+U)*(m-1);if(ot<0||ot>m-1){for(let ft=0;ft<f;ft++){let at=ft+X*E[2]+Q*E[1]+$*E[0];y.values[at]=l}continue}let st=Math.round(ot),it=Math.round(rt);for(let ft=0;ft<f;ft++){let at=ft+st*k[2]+it*k[1]+q*k[0],xt=ft+X*E[2]+Q*E[1]+$*E[0];y.values[xt]=v[at]}}}}return e.makeTensorInfo(y.shape,y.dtype,y.values)}var VF={kernelName:ca,backendName:"cpu",kernelFunc:b9};function w9(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,exclusive:i,reverse:a}=n;nt(o,"cumprod");let u=S.getAxesPermutation([s],o.shape.length),l=o;u!=null&&(l=He({inputs:{x:o},backend:e,attrs:{perm:u}}));let c=S.getInnerMostAxes(1,o.shape.length)[0];if(c!==l.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${l.shape.length-1} but got axis=${c}`);let p=ar(l.dtype,"int32"),m=x.makeOnesTypedArray(x.sizeFromShape(l.shape),p),f=e.data.get(l.dataId).values,d=l.shape[l.shape.length-1],h=a?(y,b)=>y+d-b-1:(y,b)=>y+b;for(let y=0;y<f.length;y+=d)for(let b=0;b<d;b++){let w=h(y,b);if(b===0)m[w]=i?1:f[w];else{let v=h(y,b-1);m[w]=i?f[v]*m[v]:f[w]*m[v]}}let g=e.makeTensorInfo(l.shape,p,m);if(u!=null){let y=S.getUndoAxesPermutation(u),b=He({inputs:{x:g},backend:e,attrs:{perm:y}});return e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(l),b}return g}var GF={kernelName:ua,backendName:"cpu",kernelFunc:w9};function v9(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,exclusive:i,reverse:a}=n;nt(o,"cumsum");let u=S.getAxesPermutation([s],o.shape.length),l=o;u!=null&&(l=He({inputs:{x:o},backend:e,attrs:{perm:u}}));let c=S.getInnerMostAxes(1,o.shape.length)[0];if(c!==l.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${l.shape.length-1} but got axis=${c}`);let p=ar(l.dtype,"int32"),m=x.makeZerosTypedArray(x.sizeFromShape(l.shape),p),f=e.data.get(l.dataId).values,d=l.shape[l.shape.length-1],h=a?(y,b)=>y+d-b-1:(y,b)=>y+b;for(let y=0;y<f.length;y+=d)for(let b=0;b<d;b++){let w=h(y,b);if(b===0)m[w]=i?0:f[w];else{let v=h(y,b-1);m[w]=i?f[v]+m[v]:f[w]+m[v]}}let g=e.makeTensorInfo(l.shape,p,m);if(u!=null){let y=S.getUndoAxesPermutation(u),b=He({inputs:{x:g},backend:e,attrs:{perm:y}});return e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(l),b}return g}var WF={kernelName:is,backendName:"cpu",kernelFunc:v9};function C9(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,weights:s}=t,{size:i,binaryOutput:a}=n;if(o.shape.length===1){let u=e.data.get(o.dataId).values,l=e.data.get(s.dataId).values,c=rd(u,l,s.dtype,s.shape,i);return e.makeTensorInfo([i],s.dtype,c)}else if(o.shape.length===2){let u=e.bufferSync(o),l=e.bufferSync(s),c=Mb(u,l,i,a);return e.makeTensorInfo(c.shape,s.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${o.shape.length}.`)}var UF={kernelName:Fp,backendName:"cpu",kernelFunc:C9};function I9(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{blockSize:s,dataFormat:i}=n;x.assert(i==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${i}`);let a=o.shape[0],u=o.shape[1],l=o.shape[2],c=o.shape[3],p=u*s,m=l*s,f=c/(s*s),d=e.data.get(o.dataId).values,h=new Float32Array(a*p*m*f),g=0;for(let y=0;y<a;++y)for(let b=0;b<p;++b){let w=Math.floor(b/s),v=b%s;for(let k=0;k<m;++k){let E=Math.floor(k/s),$=k%s,D=(v*s+$)*f;for(let R=0;R<f;++R){let W=R+D+c*(E+l*(w+u*y));h[g++]=d[W]}}}return e.makeTensorInfo([a,p,m,f],o.dtype,h)}var HF={kernelName:pa,backendName:"cpu",kernelFunc:I9};function wN(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,filter:s}=t,{strides:i,pad:a,dilations:u,dimRoundingMode:l}=n;nt([o,s],"depthwiseConv2DNative");let c=x.computeStrides(o.shape),p=x.computeStrides(s.shape),m=u;m==null&&(m=[1,1]),x.assert(S.eitherStridesOrDilationsAreOne(i,m),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${m}'`);let f=S.computeConv2DInfo(o.shape,s.shape,i,m,a,l,!0),{filterHeight:d,filterWidth:h,dilationHeight:g,dilationWidth:y,padInfo:b}=f,w=b.left,v=b.top,k=f.outChannels/f.inChannels,E=new pe(f.outShape,o.dtype),$=e.data.get(o.dataId).values,D=e.data.get(s.dataId).values,R=E.values;for(let P=0;P<f.batchSize;++P){let W=P*c[0],U=P*E.strides[0];for(let q=0;q<f.outHeight;++q){let K=U+q*E.strides[1],j=q*f.strideHeight-v;for(let Q=0;Q<d;++Q){let rt=j+Q*g;if(rt<0||rt>=f.inHeight)continue;let X=Q*p[0],ot=W+rt*c[1];for(let st=0;st<f.outWidth;++st){let it=K+st*E.strides[2],ft=st*f.strideWidth-w;for(let at=0;at<h;++at){let xt=ft+at*y;if(xt<0||xt>=f.inWidth)continue;let dt=X+at*p[1],bt=ot+xt*f.inChannels,kt=it,At=dt;for(let Dt=0;Dt<f.inChannels;++Dt){let qt=$[bt+Dt];for(let Kt=0;Kt<k;++Kt)R[kt+Kt]+=qt*D[At+Kt];kt+=k,At+=k}}}}}}return e.makeTensorInfo(E.shape,E.dtype,E.values)}var qF={kernelName:as,backendName:"cpu",kernelFunc:wN};function S9(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,dy:s}=t,{strides:i,dilations:a,pad:u,dimRoundingMode:l,filterShape:c}=n;nt([o,s],"depthwiseConv2dNativeBackpropFilter");let p=S.computeConv2DInfo(o.shape,c,i,a,u,l,!0),{strideHeight:m,strideWidth:f,filterHeight:d,filterWidth:h}=p,g=new pe(p.filterShape,"float32"),y=p.padInfo.left,b=p.padInfo.top,w=p.outChannels/p.inChannels,v=e.data.get(o.dataId).values,k=new pe(o.shape,o.dtype,v),E=e.data.get(s.dataId).values,$=new pe(s.shape,s.dtype,E);for(let D=0;D<d;++D){let R=Math.max(0,Math.ceil((b-D)/m)),P=Math.min(p.outHeight,(p.inHeight+b-D)/m);for(let W=0;W<h;++W){let U=Math.max(0,Math.ceil((y-W)/f)),q=Math.min(p.outWidth,(p.inWidth+y-W)/f);for(let K=0;K<p.outChannels;++K){let j=Math.trunc(K/w),Q=K%w,rt=0;for(let X=0;X<p.batchSize;++X)for(let ot=R;ot<P;++ot){let st=D+ot*m-b;for(let it=U;it<q;++it){let ft=W+it*f-y;rt+=k.get(X,st,ft,j)*$.get(X,ot,it,K)}}g.set(rt,D,W,j,Q)}}}return e.makeTensorInfo(g.shape,g.dtype,g.values)}var KF={kernelName:Op,backendName:"cpu",kernelFunc:S9};function k9(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,filter:s}=t,{strides:i,dilations:a,pad:u,dimRoundingMode:l,inputShape:c}=n;nt([o,s],"depthwiseConv2DNativeBackpropInput");let p=x.computeStrides(o.shape),m=x.computeStrides(s.shape),f=S.computeConv2DInfo(c,s.shape,i,a,u,l,!0),d=new pe(f.inShape,"float32"),h=d.values,[g,y,b]=d.strides,w=e.data.get(o.dataId).values,[v,k,E]=p,$=e.data.get(s.dataId).values,[D,R,P]=m,{batchSize:W,filterHeight:U,filterWidth:q,inChannels:K,inHeight:j,inWidth:Q,outChannels:rt,outHeight:X,outWidth:ot,strideHeight:st,strideWidth:it}=f,ft=U-1-f.padInfo.top,at=q-1-f.padInfo.left,xt=rt/K;for(let dt=0;dt<W;++dt)for(let bt=0;bt<K;++bt)for(let kt=0;kt<j;++kt){let At=kt-ft,Dt=Math.max(0,Math.ceil(At/st)),qt=Math.min(X,(U+At)/st);for(let Kt=0;Kt<Q;++Kt){let ce=Kt-at,Ot=Math.max(0,Math.ceil(ce/it)),$e=Math.min(ot,(q+ce)/it),Se=0;for(let ae=Dt;ae<qt;++ae){let je=ae*st-At;for(let Fe=Ot;Fe<$e;++Fe){let rn=Fe*it-ce,ze=v*dt+k*ae+E*Fe,Bo=D*(U-1-je)+R*(q-1-rn)+P*bt;for(let Fr=0;Fr<xt;++Fr){let nn=bt*xt+Fr,on=w[ze+nn],jr=$[Bo+Fr];Se+=on*jr}}}h[g*dt+y*kt+b*Kt+bt]=Se}}return e.makeTensorInfo(d.shape,d.dtype,d.values)}var jF={kernelName:Mp,backendName:"cpu",kernelFunc:k9};function N9(r){let{inputs:t,backend:e}=r,{x:n}=t,o=x.sizeFromShape(n.shape),s=e.data.get(n.dataId).values,i=It([o,o],n.dtype),a=i.values;for(let l=0;l<s.length;l++)a[l*o+l]=s[l];let u=[...n.shape,...n.shape];return e.makeTensorInfo(u,i.dtype,i.values)}var XF={kernelName:Pp,backendName:"cpu",kernelFunc:N9};var YF={kernelName:Fl,backendName:"cpu",kernelFunc:({inputs:r,backend:t,attrs:e})=>{let{x:n,filter:o}=r,{strides:s,pad:i,dilations:a}=e,u=t,l=u.data.get(n.dataId).values,c=n.shape.length,p=u.data.get(o.dataId).values,m=o.shape.length,{batchSize:f,inHeight:d,inWidth:h,inChannels:g,outHeight:y,outWidth:b,padInfo:w,strideHeight:v,strideWidth:k,filterHeight:E,filterWidth:$,dilationHeight:D,dilationWidth:R,outShape:P}=S.computeDilation2DInfo(n.shape,o.shape,s,i,"NHWC",a),W=x.sizeFromShape(P),U=P.length,q=x.getArrayFromDType(n.dtype,W);for(let j=0;j<f;++j)for(let Q=0;Q<y;++Q){let rt=Q*v-w.top;for(let X=0;X<b;++X){let ot=X*k-w.left;for(let st=0;st<g;++st){let it=Number.MIN_SAFE_INTEGER;for(let at=0;at<E;++at){let xt=rt+at*D;if(xt>=0&&xt<d)for(let dt=0;dt<$;++dt){let bt=ot+dt*R;if(bt>=0&&bt<h){let kt=x.locToIndex([j,xt,bt,st],c,x.computeStrides(n.shape)),At=x.locToIndex([at,dt,st],m,x.computeStrides(o.shape)),Dt=l[kt]+p[At];Dt>it&&(it=Dt)}}}let ft=x.locToIndex([j,Q,X,st],U,x.computeStrides(P));q[ft]=it}}}return{dataId:u.write(x.toTypedArray(q,n.dtype),P,n.dtype),shape:P,dtype:n.dtype}}};var ZF={kernelName:Ud,backendName:"cpu",kernelFunc:({inputs:r,backend:t,attrs:e})=>{let{x:n,filter:o,dy:s}=r,{strides:i,pad:a,dilations:u}=e,l=t,c=x.toNestedArray(n.shape,l.data.get(n.dataId).values),p=x.toNestedArray(o.shape,l.data.get(o.dataId).values),{batchSize:m,inHeight:f,inWidth:d,inChannels:h,outHeight:g,outWidth:y,padInfo:b,strideHeight:w,strideWidth:v,filterHeight:k,filterWidth:E,dilationHeight:$,dilationWidth:D,outShape:R}=S.computeDilation2DInfo(n.shape,o.shape,i,a,"NHWC",u);x.assert(s.rank===R.length,()=>`Error in ${Ud}, dy must have the same rank as output ${R.length}, but got ${s.rank}`);let P=x.toNestedArray(R,l.data.get(s.dataId).values),W=x.makeZerosNestedTypedArray(o.shape,o.dtype);for(let q=0;q<m;++q)for(let K=0;K<g;++K){let j=K*w-b.top;for(let Q=0;Q<y;++Q){let rt=Q*v-b.left;for(let X=0;X<h;++X){let ot=Number.MIN_SAFE_INTEGER,st=0,it=0;for(let ft=0;ft<k;++ft){let at=j+ft*$;if(at>=0&&at<f)for(let xt=0;xt<E;++xt){let dt=rt+xt*D;if(dt>=0&&dt<d){let bt=c[q][at][dt][X]+p[ft][xt][X];bt>ot&&(ot=bt,st=ft,it=xt)}}}W[st][it][X]+=P[q][K][Q][X]}}}return{dataId:l.write(x.toTypedArray(W,n.dtype),o.shape,o.dtype),shape:o.shape,dtype:o.dtype}}};var JF={kernelName:Wd,backendName:"cpu",kernelFunc:({inputs:r,backend:t,attrs:e})=>{let{x:n,filter:o,dy:s}=r,{strides:i,pad:a,dilations:u}=e,l=t,c=x.toNestedArray(n.shape,l.data.get(n.dataId).values),p=x.toNestedArray(o.shape,l.data.get(o.dataId).values),{batchSize:m,inHeight:f,inWidth:d,inChannels:h,outHeight:g,outWidth:y,padInfo:b,strideHeight:w,strideWidth:v,filterHeight:k,filterWidth:E,dilationHeight:$,dilationWidth:D,outShape:R}=S.computeDilation2DInfo(n.shape,o.shape,i,a,"NHWC",u);x.assert(s.rank===R.length,()=>`Error in ${Wd}, dy must have the same rank as output ${R.length}, but got ${s.rank}`);let P=x.toNestedArray(R,l.data.get(s.dataId).values),W=x.makeZerosNestedTypedArray(n.shape,n.dtype);for(let q=0;q<m;++q)for(let K=0;K<g;++K){let j=K*w-b.top;for(let Q=0;Q<y;++Q){let rt=Q*v-b.left;for(let X=0;X<h;++X){let ot=Number.MIN_SAFE_INTEGER,st=j<0?0:j,it=rt<0?0:rt;for(let ft=0;ft<k;++ft){let at=j+ft*$;if(at>=0&&at<f)for(let xt=0;xt<E;++xt){let dt=rt+xt*D;if(dt>=0&&dt<d){let bt=c[q][at][dt][X]+p[ft][xt][X];bt>ot&&(ot=bt,st=at,it=dt)}}}W[q][st][it][X]+=P[q][K][Q][X]}}}return{dataId:l.write(x.toTypedArray(W,n.dtype),n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}};function bl(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,keepDims:i}=n;nt(o,"sum");let a;o.dtype==="bool"?a=Fo({inputs:{x:o},backend:e,attrs:{dtype:"int32"}}):a=qr({inputs:{x:o},backend:e});let u=a.shape.length,l=x.parseAxisParam(s,a.shape),c=S.getAxesPermutation(l,u),p=l,m=a;c!=null&&(m=He({inputs:{x:a},backend:e,attrs:{perm:c}}),p=S.getInnerMostAxes(p.length,u)),S.assertAxesAreInnerMostDims("sum",p,m.shape.length);let[f,d]=S.computeOutAndReduceShapes(m.shape,p),h=S.upcastType(m.dtype,"int32"),g=td(e,f,h),y=x.sizeFromShape(d),b=e.data.get(g.dataId).values,w=e.data.get(m.dataId).values;for(let v=0;v<b.length;++v){let k=v*y,E=0;for(let $=0;$<y;++$)E+=w[k+$];b[v]=E}if(i){let v=S.expandShapeToKeepDim(g.shape,l),k=g;g=ne({inputs:{x:g},backend:e,attrs:{shape:v}}),e.disposeIntermediateTensorInfo(k)}return e.disposeIntermediateTensorInfo(a),c!=null&&e.disposeIntermediateTensorInfo(m),g}var QF={kernelName:Ls,backendName:"cpu",kernelFunc:bl};function T9(r){let{inputs:t,backend:e,attrs:n}=r,{equation:o}=n,s=t,{allDims:i,summedDims:a,idDims:u}=S.decodeEinsumEquation(o,s.length);S.checkEinsumDimSizes(i.length,u,s);let{path:l,steps:c}=S.getEinsumComputePath(a,u),p=c.length,m=null,f=i.length,d=[];for(let h=0;h<p;++h){for(let g of c[h]){let{permutationIndices:y,expandDims:b}=S.getEinsumPermutation(f,u[g]),w;S.isIdentityPermutation(y)?w=s[g]:(w=He({inputs:{x:s[g]},backend:e,attrs:{perm:y}}),d.push(w));let v=w.shape.slice();for(let k=0;k<b.length;++k)v.splice(b[k],0,1);x.arraysEqual(w.shape,v)||(w=ne({inputs:{x:w},backend:e,attrs:{shape:v}}),d.push(w)),m===null?m=w:(m=Hc({inputs:{a:w,b:m},backend:e}),d.push(m))}h<p-1&&(l[h]>=0&&(m=bl({inputs:{x:m},backend:e,attrs:{axis:l[h]-(i.length-f),keepDims:!1}}),d.push(m)),f--)}for(let h of d)h!==m&&e.disposeIntermediateTensorInfo(h);return m}var tO={kernelName:Lp,backendName:"cpu",kernelFunc:T9};function _9(r){let{inputs:t,backend:e}=r,{dy:n,y:o}=t;nt([n,o],"eluGrad");let s=new Float32Array(x.sizeFromShape(o.shape)),i=e.data.get(o.dataId).values,a=e.data.get(n.dataId).values;for(let u=0;u<i.length;++u){let l=i[u];l>=1?s[u]=a[u]:s[u]=a[u]*(l+1)}return e.makeTensorInfo(o.shape,"float32",s)}var eO={kernelName:zp,backendName:"cpu",kernelFunc:_9};var E9=S.ERF_P,A9=S.ERF_A1,$9=S.ERF_A2,D9=S.ERF_A3,R9=S.ERF_A4,F9=S.ERF_A5,O9=Et(ma,r=>{let t=Math.sign(r),e=Math.abs(r),n=1/(1+E9*e);return t*(1-((((F9*n+R9)*n+D9)*n+$9)*n+A9)*n*Math.exp(-e*e))}),rO={kernelName:ma,backendName:"cpu",kernelFunc:O9};function ad(r){let{inputs:t,backend:e,attrs:n}=r,{input:o}=t,{dim:s}=n,i=o.shape.length,a=o.shape.slice(),u=s;return s<0&&(x.assert(-(i+1)<=s,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),u=i+s+1),a.splice(u,0,1),ne({inputs:{x:o},backend:e,attrs:{shape:a}})}var nO={kernelName:Ci,backendName:"cpu",kernelFunc:ad};var M9=te((r,t)=>r/t),mg=ie(ls,M9),fg={kernelName:ls,backendName:"cpu",kernelFunc:mg};function Qb(r,t,e){let n=r.shape,o=n[0],s=n[1],i=e.data.get(r.dataId),a=i.complexTensorInfos.real,u=i.complexTensorInfos.imag,l=[o,s],c=x.sizeFromShape(l),p=x.getTypedArrayFromDType("float32",c),m=x.getTypedArrayFromDType("float32",c);for(let g=0;g<o;g++){let y=Mo({inputs:{x:a},backend:e,attrs:{begin:[g,0],size:[1,s]}}),b=Mo({inputs:{x:u},backend:e,attrs:{begin:[g,0],size:[1,s]}}),w=Ir({inputs:{real:y,imag:b},backend:e}),{real:v,imag:k}=P9(w,t,e),E=S.mergeRealAndImagArrays(v,k);for(let $=0;$<s;$++){let D=S.getComplexWithIndex(E,$);p[g*s+$]=D.real,m[g*s+$]=D.imag}e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(b),e.disposeIntermediateTensorInfo(w)}let f=e.makeTensorInfo(l,"float32",p),d=e.makeTensorInfo(l,"float32",m),h=Ir({inputs:{real:f,imag:d},backend:e});return e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(d),h}function P9(r,t,e){let n=x.sizeFromShape(r.shape),o=e.data.get(r.dataId),s=e.data.get(o.complexTensorInfos.real.dataId).values,i=e.data.get(o.complexTensorInfos.imag.dataId).values;if(L9(n)){let a=vN(s,i,n,t,e),u=[r.shape[0],r.shape[1]];if(t){let l=e.makeTensorInfo(u,"float32",a.real),c=e.makeTensorInfo(u,"float32",a.imag),p=e.makeTensorInfo([],"float32",x.createScalarValue(n,"float32")),m=qr({inputs:{x:p},backend:e}),f=fg.kernelFunc({inputs:{a:l,b:p},backend:e}),d=fg.kernelFunc({inputs:{a:c,b:m},backend:e}),h=e.data.get(f.dataId).values,g=e.data.get(d.dataId).values;return e.disposeIntermediateTensorInfo(l),e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(d),{real:h,imag:g}}return a}else{let a=S.mergeRealAndImagArrays(s,i),u=z9(a,n,t);return S.splitRealAndImagArrays(u)}}function L9(r){return(r&r-1)===0}function vN(r,t,e,n,o){if(e===1)return{real:r,imag:t};let s=S.mergeRealAndImagArrays(r,t),i=e/2,a=S.complexWithEvenIndex(s),u=a.real,l=a.imag,c=[u.length],p=o.makeTensorInfo(c,"float32",u),m=o.makeTensorInfo(c,"float32",l),f=Ir({inputs:{real:p,imag:m},backend:o}),d=S.complexWithOddIndex(s),h=d.real,g=d.imag,y=[h.length],b=o.makeTensorInfo(y,"float32",h),w=o.makeTensorInfo(y,"float32",g),v=Ir({inputs:{real:b,imag:w},backend:o}),k=vN(u,l,i,n,o),E=k.real,$=k.imag,D=[E.length],R=o.makeTensorInfo(D,"float32",E),P=o.makeTensorInfo(D,"float32",$),W=Ir({inputs:{real:R,imag:P},backend:o}),U=vN(h,g,i,n,o),q=U.real,K=U.imag,j=[q.length],Q=o.makeTensorInfo(j,"float32",q),rt=o.makeTensorInfo(j,"float32",K),X=Ir({inputs:{real:Q,imag:rt},backend:o}),ot=S.exponents(e,n),st=[ot.real.length],it=o.makeTensorInfo(st,"float32",ot.real),ft=o.makeTensorInfo(st,"float32",ot.imag),at=Ir({inputs:{real:it,imag:ft},backend:o}),xt=Hc({inputs:{a:at,b:X},backend:o}),dt=yl({inputs:{a:W,b:xt},backend:o}),bt=cg({inputs:{a:W,b:xt},backend:o}),kt=Ro({inputs:{input:dt},backend:o}),At=Ro({inputs:{input:bt},backend:o}),Dt=Yi({inputs:{input:dt},backend:o}),qt=Yi({inputs:{input:bt},backend:o}),Kt=gu({inputs:[kt,At],backend:o,attrs:{axis:0}}),ce=gu({inputs:[Dt,qt],backend:o,attrs:{axis:0}}),Ot=o.data.get(Kt.dataId).values,$e=o.data.get(ce.dataId).values;return o.disposeIntermediateTensorInfo(p),o.disposeIntermediateTensorInfo(m),o.disposeIntermediateTensorInfo(f),o.disposeIntermediateTensorInfo(b),o.disposeIntermediateTensorInfo(w),o.disposeIntermediateTensorInfo(v),o.disposeIntermediateTensorInfo(R),o.disposeIntermediateTensorInfo(P),o.disposeIntermediateTensorInfo(W),o.disposeIntermediateTensorInfo(Q),o.disposeIntermediateTensorInfo(rt),o.disposeIntermediateTensorInfo(X),o.disposeIntermediateTensorInfo(it),o.disposeIntermediateTensorInfo(ft),o.disposeIntermediateTensorInfo(at),o.disposeIntermediateTensorInfo(xt),o.disposeIntermediateTensorInfo(dt),o.disposeIntermediateTensorInfo(bt),o.disposeIntermediateTensorInfo(kt),o.disposeIntermediateTensorInfo(Dt),o.disposeIntermediateTensorInfo(At),o.disposeIntermediateTensorInfo(qt),o.disposeIntermediateTensorInfo(Kt),o.disposeIntermediateTensorInfo(ce),{real:Ot,imag:$e}}function z9(r,t,e){let n=new Float32Array(t*2);for(let o=0;o<t;o++){let s=0,i=0;for(let a=0;a<t;a++){let u=S.exponent(o*a,t,e),l=S.getComplexWithIndex(r,a);s+=l.real*u.real-l.imag*u.imag,i+=l.real*u.imag+l.imag*u.real}e&&(s/=t,i/=t),S.assignToTypedArray(n,s,i,o)}return n}function B9(r){let{inputs:t,backend:e}=r,{input:n}=t,o=x.sizeFromShape(n.shape),s=n.shape[n.shape.length-1],i=o/s,a=ne({inputs:{x:n},backend:e,attrs:{shape:[i,s]}}),u=Qb(a,!1,e),l=ne({inputs:{x:u},backend:e,attrs:{shape:n.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(u),l}var oO={kernelName:Bp,backendName:"cpu",kernelFunc:B9};function dg(r){let{backend:t,attrs:e}=r,{shape:n,value:o,dtype:s}=e,i=s||x.inferDtype(o),a=x.getArrayFromDType(i,x.sizeFromShape(n));return V9(a,o,i),t.makeTensorInfo(n,i,a)}var sO={kernelName:Ol,backendName:"cpu",kernelFunc:dg};function V9(r,t,e){r.fill(t)}var iO={kernelName:ha,backendName:"cpu",kernelFunc:({inputs:r,attrs:t,backend:e})=>{let{image:n}=r,o=e,s=x.getTypedArrayFromDType(n.dtype,x.sizeFromShape(n.shape)),[i,a,u,l]=n.shape,c=o.data.get(n.dataId).values;for(let m=0;m<i;m++){let f=m*u*a*l;for(let d=0;d<a;d++){let h=d*(u*l);for(let g=0;g<u;g++){let y=g*l;for(let b=0;b<l;b++){let w=Math.round(u-g-1),v=f+h+y+b,k=c[v];if(w>=0&&w<u){let E=w*l,$=f+h+E+b;k=c[$]}s[v]=k}}}}return{dataId:o.write(s,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}};var G9=te((r,t)=>Math.floor(r/t)),W9=ie(ms,G9,null,"int32"),aO={kernelName:ms,backendName:"cpu",kernelFunc:W9};function U9(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,filter:s,bias:i,preluActivationWeights:a}=t,{strides:u,pad:l,dataFormat:c,dilations:p,dimRoundingMode:m,activation:f,leakyreluAlpha:d}=n,h=bN({inputs:{x:o,filter:s},backend:e,attrs:{strides:u,pad:l,dataFormat:c,dilations:p,dimRoundingMode:m}});if(i){let g=h;h=yl({inputs:{a:h,b:i},backend:e}),e.disposeIntermediateTensorInfo(g)}if(f){let g=h;h=sd(e,h,f,a,d),e.disposeIntermediateTensorInfo(g)}return h}var lO={kernelName:Oi,backendName:"cpu",kernelFunc:U9};function H9(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,filter:s,bias:i,preluActivationWeights:a}=t,{strides:u,pad:l,dataFormat:c,dilations:p,dimRoundingMode:m,activation:f,leakyreluAlpha:d}=n,h=wN({inputs:{x:o,filter:s},backend:e,attrs:{strides:u,pad:l,dataFormat:c,dilations:p,dimRoundingMode:m}});if(i){let g=h;h=yl({inputs:{a:h,b:i},backend:e}),e.disposeIntermediateTensorInfo(g)}if(f){let g=h;h=sd(e,h,f,a,d),e.disposeIntermediateTensorInfo(g)}return h}var uO={kernelName:Mi,backendName:"cpu",kernelFunc:H9};function q9(r){let{inputs:t,backend:e}=r,{params:n,indices:o}=t,s=x.sizeFromShape(n.shape),i=o.shape,a=i[i.length-1],[u,l,c,p]=S.prepareAndValidate(n,o);if(l===0)return e.makeTensorInfo(u,n.dtype,[]);let m=e.data.get(o.dataId).values,f=e.bufferSync(n),d=Pb(m,f,n.dtype,l,a,c,p,n.shape,s);return e.makeTensorInfo(u,n.dtype,d.values)}var cO={kernelName:ga,backendName:"cpu",kernelFunc:q9};function K9(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,indices:s}=t,{axis:i,batchDims:a}=n;nt([o,s],"gatherV2");let u=x.parseAxisParam(i,o.shape)[0],l=e.data.get(s.dataId).values,c=o.shape[u];for(let v=0;v<l.length;++v){let k=l[v];x.assert(k<=c-1&&k>=0,()=>`GatherV2: the index value ${k} is not in [0, ${c-1}]`)}let p=a;a==null&&(p=0);let m=x.sizeFromShape(s.shape),f=S.segment_util.collectGatherOpShapeInfo(o,s,u,p),d=ne({inputs:{x:o},backend:e,attrs:{shape:[f.batchSize,f.outerSize,f.dimSize,f.sliceSize]}}),h=ne({inputs:{x:s},backend:e,attrs:{shape:[f.batchSize,m/f.batchSize]}}),g=[f.batchSize,f.outerSize,m/f.batchSize,f.sliceSize],y=e.bufferSync(h),b=e.bufferSync(d),w=Lb(b,y,g);return e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(h),e.makeTensorInfo(f.outputShape,w.dtype,w.values)}var pO={kernelName:Ii,backendName:"cpu",kernelFunc:K9};function j9(r){let{inputs:t,backend:e}=r,{input:n}=t,o=x.sizeFromShape(n.shape),s=n.shape[n.shape.length-1],i=o/s,a=ne({inputs:{x:n},backend:e,attrs:{shape:[i,s]}}),u=Qb(a,!0,e),l=ne({inputs:{x:u},backend:e,attrs:{shape:n.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(u),l}var mO={kernelName:Vp,backendName:"cpu",kernelFunc:j9};var X9=Et(ya,r=>Number.isFinite(r)?1:0,"bool"),fO={kernelName:ya,backendName:"cpu",kernelFunc:X9};var Y9=Et(ba,r=>Math.abs(r)===1/0?1:0,"bool"),dO={kernelName:ba,backendName:"cpu",kernelFunc:Y9};var Z9=Et(wa,r=>Number.isNaN(r)?1:0,"bool"),hO={kernelName:wa,backendName:"cpu",kernelFunc:Z9};function J9(r){let{backend:t,attrs:e}=r,{start:n,stop:o,num:s}=e,i=zb(n,o,s);return t.makeTensorInfo([i.length],"float32",i)}var gO={kernelName:Wp,backendName:"cpu",kernelFunc:J9};var Q9=Et(Ia,r=>Math.log1p(r)),xO={kernelName:Ia,backendName:"cpu",kernelFunc:Q9};var tJ=te((r,t)=>r&&t),eJ=ie(Sa,tJ,null,"bool"),yO={kernelName:Sa,backendName:"cpu",kernelFunc:eJ};var rJ=Et(Ou,r=>r?0:1,"bool"),bO={kernelName:Ou,backendName:"cpu",kernelFunc:rJ};var nJ=te((r,t)=>r||t),oJ=ie(Mu,nJ,null,"bool"),wO={kernelName:Mu,backendName:"cpu",kernelFunc:oJ};function sJ(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{depthRadius:s,bias:i,alpha:a,beta:u}=n;nt(o,"LRN");let l=o.shape[3],c=l-1,p=e.data.get(o.dataId).values,m=x.sizeFromShape(o.shape),f=new Float32Array(m);function d(h){let g=h%l,y=h-g+Math.max(0,g-s),b=h-g+Math.min(g+s,c),w=0;for(;y<=b;y++){let v=p[y];w+=v*v}return w}for(let h=0;h<m;h++){let g=d(h),y=p[h]*Math.pow(i+a*g,-u);f[h]=y}return e.makeTensorInfo(o.shape,o.dtype,f)}var vO={kernelName:Ml,backendName:"cpu",kernelFunc:sJ};function iJ(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,y:s,dy:i}=t,{depthRadius:a,bias:u,alpha:l,beta:c}=n;nt(i,"LRNGrad");let p=x.sizeFromShape(i.shape),m=i.shape[3],f=e.data.get(i.dataId).values,d=e.data.get(o.dataId).values,h=e.data.get(s.dataId).values,g=new Float32Array(p),y=p;for(let b=0;b<y;b++){let w=b%m,v=b-w+Math.max(0,w-a),k=b-w+Math.min(m,w+a+1),E=0;for(let $=v;$<k;$++)E+=Math.pow(d[$],2);E=l*E+u;for(let $=v;$<k;$++){let D=-2*l*c*d[$]*h[b]/E;b===$&&(D+=Math.pow(E,-c)),D*=f[b],g[$]+=D}}return e.makeTensorInfo(i.shape,o.dtype,g)}var CO={kernelName:Up,backendName:"cpu",kernelFunc:iJ};function CN(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{reductionIndices:s,keepDims:i}=n,a=e,u=o.shape,l=u.length,c=x.parseAxisParam(s,u),p=c,m=S.getAxesPermutation(p,l),f=a.data.get(o.dataId).values;if(m!=null){let v=new Array(l);for(let k=0;k<v.length;k++)v[k]=u[m[k]];f=nd(f,u,o.dtype,m,v),p=S.getInnerMostAxes(p.length,l),u=v}nt(o,"max"),S.assertAxesAreInnerMostDims("max",p,l);let[d,h]=S.computeOutAndReduceShapes(u,p),g=x.sizeFromShape(h),y=Bb(f,g,d,o.dtype),b=a.write(y,d,o.dtype),w=d;return i&&(w=S.expandShapeToKeepDim(d,c)),{dataId:b,shape:w,dtype:o.dtype}}var IO={kernelName:xs,backendName:"cpu",kernelFunc:CN};function aJ(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t;nt(o,"maxPool");let{filterSize:s,strides:i,pad:a,dimRoundingMode:u}=n,l=1;x.assert(S.eitherStridesOrDilationsAreOne(i,l),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${l}'`);let c=S.computePool2DInfo(o.shape,s,i,l,a,u),p;if(c.filterWidth===1&&c.filterHeight===1&&x.arraysEqual(c.inShape,c.outShape))p=qr({inputs:{x:o},backend:e});else{let m=e.data.get(o.dataId).values,f=x.computeStrides(o.shape),d=id(m,o.shape,o.dtype,f,c,"max");p=e.makeTensorInfo(c.outShape,o.dtype,d.values)}return p}var SO={kernelName:bs,backendName:"cpu",kernelFunc:aJ};function lJ(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{filterSize:s,strides:i,pad:a,dimRoundingMode:u,dataFormat:l}=n;nt(o,"maxPool3d");let c=S.computePool3DInfo(o.shape,s,i,1,a,u,l),p=e.data.get(o.dataId).values,m=Jb(p,o.shape,o.dtype,x.computeStrides(o.shape),c,"max");return e.makeTensorInfo(m.shape,"float32",m.values)}var kO={kernelName:Pl,backendName:"cpu",kernelFunc:lJ};function uJ(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,input:s}=t,{filterSize:i,strides:a,pad:u,dimRoundingMode:l}=n;nt([o,s],"maxPool3DGrad");let c=S.computePool3DInfo(s.shape,i,a,1,u,l),p=e.bufferSync(s),m=wF(p,c),f=c.strideDepth,d=c.strideHeight,h=c.strideWidth,g=c.dilationDepth,y=c.dilationHeight,b=c.dilationWidth,w=c.effectiveFilterDepth,v=c.effectiveFilterHeight,k=c.effectiveFilterWidth,E=w-1-c.padInfo.front,$=k-1-c.padInfo.left,D=v-1-c.padInfo.top,R=It(s.shape,"float32"),P=e.bufferSync(o);for(let W=0;W<c.batchSize;++W)for(let U=0;U<c.inChannels;++U)for(let q=0;q<c.inDepth;++q)for(let K=0;K<c.inHeight;++K)for(let j=0;j<c.inWidth;++j){let Q=q-E,rt=K-D,X=j-$,ot=0;for(let st=0;st<w;st+=g){let it=(Q+st)/f;if(!(it<0||it>=c.outDepth||Math.floor(it)!==it))for(let ft=0;ft<v;ft+=y){let at=(rt+ft)/d;if(!(at<0||at>=c.outHeight||Math.floor(at)!==at))for(let xt=0;xt<k;xt+=b){let dt=(X+xt)/h;if(dt<0||dt>=c.outWidth||Math.floor(dt)!==dt)continue;let bt=w*v*k-1-m.get(W,it,at,dt,U),kt=st*v*k+ft*k+xt,At=bt===kt?1:0;if(At===0)continue;ot+=P.get(W,it,at,dt,U)*At}}}R.set(ot,W,q,K,j,U)}return e.makeTensorInfo(R.shape,R.dtype,R.values)}var NO={kernelName:qp,backendName:"cpu",kernelFunc:uJ};function cJ(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,input:s,output:i}=t,a=s;nt([s,i],"maxPoolGrad");let{filterSize:u,strides:l,pad:c,dimRoundingMode:p}=n,m=S.computePool2DInfo(a.shape,u,l,1,c,p),f=e.data.get(a.dataId).values,d=It(m.outShape,a.dtype,Zb(f,a.shape,a.dtype,m).values),h=m.strideHeight,g=m.strideWidth,y=m.dilationHeight,b=m.dilationWidth,w=m.effectiveFilterHeight,v=m.effectiveFilterWidth,k=v-1-m.padInfo.left,E=w-1-m.padInfo.top,$=It(a.shape,"float32"),D=e.data.get(o.dataId).values,R=It(o.shape,"float32",D);for(let P=0;P<m.batchSize;++P)for(let W=0;W<m.inChannels;++W)for(let U=0;U<m.inHeight;++U)for(let q=0;q<m.inWidth;++q){let K=U-E,j=q-k,Q=0;for(let rt=0;rt<w;rt+=y){let X=(K+rt)/h;if(!(X<0||X>=m.outHeight||Math.floor(X)!==X))for(let ot=0;ot<v;ot+=b){let st=(j+ot)/g;if(st<0||st>=m.outWidth||Math.floor(st)!==st)continue;let it=w*v-1-d.get(P,X,st,W),ft=rt*v+ot,at=it===ft?1:0;if(at===0)continue;Q+=R.get(P,X,st,W)*at}}$.set(Q,P,U,q,W)}return e.makeTensorInfo($.shape,$.dtype,$.values)}var TO={kernelName:Hp,backendName:"cpu",kernelFunc:cJ};function _O(r,t,e,n,o){let s=x.computeStrides(t),i=id(r,t,e,s,o,"max"),a=Zb(r,t,e,o,!0,n);return[i.values,a.values]}var EO={kernelName:Kp,backendName:"cpu",kernelFunc:({inputs:r,attrs:t,backend:e})=>{let{x:n}=r,{filterSize:o,strides:s,pad:i,includeBatchInIndex:a}=t,u=e;nt(n,"MaxPoolWithArgmax");let l=u.data.get(n.dataId).values,c=S.computePool2DInfo(n.shape,o,s,[1,1],i),[p,m]=_O(l,n.shape,n.dtype,a,c),f=u.write(p,c.outShape,n.dtype),d=u.write(m,c.outShape,n.dtype);return[{dataId:f,shape:c.outShape,dtype:n.dtype},{dataId:d,shape:c.outShape,dtype:"int32"}]}};function pJ(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,keepDims:i}=n,a=x.parseAxisParam(s,o.shape),l=S.computeOutAndReduceShapes(o.shape,a)[1],c=x.sizeFromShape(l),p=[],m=e.makeTensorInfo([],"float32",new Float32Array([c]));p.push(m);let f=Fo({inputs:{x:o},backend:e,attrs:{dtype:"float32"}});p.push(f);let d=mg({inputs:{a:f,b:m},backend:e});p.push(d);let h=bl({inputs:{x:d},backend:e,attrs:{axis:s,keepDims:i}});return p.forEach(g=>e.disposeIntermediateTensorInfo(g)),h}var AO={kernelName:ws,backendName:"cpu",kernelFunc:pJ};function mJ(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,keepDims:i}=n;nt(o,"min");let a=x.parseAxisParam(s,o.shape),u=a,l=S.getAxesPermutation(u,o.shape.length),c=o;l!=null&&(c=He({inputs:{x:o},backend:e,attrs:{perm:l}}),u=S.getInnerMostAxes(u.length,o.shape.length)),S.assertAxesAreInnerMostDims("min",u,c.shape.length);let[p,m]=S.computeOutAndReduceShapes(c.shape,u),f=x.sizeFromShape(m),d=x.makeZerosTypedArray(x.sizeFromShape(p),c.dtype),h=e.data.get(c.dataId).values;for(let y=0;y<d.length;++y){let b=y*f,w=h[b];for(let v=0;v<f;++v){let k=h[b+v];(Number.isNaN(k)||k<w)&&(w=k)}d[y]=w}l!=null&&e.disposeIntermediateTensorInfo(c);let g=e.makeTensorInfo(p,c.dtype,d);if(i){let y=S.expandShapeToKeepDim(p,a),b=ne({inputs:{x:g},backend:e,attrs:{shape:y}});return e.disposeIntermediateTensorInfo(g),b}return g}var $O={kernelName:vs,backendName:"cpu",kernelFunc:mJ};function fJ(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{paddings:s,mode:i}=n;nt(o,"mirrorPad");let a=s.map((w,v)=>w[0]+o.shape[v]+w[1]),u=s.map(w=>w[0]),l=s.map((w,v)=>w[0]+o.shape[v]),c=i==="reflect"?0:1,p=e.data.get(o.dataId).values,m=o.shape.length,f=x.computeStrides(o.shape),d=x.sizeFromShape(a),h=a.length,g=x.computeStrides(a),y=x.getTypedArrayFromDType(o.dtype,d);for(let w=0;w<d;w++){let v=x.indexToLoc(w,h,g);for(let E=0;E<h;E++)v[E]<u[E]?v[E]=u[E]*2-v[E]-c:v[E]>=l[E]&&(v[E]=(l[E]-1)*2-v[E]+c);v=v.map((E,$)=>E-u[$]);let k=x.locToIndex(v,m,f);y[w]=p[k]}return{dataId:e.write(y,a,o.dtype),shape:a,dtype:o.dtype}}var DO={kernelName:Is,backendName:"cpu",kernelFunc:fJ};var dJ=te((r,t)=>{let e=r%t;return r<0&&t<0||r>=0&&t>=0?e:(e+t)%t}),hJ=ie(ka,dJ),RO={kernelName:ka,backendName:"cpu",kernelFunc:hJ};var OO=Du(iS());function IN(r){let{inputs:t,backend:e,attrs:n}=r,{logits:o}=t,{dim:s}=n,i=o.shape.length,a=s;if(a===-1&&(a=i-1),a!==i-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${i} and dim was ${a}`);let u=x.parseAxisParam([a],o.shape),l=CN({inputs:{x:o},backend:e,attrs:{reductionIndices:u,keepDims:!1}}),c=S.expandShapeToKeepDim(l.shape,u),p=ne({inputs:{x:l},backend:e,attrs:{shape:c}}),m=cg({inputs:{a:o,b:p},backend:e}),f=Xk({inputs:{x:m},backend:e}),d=bl({inputs:{x:f},backend:e,attrs:{axis:u,keepDims:!1}}),h=ne({inputs:{x:d},backend:e,attrs:{shape:c}}),g=mg({inputs:{a:f,b:h},backend:e});return e.disposeIntermediateTensorInfo(l),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(h),g}var FO={kernelName:zs,backendName:"cpu",kernelFunc:IN};function gJ(r){let{inputs:t,backend:e,attrs:n}=r,{logits:o}=t,{numSamples:s,seed:i,normalized:a}=n;nt(o,"multinomial");let u=a?o:IN({inputs:{logits:o},backend:e,attrs:{dim:-1}}),l=u.shape[0],c=u.shape[1],p=e.data.get(u.dataId).values,m=[l,s],f=x.makeZerosTypedArray(x.sizeFromShape(m),"int32");for(let d=0;d<l;++d){let h=d*c,g=new Float32Array(c-1);g[0]=p[h];for(let w=1;w<g.length;++w)g[w]=g[w-1]+p[h+w];let y=OO.alea(i.toString()),b=d*s;for(let w=0;w<s;++w){let v=y();f[b+w]=g.length;for(let k=0;k<g.length;k++)if(v<g[k]){f[b+w]=k;break}}}return a||e.disposeIntermediateTensorInfo(u),e.makeTensorInfo(m,"int32",f)}var MO={kernelName:jp,backendName:"cpu",kernelFunc:gJ};var xJ=Gr.nonMaxSuppressionV3Impl;function yJ(r){let{inputs:t,backend:e,attrs:n}=r,{boxes:o,scores:s}=t,{maxOutputSize:i,iouThreshold:a,scoreThreshold:u}=n;nt(o,"NonMaxSuppression");let l=e.data.get(o.dataId).values,c=e.data.get(s.dataId).values,{selectedIndices:p}=xJ(l,c,i,a,u);return e.makeTensorInfo([p.length],"int32",new Int32Array(p))}var PO={kernelName:Ta,backendName:"cpu",kernelFunc:yJ};var bJ=Gr.nonMaxSuppressionV4Impl;function wJ(r){let{inputs:t,backend:e,attrs:n}=r,{boxes:o,scores:s}=t,{maxOutputSize:i,iouThreshold:a,scoreThreshold:u,padToMaxOutputSize:l}=n;nt(o,"NonMaxSuppressionPadded");let c=e.data.get(o.dataId).values,p=e.data.get(s.dataId).values,{selectedIndices:m,validOutputs:f}=bJ(c,p,i,a,u,l);return[e.makeTensorInfo([m.length],"int32",new Int32Array(m)),e.makeTensorInfo([],"int32",new Int32Array([f]))]}var LO={kernelName:_a,backendName:"cpu",kernelFunc:wJ};var vJ=Gr.nonMaxSuppressionV5Impl;function CJ(r){let{inputs:t,backend:e,attrs:n}=r,{boxes:o,scores:s}=t,{maxOutputSize:i,iouThreshold:a,scoreThreshold:u,softNmsSigma:l}=n;nt(o,"NonMaxSuppressionWithScore");let c=e.data.get(o.dataId).values,p=e.data.get(s.dataId).values,m=i,f=a,d=u,h=l,{selectedIndices:g,selectedScores:y}=vJ(c,p,m,f,d,h);return[e.makeTensorInfo([g.length],"int32",new Int32Array(g)),e.makeTensorInfo([y.length],"float32",new Float32Array(y))]}var zO={kernelName:Ea,backendName:"cpu",kernelFunc:CJ};function IJ(r){let{inputs:t,backend:e,attrs:n}=r,{indices:o}=t,{depth:s,onValue:i,offValue:a}=n;nt(o,"oneHot");let u=x.sizeFromShape(o.shape),l=new Float32Array(u*s);l.fill(a);let c=e.data.get(o.dataId).values;for(let p=0;p<u;++p)c[p]>=0&&c[p]<s&&(l[p*s+c[p]]=i);return e.makeTensorInfo([...o.shape,s],"int32",l)}var BO={kernelName:ks,backendName:"cpu",kernelFunc:IJ};function hg(r){let{inputs:t,backend:e}=r,{x:n}=t;if(n.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(n.dtype==="complex64"){let o=Ro({inputs:{input:n},backend:e}),s=hg({inputs:{x:o},backend:e}),i=Yi({inputs:{input:n},backend:e}),a=hg({inputs:{x:i},backend:e}),u=Ir({inputs:{real:s,imag:a},backend:e});return e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(a),u}else return dg({backend:e,attrs:{shape:n.shape,value:0,dtype:n.dtype}})}var VO={kernelName:Ri,backendName:"cpu",kernelFunc:hg};function GO(r){let{inputs:t,backend:e}=r,{x:n}=t;if(n.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(n.dtype==="complex64"){let o=Ro({inputs:{input:n},backend:e}),s=GO({inputs:{x:o},backend:e}),i=Yi({inputs:{input:n},backend:e}),a=hg({inputs:{x:i},backend:e}),u=Ir({inputs:{real:s,imag:a},backend:e});return e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(a),u}else return dg({backend:e,attrs:{shape:n.shape,value:1,dtype:n.dtype}})}var WO={kernelName:ki,backendName:"cpu",kernelFunc:GO};function SN(r){let{inputs:t,backend:e,attrs:n}=r,{axis:o}=n;if(t.length===1)return ad({inputs:{input:t[0]},backend:e,attrs:{dim:o}});let s=t[0].shape,i=t[0].dtype;t.forEach(c=>{x.assertShapesMatch(s,c.shape,"All tensors passed to stack must have matching shapes"),x.assert(i===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});let a=[],u=t.map(c=>{let p=ad({inputs:{input:c},backend:e,attrs:{dim:o}});return a.push(p),p}),l=gu({inputs:u,backend:e,attrs:{axis:o}});return a.forEach(c=>e.disposeIntermediateTensorInfo(c)),l}var UO={kernelName:Ni,backendName:"cpu",kernelFunc:SN};function SJ(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{paddings:s,constantValue:i}=n;nt(o,"pad");let a=s.map((b,w)=>b[0]+o.shape[w]+b[1]),u=s.map(b=>b[0]),l=e.data.get(o.dataId).values,c=x.sizeFromShape(o.shape),p=o.shape.length,m=x.computeStrides(o.shape),f=x.sizeFromShape(a),d=a.length,h=x.computeStrides(a),g=x.getTypedArrayFromDType(o.dtype,f);i!==0&&g.fill(i);for(let b=0;b<c;b++){let v=x.indexToLoc(b,p,m).map((E,$)=>E+u[$]),k=x.locToIndex(v,d,h);g[k]=l[b]}return{dataId:e.write(g,a,o.dtype),shape:a,dtype:o.dtype}}var tw={kernelName:Ns,backendName:"cpu",kernelFunc:SJ};var kJ=te((r,t)=>Math.pow(r,t)),NJ=ie(Ts,kJ),HO={kernelName:Ts,backendName:"cpu",kernelFunc:NJ};function TJ(r){let{backend:t,attrs:e}=r,{start:n,stop:o,dtype:s,step:i}=e,a=qc(n,o,i,s);return t.makeTensorInfo([a.length],s,a)}var qO={kernelName:Ll,backendName:"cpu",kernelFunc:TJ};var _J=Et($a,r=>1/r),KO={kernelName:$a,backendName:"cpu",kernelFunc:_J};function EJ(r){let{inputs:t,backend:e,attrs:n}=r,{images:o}=t,{alignCorners:s,halfPixelCenters:i,size:a}=n;nt(o,"resizeBilinear");let u=x.computeStrides(o.shape),[l,c]=a,[p,m,f,d]=o.shape,h=e.data.get(o.dataId).values,g=new Float32Array(x.sizeFromShape([p,l,c,d])),y=[s&&l>1?m-1:m,s&&c>1?f-1:f],b=[s&&l>1?l-1:l,s&&c>1?c-1:c],w=0,v=y[0]/b[0],k=y[1]/b[1];for(let E=0;E<p;E++)for(let $=0;$<l;$++){let D;i?D=v*($+.5)-.5:D=v*$;let R=Math.max(0,Math.floor(D)),P=D-R,W=Math.min(m-1,Math.ceil(D)),U=E*u[0]+R*u[1],q=E*u[0]+W*u[1];for(let K=0;K<c;K++){let j;i?j=k*(K+.5)-.5:j=k*K;let Q=Math.max(0,Math.floor(j)),rt=j-Q,X=Math.min(f-1,Math.ceil(j)),ot=U+Q*u[2],st=q+Q*u[2],it=U+X*u[2],ft=q+X*u[2];for(let at=0;at<d;at++){let xt=h[ot+at],dt=h[st+at],bt=h[it+at],kt=h[ft+at],At=xt+(bt-xt)*rt,Dt=dt+(kt-dt)*rt,qt=At+(Dt-At)*P;g[w++]=qt}}}return e.makeTensorInfo([p,l,c,d],"float32",g)}var jO={kernelName:As,backendName:"cpu",kernelFunc:EJ};function AJ(r){let{inputs:t,backend:e,attrs:n}=r,{images:o,dy:s}=t,{alignCorners:i}=n;nt([s,o],"resizeBilinearGrad");let a=x.computeStrides(o.shape),[u,l,c,p]=o.shape,[,m,f]=s.shape,d=new Float32Array(u*l*c*p),h=[i&&m>1?l-1:l,i&&f>1?c-1:c],g=[i&&m>1?m-1:m,i&&f>1?f-1:f],y=h[0]/g[0],b=h[1]/g[1],w=e.data.get(s.dataId).values,v=0;for(let k=0;k<u;k++){let E=k*a[0];for(let $=0;$<m;$++){let D=$*y,R=Math.floor(D),P=Math.min(Math.ceil(D),l-1),W=E+R*a[1],U=E+P*a[1],q=D-R,K=1-q;for(let j=0;j<f;j++){let Q=j*b,rt=Math.floor(Q),X=Math.min(Math.ceil(Q),c-1),ot=Q-rt,st=1-ot,it=W+rt*a[2],ft=W+X*a[2],at=U+rt*a[2],xt=U+X*a[2],dt=K*st,bt=K*ot,kt=q*st,At=q*ot;for(let Dt=0;Dt<p;Dt++){let qt=w[v++];d[it+Dt]+=qt*dt,d[ft+Dt]+=qt*bt,d[at+Dt]+=qt*kt,d[xt+Dt]+=qt*At}}}}return e.makeTensorInfo([u,c,l,p],"float32",d)}var XO={kernelName:Zp,backendName:"cpu",kernelFunc:AJ};function $J(r){let{inputs:t,backend:e,attrs:n}=r,{images:o}=t,{alignCorners:s,halfPixelCenters:i,size:a}=n;nt(o,"resizeNearestNeighbor");let u=x.computeStrides(o.shape),[l,c]=a,[p,m,f,d]=o.shape,h=e.data.get(o.dataId).values,g=new Float32Array(p*l*c*d),y=[s&&l>1?m-1:m,s&&c>1?f-1:f],b=[s&&l>1?l-1:l,s&&c>1?c-1:c],w=y[0]/b[0],v=y[1]/b[1],k=0;for(let E=0;E<p;E++){let $=E*u[0];for(let D=0;D<l;D++){let R=i?w*(D+.5):w*D,P=Math.min(m-1,s?Math.round(R):Math.floor(R));i&&(P=Math.max(0,P));let W=$+P*u[1];for(let U=0;U<c;U++){let q=i?v*(U+.5):v*U,K=Math.min(f-1,s?Math.round(q):Math.floor(q));i&&(K=Math.max(0,K));let j=W+K*u[2];for(let Q=0;Q<d;Q++){let rt=h[j+Q];g[k++]=rt}}}}return e.makeTensorInfo([p,l,c,d],o.dtype,g)}var YO={kernelName:zl,backendName:"cpu",kernelFunc:$J};function DJ(r){let{inputs:t,backend:e,attrs:n}=r,{images:o,dy:s}=t,{alignCorners:i}=n;nt([s,o],"resizeNearestNeighborGrad");let a=x.computeStrides(o.shape),u=x.computeStrides(s.shape),[l,c,p,m]=o.shape,[,f,d]=s.shape,h=new Float32Array(l*c*p*m),g=e.data.get(s.dataId).values,y=[i&&f>1?c-1:c,i&&d>1?p-1:p],b=[i&&f>1?f-1:f,i&&d>1?d-1:d],w=y[0]/b[0],v=y[1]/b[1],k=1/w,E=1/v,$=Math.ceil(k)*2+2,D=Math.ceil(E)*2+2;for(let R=0;R<l;R++){let P=R*a[0];for(let W=0;W<c;W++){let U=P+W*a[1],q=Math.floor(W*k),K=Math.floor(q-$/2);for(let j=0;j<p;j++){let Q=U+j*a[2],rt=Math.floor(j*E),X=Math.floor(rt-D/2);for(let ot=0;ot<m;ot++){let st=0;for(let it=0;it<$;it++){let ft=it+K;if(ft<0||ft>=f)continue;let at=P+ft*u[1],xt=ft*w,dt=Math.min(c-1,i?Math.round(xt):Math.floor(xt));if(W===dt)for(let bt=0;bt<D;bt++){let kt=bt+X;if(kt<0||kt>=d)continue;let At=at+kt*u[2],Dt=kt*v,qt=Math.min(p-1,i?Math.round(Dt):Math.floor(Dt));j===qt&&(st+=g[At+ot])}}h[Q+ot]=st}}}}return e.makeTensorInfo(o.shape,o.dtype,h)}var ZO={kernelName:Yp,backendName:"cpu",kernelFunc:DJ};function RJ(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{dims:s}=n;nt(o,"reverse");let i=o.shape.length,a=x.parseAxisParam(s,o.shape);if(i===0)return qr({inputs:{x:o},backend:e});let u=new pe(o.shape,o.dtype),l=e.bufferSync(o);for(let c=0;c<u.size;c++){let p=u.indexToLoc(c),m=p.slice();a.forEach(f=>m[f]=o.shape[f]-1-m[f]),u.set(l.get(...m),...p)}return e.makeTensorInfo(u.shape,u.dtype,u.values)}var JO={kernelName:Ds,backendName:"cpu",kernelFunc:RJ};var QO={kernelName:Va,backendName:"cpu",kernelFunc:({inputs:r,attrs:t,backend:e})=>{let{image:n}=r,{radians:o,fillValue:s,center:i}=t,a=e,u=x.getTypedArrayFromDType(n.dtype,x.sizeFromShape(n.shape)),[l,c,p,m]=n.shape,[f,d]=S.getImageCenter(i,c,p),h=255,g=Math.sin(o),y=Math.cos(o),b=a.data.get(n.dataId).values;for(let v=0;v<l;v++){let k=v*p*c*m;for(let E=0;E<c;E++){let $=E*(p*m);for(let D=0;D<p;D++){let R=D*m;for(let P=0;P<m;P++){let W=[l,E,D,P],U=W[2],q=W[1],K=(U-f)*y-(q-d)*g,j=(U-f)*g+(q-d)*y;K=Math.round(K+f),j=Math.round(j+d);let Q=s;if(typeof s!="number"&&(P===3?Q=h:Q=s[P]),K>=0&&K<p&&j>=0&&j<c){let X=j*(p*m),ot=K*m,st=k+X+ot+P;Q=b[st]}let rt=k+$+R+P;u[rt]=Q}}}}return{dataId:a.write(u,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}};var FJ=Et(Rs,r=>{let t=Math.floor(r);return r-t<.5?Math.floor(r):r-t>.5?Math.ceil(r):t%2===0?t:t+1}),tM={kernelName:Rs,backendName:"cpu",kernelFunc:FJ};function ew(r,t,e,n,o,s,i,a,u,l){let c=[n/o,o],p=r.values,m=t.values;if(n===0)return It(e,t.dtype);let f=It(c,t.dtype);f.values.fill(u);for(let d=0;d<s;d++){let h=[],g=0;for(let y=0;y<i;y++){let b=p[d*i+y];h.push(b),g+=b*a[y]}if(g<0||g>=n/o)throw new Error(`Invalid indices: ${h} does not index into ${e}`);for(let y=0;y<o;y++)l?f.values[g*o+y]+=m[d*o+y]:f.values[g*o+y]=t.rank===0?m[0]:m[d*o+y]}return f}function OJ(r){let{inputs:t,backend:e,attrs:n}=r,{indices:o,updates:s}=t,{shape:i}=n,{sliceRank:a,numUpdates:u,sliceSize:l,strides:c,outputSize:p}=S.calculateShapes(s,o,i),m=!0,f=e.bufferSync(o),d=e.bufferSync(s),h=ew(f,d,i,p,l,u,a,c,0,m);return e.makeTensorInfo(i,h.dtype,h.values)}var eM={kernelName:Da,backendName:"cpu",kernelFunc:OJ};function MJ(r){let{inputs:t,backend:e}=r,{condition:n,t:o,e:s}=t;nt([n,o,s],"select");let i=n.shape.length,a=e.data.get(n.dataId).values,u=e.data.get(o.dataId).values,l=e.data.get(s.dataId).values,c=ar(o.dtype,s.dtype),p=x.makeZerosTypedArray(x.sizeFromShape(o.shape),c),m=0,f=i===0||i>1||o.shape.length===1?1:x.sizeFromShape(o.shape.slice(1));for(let d=0;d<a.length;d++)for(let h=0;h<f;h++)a[d]===1?p[m++]=u[d]:p[m++]=l[d];return e.makeTensorInfo(o.shape,c,p)}var rM={kernelName:_i,backendName:"cpu",kernelFunc:MJ};var PJ=S.SELU_SCALEALPHA,LJ=S.SELU_SCALE,zJ=Et(Ra,r=>r>=0?LJ*r:PJ*(Math.exp(r)-1)),nM={kernelName:Ra,backendName:"cpu",kernelFunc:zJ};var BJ=Et(Oa,r=>r<0?-1:r>0?1:0),oM={kernelName:Oa,backendName:"cpu",kernelFunc:BJ};var VJ=Et(Os,r=>Math.sin(r)),sM={kernelName:Os,backendName:"cpu",kernelFunc:VJ};var GJ=Et(Fa,r=>Math.sinh(r)),iM={kernelName:Fa,backendName:"cpu",kernelFunc:GJ};var WJ=11920928955078125e-23,aM=Math.log(WJ)+2,UJ=Et(Ma,r=>{let t=r>-aM,e=r<aM,n=Math.exp(r),o;return e?o=n:t?o=r:o=Math.log(1+n),o}),lM={kernelName:Ma,backendName:"cpu",kernelFunc:UJ};function HJ(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{blockShape:s,paddings:i}=n;nt([o],"spaceToBatchND");let a=x.sizeFromShape(s),u=[[0,0]];u.push(...i);for(let E=1+s.length;E<o.shape.length;++E)u.push([0,0]);let l=tw.kernelFunc({inputs:{x:o},backend:e,attrs:{paddings:u,constantValue:0}}),c=S.getReshaped(l.shape,s,a,!1),p=S.getPermuted(c.length,s.length,!1),m=S.getReshapedPermuted(l.shape,s,a,!1),h=ne({inputs:{x:l},backend:e,attrs:{shape:c}}),b=He({inputs:{x:h},backend:e,attrs:{perm:p}}),k=ne({inputs:{x:b},backend:e,attrs:{shape:m}});return e.disposeIntermediateTensorInfo(l),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(b),k}var uM={kernelName:Ai,backendName:"cpu",kernelFunc:HJ};function qJ(r){let{inputs:t,backend:e}=r,{indices:n,values:o,denseShape:s,defaultValue:i}=t;if(s.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${s.shape}`);if(n.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${n.shape}`);if(o.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${o.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);let a=e.data.get(n.dataId).values,u=e.data.get(o.dataId).values,l=e.data.get(s.dataId).values,c=e.data.get(i.dataId).values[0],[p,m,f,d,h]=Vb(a,n.shape,n.dtype,u,o.dtype,l,c);return[e.makeTensorInfo(m,n.dtype,p),e.makeTensorInfo([m[0]],o.dtype,f),e.makeTensorInfo([d.length],"bool",new Uint8Array(d.map(g=>Number(g)))),e.makeTensorInfo([h.length],n.dtype,new Int32Array(h))]}var cM={kernelName:Bl,backendName:"cpu",kernelFunc:qJ};function KJ(r){let{inputs:t,backend:e}=r,{inputIndices:n,inputShape:o,newShape:s}=t;if(n.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${n.shape}`);if(o.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${o.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let i=Array.from(e.data.get(o.dataId).values),a=e.data.get(n.dataId).values,u=Array.from(e.data.get(s.dataId).values),[l,c,p]=Gb(a,n.shape,n.dtype,i,u);return[e.makeTensorInfo(c,n.dtype,l),e.makeTensorInfo([p.length],s.dtype,new Int32Array(p))]}var pM={kernelName:Pa,backendName:"cpu",kernelFunc:KJ};function jJ(r){let{inputs:t,backend:e}=r,{data:n,indices:o,segmentIds:s}=t;if(n.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${o.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${s.shape}`);if(o.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");let i=e.data.get(n.dataId).values,a=e.data.get(o.dataId).values,u=e.data.get(s.dataId).values,[l,c]=od(i,n.shape,n.dtype,a,u,!0);return e.makeTensorInfo(c,n.dtype,l)}var mM={kernelName:Vl,backendName:"cpu",kernelFunc:jJ};function XJ(r){let{inputs:t,backend:e}=r,{data:n,indices:o,segmentIds:s}=t;if(n.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${o.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${s.shape}`);if(o.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");let i=e.data.get(n.dataId).values,a=e.data.get(o.dataId).values,u=e.data.get(s.dataId).values,[l,c]=od(i,n.shape,n.dtype,a,u);return e.makeTensorInfo(c,n.dtype,l)}var fM={kernelName:Gl,backendName:"cpu",kernelFunc:XJ};function YJ(r){let{inputs:t,backend:e,attrs:n}=r,{sparseIndices:o,sparseValues:s,defaultValue:i}=t,{outputShape:a}=n,{sliceRank:u,numUpdates:l,sliceSize:c,strides:p,outputSize:m}=S.calculateShapes(s,o,a),f=!1,d=e.bufferSync(o),h=e.bufferSync(s),g=e.data.get(i.dataId).values[0],y=ew(d,h,a,m,c,l,u,p,g,f);return e.makeTensorInfo(a,y.dtype,y.values)}var dM={kernelName:Jp,backendName:"cpu",kernelFunc:YJ};function ZJ(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{numOrSizeSplits:s,axis:i}=n,a=x.parseAxisParam(i,o.shape)[0],u=S.prepareSplitSize(o,s,a),l=new Array(o.shape.length).fill(0),c=o.shape.slice();return u.map(p=>{let m=[...c];m[a]=p;let f=Mo({inputs:{x:o},backend:e,attrs:{begin:l,size:m}});return l[a]+=p,f})}var hM={kernelName:$i,backendName:"cpu",kernelFunc:ZJ};var gM={kernelName:Wl,backendName:"cpu",kernelFunc:({inputs:r,backend:t})=>{let{x:e}=r,n=t;nt(e,"square");let o=n.data.get(e.dataId).values,s=new Float32Array(o.length);for(let a=0;a<o.length;++a){let u=o[a];s[a]=u*u}return{dataId:n.write(s,e.shape,e.dtype),shape:e.shape,dtype:e.dtype}}};var JJ=Et(uo,(r,t)=>{let e=t;return isNaN(r)?NaN:r>0?1:e.alpha}),xM={kernelName:uo,backendName:"cpu",kernelFunc:JJ};function QJ(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{begin:s,end:i,strides:a,beginMask:u,endMask:l,ellipsisMask:c,newAxisMask:p,shrinkAxisMask:m}=n;nt(o,"stridedSlice");let{finalShapeSparse:f,finalShape:d,isIdentity:h,sliceDim0:g,isSimpleSlice:y,begin:b,end:w,strides:v}=Ve.sliceInfo(o.shape,s,i,a,u,l,c,p,m),k;if(h)k=ne({inputs:{x:o},backend:e,attrs:{shape:d}});else if(g||y){x.assert(o.shape.length>=1,()=>`Input must have rank at least 1, got: ${o.shape.length}`);let E=Ve.computeOutShape(b,w,v),$=Mo({inputs:{x:o},backend:e,attrs:{begin:b,size:E}});k=ne({inputs:{x:$},backend:e,attrs:{shape:d}}),e.disposeIntermediateTensorInfo($)}else{let E=e.bufferSync(o),$=Wb(f,E,v,b);k=e.makeTensorInfo(d,$.dtype,$.values)}return k}var yM={kernelName:La,backendName:"cpu",kernelFunc:QJ};function tQ(r){let{inputs:t,backend:e,attrs:n}=r,{separator:o,nGramWidths:s,leftPad:i,rightPad:a,padWidth:u,preserveShortSequences:l}=n,{data:c,dataSplits:p}=t,m=e.data.get(c.dataId).values,f=e.data.get(p.dataId).values,[d,h]=Ub(m,f,o,s,i,a,u,l);return[e.makeTensorInfo([d.length],"string",d),e.makeTensorInfo(p.shape,"int32",h)]}var bM={kernelName:Qp,backendName:"cpu",kernelFunc:tQ};function eQ(r){let{inputs:t,backend:e,attrs:n}=r,{skipEmpty:o}=n,{input:s,delimiter:i}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(s.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);let a=e.data.get(s.dataId).values,u=e.data.get(i.dataId).values[0],[l,c,p]=Hb(a,u,o),m=c.length;return[e.makeTensorInfo([m,2],"int32",l),e.makeTensorInfo([m],"string",c),e.makeTensorInfo([2],"int32",new Int32Array(p))]}var wM={kernelName:tm,backendName:"cpu",kernelFunc:eQ};function rQ(r){let{inputs:t,backend:e,attrs:n}=r,{numBuckets:o}=n,{input:s}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(o<=0)throw new Error("Number of buckets must be at least 1");let i=e.data.get(s.dataId).values,a=qb(i,o);return e.makeTensorInfo(s.shape,"int32",a)}var vM={kernelName:em,backendName:"cpu",kernelFunc:rQ};var nQ=Et(Gs,r=>Math.tan(r)),CM={kernelName:Gs,backendName:"cpu",kernelFunc:nQ};var oQ=Et(Ws,r=>Math.tanh(r)),IM={kernelName:Ws,backendName:"cpu",kernelFunc:oQ};function sQ(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{reps:s}=n;nt(o,"tile");let i=Kb(e.bufferSync(o),s);return e.makeTensorInfo(i.shape,i.dtype,i.values)}var SM={kernelName:Yn,backendName:"cpu",kernelFunc:sQ};function iQ(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{k:s,sorted:i}=n;nt(o,"topk");let a=e.data.get(o.dataId).values,[u,l]=jb(a,o.shape,o.dtype,s,i);return[e.makeTensorInfo(u.shape,u.dtype,u.values),e.makeTensorInfo(l.shape,l.dtype,l.values)]}var kM={kernelName:za,backendName:"cpu",kernelFunc:iQ};function aQ(r){let{inputs:t,attrs:e,backend:n}=r,{image:o,transforms:s}=t,{interpolation:i,fillMode:a,fillValue:u,outputShape:l}=e,[c,p,m,f]=o.shape,[d,h]=l!=null?l:[p,m],g=[c,d,h,f],y=x.computeStrides(o.shape),b=y[0],w=y[1],v=y[2],k=x.getTypedArrayFromDType(o.dtype,x.sizeFromShape(g));k.fill(u);let E=n.data.get(o.dataId).values,$=n.data.get(s.dataId).values;for(let R=0;R<c;++R){let P=s.shape[0]===1?$:$.subarray(R*8,R*8+8);for(let W=0;W<d;++W)for(let U=0;U<h;++U)for(let q=0;q<f;++q){let K,j=P[6]*U+P[7]*W+1;if(j===0)continue;let Q=(P[0]*U+P[1]*W+P[2])/j,rt=(P[3]*U+P[4]*W+P[5])/j,X=NM(Q,m,a),ot=NM(rt,p,a);switch(i){case"nearest":K=mQ(E,p,m,b,w,v,R,ot,X,q,u);break;case"bilinear":K=fQ(E,p,m,b,w,v,R,ot,X,q,u);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${i}`)}let st=R*b+W*w+U*v+q;k[st]=K}return n.makeTensorInfo(g,o.dtype,k)}return{dataId:n.write(k,g,o.dtype),shape:o.shape,dtype:o.dtype}}var TM={kernelName:Ba,backendName:"cpu",kernelFunc:aQ};function NM(r,t,e){switch(e){case"reflect":return lQ(r,t);case"wrap":return uQ(r,t);case"nearest":return pQ(r,t);case"constant":default:return cQ(r,t)}}function lQ(r,t){let e=r;if(e<0)if(t<=1)e=0;else{let n=2*t;e<n&&(e=n*Math.trunc(-e/n)+e),e=e<-t?e+n:-e-1}else if(e>t-1)if(t<=1)e=0;else{let n=2*t;e-=n*Math.trunc(e/n),e>=t&&(e=n-e-1)}return x.clamp(0,e,t-1)}function uQ(r,t){let e=r;if(e<0)if(t<=1)e=0;else{let n=t-1;e+=t*(Math.trunc(-e/n)+1)}else if(e>t-1)if(t<=1)e=0;else{let n=t-1;e-=t*Math.trunc(e/n)}return x.clamp(0,e,t-1)}function cQ(r,t){return r}function pQ(r,t){return x.clamp(0,r,t-1)}function gg(r,t,e,n,o,s,i,a,u,l,c){let p=i*n+a*o+u*s+l;return 0<=a&&a<t&&0<=u&&u<e?r[p]:c}function mQ(r,t,e,n,o,s,i,a,u,l,c){let p=Math.round(a),m=Math.round(u);return gg(r,t,e,n,o,s,i,p,m,l,c)}function fQ(r,t,e,n,o,s,i,a,u,l,c){let p=Math.floor(a),m=Math.floor(u),f=p+1,d=m+1,h=(d-u)*gg(r,t,e,n,o,s,i,p,m,l,c)+(u-m)*gg(r,t,e,n,o,s,i,p,d,l,c),g=(d-u)*gg(r,t,e,n,o,s,i,f,m,l,c)+(u-m)*gg(r,t,e,n,o,s,i,f,d,l,c);return(f-a)*h+(a-p)*g}function dQ(r){let{inputs:t,attrs:e,backend:n}=r,{axis:o}=e,{x:s}=t;nt(s,"unique");let i=n.data.get(s.dataId).values,{outputValues:a,outputShape:u,indices:l}=Xb(i,o,s.shape,s.dtype);return[n.makeTensorInfo(u,s.dtype,a),n.makeTensorInfo([l.length],"int32",l)]}var _M={kernelName:rm,backendName:"cpu",kernelFunc:dQ};function hQ(r){let{inputs:t,backend:e,attrs:n}=r,{value:o}=t,{axis:s}=n;s<0&&(s+=o.shape.length);let i=o.shape.length,a=o.shape[s],u=new Array(i-1),l=0;for(let f=0;f<i;f++)f!==s&&(u[l++]=o.shape[f]);let c=new Array(i).fill(0),p=o.shape.slice();p[s]=1;let m=new Array(a);for(let f=0;f<m.length;f++){c[s]=f;let d=Mo({inputs:{x:o},backend:e,attrs:{begin:c,size:p}});m[f]=ne({inputs:{x:d},backend:e,attrs:{shape:u}}),e.disposeIntermediateTensorInfo(d)}return m}var EM={kernelName:Di,backendName:"cpu",kernelFunc:hQ};function gQ(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,segmentIds:s}=t,{numSegments:i}=n;nt(o,"unsortedSegmentSum");let a=o.shape.length,u=s.shape.length,l=[],c=[],p=a-u,m=s;for(let d=0;d<p;++d){let h=ad({inputs:{input:m},backend:e,attrs:{dim:d+1}});m=h,c.push(h)}for(let d=0;d<i;++d){let h=x.createScalarValue(d,"int32"),g=e.makeTensorInfo([],"int32",h),y=Kk({inputs:{a:g,b:m},backend:e}),b=Fo({inputs:{x:y},backend:e,attrs:{dtype:"float32"}}),w=Hc({inputs:{a:b,b:o},backend:e}),v=bl({inputs:{x:w},backend:e,attrs:{axis:0,keepDims:!1}});l.push(v),c.push(g),c.push(y),c.push(b),c.push(w),c.push(v)}let f=SN({inputs:l,backend:e,attrs:{axis:0}});return c.forEach(d=>e.disposeIntermediateTensorInfo(d)),f}var AM={kernelName:Ul,backendName:"cpu",kernelFunc:gQ};var xQ=[aF,CR,lF,uF,TR,cF,pF,mF,fF,dF,hF,gF,xF,yF,bF,vF,CF,IF,SF,iF,kF,NF,TF,_F,NR,_R,EF,IR,AF,DF,RF,FF,OF,MF,PF,LF,zF,BF,VF,GF,WF,UF,HF,qF,KF,jF,XF,YF,ZF,JF,tO,tF,eO,ER,rO,AR,nO,$R,oO,sO,iO,DR,aO,lO,uO,cO,pO,RR,FR,SR,mO,$F,fO,dO,hO,eF,OR,MR,gO,PR,xO,yO,bO,wO,vO,CO,IO,LR,SO,kO,NO,TO,EO,AO,$O,zR,DO,RO,MO,BR,VR,PO,LO,zO,GR,BO,WO,UO,tw,HO,rF,UR,qO,kR,fg,KO,nF,oF,sF,jO,XO,YO,ZO,JO,QO,tM,HR,eM,rM,nM,KR,oM,sM,iM,jR,FO,lM,uM,cM,pM,mM,fM,dM,hM,YR,gM,ZR,xM,yM,bM,wM,vM,JR,QF,CM,IM,SM,kM,TM,WR,_M,EM,AM,VO];for(let r of xQ)Pu(r);var cd={};Yt(cd,{assertNotComplex:()=>fi,bindCanvasToFramebuffer:()=>NQ,bindColorTextureToFramebuffer:()=>wg,bindTextureToProgramUniformSampler:()=>VN,bindTextureUnit:()=>FM,bindVertexBufferToProgramAttribute:()=>iw,callAndCheck:()=>vt,canBeRepresented:()=>EN,createFragmentShader:()=>$N,createFramebuffer:()=>LN,createProgram:()=>DN,createStaticIndexBuffer:()=>ON,createStaticVertexBuffer:()=>FN,createTexture:()=>MN,createVertexShader:()=>AN,getBatchDim:()=>vl,getExtensionOrThrow:()=>ld,getFramebufferErrorMessage:()=>OM,getMaxTexturesInShader:()=>UN,getNumChannels:()=>SQ,getProgramUniformLocation:()=>BN,getProgramUniformLocationOrThrow:()=>zN,getRowsCols:()=>Cl,getShapeAs3D:()=>vg,getTextureShapeFromLogicalShape:()=>GN,getWebGLDisjointQueryTimerVersion:()=>HN,getWebGLErrorMessage:()=>RM,getWebGLMaxTextureSize:()=>WN,hasExtension:()=>Un,isCapableOfRenderingToFloatTexture:()=>qN,isDownloadFloatTextureEnabled:()=>KN,isReshapeFree:()=>yu,isWebGLFenceEnabled:()=>jN,isWebGLVersionEnabled:()=>lw,linkProgram:()=>RN,logShaderSourceAndInfoLog:()=>sw,resetMaxTextureSize:()=>TQ,resetMaxTexturesInShader:()=>_Q,unbindColorTextureFromFramebuffer:()=>aw,unbindTextureUnit:()=>kQ,validateFramebuffer:()=>ud,validateProgram:()=>bg,validateTextureSize:()=>PN});var jc={},kN={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function NN(r,t){jc[r]=t}function Wn(r,t){if(!(r in jc)||t!=null){let n=bQ(r,t);if(n!==null)jc[r]=n;else return console.log("Could not get context for WebGL version",r),null}let e=jc[r];return e==null||e.isContextLost()?(delete jc[r],Wn(r)):(e.disable(e.DEPTH_TEST),e.disable(e.STENCIL_TEST),e.disable(e.BLEND),e.disable(e.DITHER),e.disable(e.POLYGON_OFFSET_FILL),e.disable(e.SAMPLE_COVERAGE),e.enable(e.SCISSOR_TEST),e.enable(e.CULL_FACE),e.cullFace(e.BACK),jc[r])}function yQ(r){if(typeof OffscreenCanvas!="undefined"&&r===2)return new OffscreenCanvas(300,150);if(typeof document!="undefined")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function bQ(r,t){if(r!==1&&r!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");let e=t==null?yQ(r):t;return e.addEventListener("webglcontextlost",n=>{n.preventDefault(),delete jc[r]},!1),r===1?e.getContext("webgl",kN)||e.getContext("experimental-webgl",kN):e.getContext("webgl2",kN)}var xu;(function(r){r[r.DENSE=0]="DENSE",r[r.SHARED_BATCH=1]="SHARED_BATCH"})(xu||(xu={}));var Kr;(function(r){r[r.RENDER=0]="RENDER",r[r.UPLOAD=1]="UPLOAD",r[r.PIXELS=2]="PIXELS",r[r.DOWNLOAD=3]="DOWNLOAD"})(Kr||(Kr={}));var Rr;(function(r){r[r.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",r[r.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",r[r.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",r[r.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",r[r.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(Rr||(Rr={}));function Xc(r,t){return[t,r]}function $M(r,t){return r*t}function xg(r){let t=x.sizeFromShape(r),e=Math.ceil(t/4);return x.sizeToSquarishShape(e)}function Zi(r,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(r/2))]}function DM(r,t){let[e,n]=Zi(r,t);return e*n*4}function yg(r,t){let e=r,n,o,s,i,a,u,l,c,p,m;return V().getNumber("WEBGL_VERSION")===2?(n=e.R32F,o=e.R16F,s=e.RGBA16F,i=e.RGBA32F,a=e.RED,l=4,c=1,p=e.HALF_FLOAT,m=e.FLOAT,u=e.RGBA8):(n=r.RGBA,o=r.RGBA,s=r.RGBA,i=e.RGBA,a=r.RGBA,l=4,c=4,p=t!=null?t.HALF_FLOAT_OES:null,m=r.FLOAT,u=r.RGBA),{internalFormatFloat:n,internalFormatHalfFloat:o,internalFormatPackedHalfFloat:s,internalFormatPackedFloat:i,textureFormatFloat:a,downloadTextureFormat:u,downloadUnpackNumChannels:l,defaultNumChannels:c,textureTypeHalfFloat:p,textureTypeFloat:m}}function vt(r,t){let e=t();return V().getBool("DEBUG")&&wQ(r),e}function wQ(r){let t=r.getError();if(t!==r.NO_ERROR)throw new Error("WebGL Error: "+RM(r,t))}var vQ=596e-10,CQ=65504;function EN(r){return!!(V().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||r===0||vQ<Math.abs(r)&&Math.abs(r)<CQ)}function RM(r,t){switch(t){case r.NO_ERROR:return"NO_ERROR";case r.INVALID_ENUM:return"INVALID_ENUM";case r.INVALID_VALUE:return"INVALID_VALUE";case r.INVALID_OPERATION:return"INVALID_OPERATION";case r.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case r.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case r.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}function ld(r,t){return wl(r,()=>r.getExtension(t),'Extension "'+t+'" not supported on this browser.')}function AN(r,t){let e=wl(r,()=>r.createShader(r.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(vt(r,()=>r.shaderSource(e,t)),vt(r,()=>r.compileShader(e)),r.getShaderParameter(e,r.COMPILE_STATUS)===!1)throw console.log(r.getShaderInfoLog(e)),new Error("Failed to compile vertex shader.");return e}function $N(r,t){let e=wl(r,()=>r.createShader(r.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(vt(r,()=>r.shaderSource(e,t)),vt(r,()=>r.compileShader(e)),V().get("ENGINE_COMPILE_ONLY"))return e;if(r.getShaderParameter(e,r.COMPILE_STATUS)===!1)throw sw(t,r.getShaderInfoLog(e)),new Error("Failed to compile fragment shader.");return e}var IQ=/ERROR: [0-9]+:([0-9]+):/g;function sw(r,t){let e=IQ.exec(t);if(e==null){console.log(`Couldn't parse line number in error: ${t}`),console.log(r);return}let n=+e[1],o=r.split(`
`),s=o.length.toString().length+2,i=o.map((p,m)=>x.rightPad((m+1).toString(),s)+p),a=0;for(let p=0;p<i.length;p++)a=Math.max(i[p].length,a);let u=i.slice(0,n-1),l=i.slice(n-1,n),c=i.slice(n);console.log(u.join(`
`)),console.log(t.split(`
`)[0]),console.log(`%c ${x.rightPad(l[0],a)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(c.join(`
`))}function DN(r){return wl(r,()=>r.createProgram(),"Unable to create WebGLProgram.")}function RN(r,t){if(vt(r,()=>r.linkProgram(t)),!V().get("ENGINE_COMPILE_ONLY")&&r.getProgramParameter(t,r.LINK_STATUS)===!1)throw console.log(r.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}function bg(r,t){if(vt(r,()=>r.validateProgram(t)),r.getProgramParameter(t,r.VALIDATE_STATUS)===!1)throw console.log(r.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function FN(r,t){let e=wl(r,()=>r.createBuffer(),"Unable to create WebGLBuffer");return vt(r,()=>r.bindBuffer(r.ARRAY_BUFFER,e)),vt(r,()=>r.bufferData(r.ARRAY_BUFFER,t,r.STATIC_DRAW)),e}function ON(r,t){let e=wl(r,()=>r.createBuffer(),"Unable to create WebGLBuffer");return vt(r,()=>r.bindBuffer(r.ELEMENT_ARRAY_BUFFER,e)),vt(r,()=>r.bufferData(r.ELEMENT_ARRAY_BUFFER,t,r.STATIC_DRAW)),e}function SQ(){return V().getNumber("WEBGL_VERSION")===2?1:4}function MN(r){return wl(r,()=>r.createTexture(),"Unable to create WebGLTexture.")}function PN(r,t){let e=V().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(r<=0||t<=0){let n=`[${r}x${t}]`;throw new Error("Requested texture size "+n+" is invalid.")}if(r>e||t>e){let n=`[${r}x${t}]`,o=`[${e}x${e}]`;throw new Error("Requested texture size "+n+" greater than WebGL maximum on this browser / GPU "+o+".")}}function LN(r){return wl(r,()=>r.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function iw(r,t,e,n,o,s,i){let a=r.getAttribLocation(t,e);return a===-1?!1:(vt(r,()=>r.bindBuffer(r.ARRAY_BUFFER,n)),vt(r,()=>r.vertexAttribPointer(a,o,r.FLOAT,!1,s,i)),vt(r,()=>r.enableVertexAttribArray(a)),!0)}function FM(r,t,e){MM(r,e),vt(r,()=>r.activeTexture(r.TEXTURE0+e)),vt(r,()=>r.bindTexture(r.TEXTURE_2D,t))}function kQ(r,t){MM(r,t),vt(r,()=>r.activeTexture(r.TEXTURE0+t)),vt(r,()=>r.bindTexture(r.TEXTURE_2D,null))}function zN(r,t,e){return wl(r,()=>r.getUniformLocation(t,e),'uniform "'+e+'" not present in program.')}function BN(r,t,e){return r.getUniformLocation(t,e)}function VN(r,t,e,n){vt(r,()=>FM(r,t,n)),vt(r,()=>r.uniform1i(e,n))}function NQ(r){vt(r,()=>r.bindFramebuffer(r.FRAMEBUFFER,null)),vt(r,()=>r.viewport(0,0,r.canvas.width,r.canvas.height)),vt(r,()=>r.scissor(0,0,r.canvas.width,r.canvas.height))}function wg(r,t,e){vt(r,()=>r.bindFramebuffer(r.FRAMEBUFFER,e)),vt(r,()=>r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,t,0))}function aw(r,t){vt(r,()=>r.bindFramebuffer(r.FRAMEBUFFER,t)),vt(r,()=>r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,null,0))}function ud(r){let t=r.checkFramebufferStatus(r.FRAMEBUFFER);if(t!==r.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+OM(r,t))}function OM(r,t){switch(t){case r.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case r.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case r.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case r.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}function wl(r,t,e){let n=vt(r,()=>t());if(n==null)throw new Error(e);return n}function MM(r,t){let e=r.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,n=t+r.TEXTURE0;if(n<r.TEXTURE0||n>e){let o=`[gl.TEXTURE0, gl.TEXTURE${e}]`;throw new Error(`textureUnit must be in ${o}.`)}}function vl(r,t=2){return x.sizeFromShape(r.slice(0,r.length-t))}function Cl(r){if(r.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[r.length>1?r[r.length-2]:1,r[r.length-1]]}function vg(r){let t=[1,1,1];return r.length===0||r.length===1&&r[0]===1||(t=[vl(r),...Cl(r)]),t}function GN(r,t=!1){let e=V().getNumber("WEBGL_MAX_TEXTURE_SIZE");t&&(e=e*2,r=r.map((o,s)=>s>=r.length-2?x.nearestLargerEven(r[s]):r[s]),r.length===1&&(r=[2,r[0]])),r.length!==2&&(r=x.squeezeShape(r).newShape);let n=x.sizeFromShape(r);if(r.length<=1&&n<=e)return[1,n];if(r.length===2&&r[0]<=e&&r[1]<=e)return r;if(r.length===3&&r[0]*r[1]<=e&&r[2]<=e)return[r[0]*r[1],r[2]];if(r.length===3&&r[0]<=e&&r[1]*r[2]<=e)return[r[0],r[1]*r[2]];if(r.length===4&&r[0]*r[1]*r[2]<=e&&r[3]<=e)return[r[0]*r[1]*r[2],r[3]];if(r.length===4&&r[0]<=e&&r[1]*r[2]*r[3]<=e)return[r[0],r[1]*r[2]*r[3]];if(t){let o=vl(r),s=2,i=2;return r.length&&([s,i]=Cl(r)),n=o*(s/2)*(i/2),x.sizeToSquarishShape(n).map(a=>a*2)}return x.sizeToSquarishShape(n)}function rw(r){return r%2===0}function yu(r,t){if(r=r.slice(-2),t=t.slice(-2),x.arraysEqual(r,t)||!r.length||!t.length||r[0]===0||r[1]===0||t[0]===0||t[1]===0)return!0;if(r.length!==t.length){let e=r.slice(-1)[0],n=t.slice(-1)[0];if(e===n||rw(e)&&rw(n)&&(r[0]===1||t[0]===1))return!0}return r[1]===t[1]&&rw(r[0])&&rw(t[0])}var nw,ow;function WN(r){if(nw==null){let t=Wn(r);nw=t.getParameter(t.MAX_TEXTURE_SIZE)}return nw}function TQ(){nw=null}function _Q(){ow=null}function UN(r){if(ow==null){let t=Wn(r);ow=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,ow)}function HN(r){if(r===0)return 0;let t,e=Wn(r);return Un(e,"EXT_disjoint_timer_query_webgl2")&&r===2?t=2:Un(e,"EXT_disjoint_timer_query")?t=1:t=0,t}function Un(r,t){return r.getExtension(t)!=null}function lw(r){try{if(Wn(r)!=null)return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function qN(r){if(r===0)return!1;let t=Wn(r);if(r===1){if(!Un(t,"OES_texture_float"))return!1}else if(!Un(t,"EXT_color_buffer_float"))return!1;return _N(t)}function KN(r){if(r===0)return!1;let t=Wn(r);if(r===1){if(!Un(t,"OES_texture_float")||!Un(t,"WEBGL_color_buffer_float"))return!1}else{if(Un(t,"EXT_color_buffer_float"))return _N(t);let n="EXT_color_buffer_half_float";if(Un(t,n)){let o=t.getExtension(n);return EQ(t,o)}return!1}return _N(t)}function _N(r){let t=yg(r),e=r.createTexture();r.bindTexture(r.TEXTURE_2D,e);let n=1,o=1;r.texImage2D(r.TEXTURE_2D,0,t.internalFormatFloat,n,o,0,t.textureFormatFloat,t.textureTypeFloat,null);let s=r.createFramebuffer();r.bindFramebuffer(r.FRAMEBUFFER,s),r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,e,0);let i=r.checkFramebufferStatus(r.FRAMEBUFFER)===r.FRAMEBUFFER_COMPLETE;return r.bindTexture(r.TEXTURE_2D,null),r.bindFramebuffer(r.FRAMEBUFFER,null),r.deleteTexture(e),r.deleteFramebuffer(s),i}function EQ(r,t){let e=yg(r,t),n=r.createTexture();r.bindTexture(r.TEXTURE_2D,n);let o=1,s=1;r.texImage2D(r.TEXTURE_2D,0,e.internalFormatHalfFloat,o,s,0,e.textureFormatFloat,e.textureTypeHalfFloat,null);let i=r.createFramebuffer();r.bindFramebuffer(r.FRAMEBUFFER,i),r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,n,0);let a=r.checkFramebufferStatus(r.FRAMEBUFFER)===r.FRAMEBUFFER_COMPLETE;return r.bindTexture(r.TEXTURE_2D,null),r.bindFramebuffer(r.FRAMEBUFFER,null),r.deleteTexture(n),r.deleteFramebuffer(i),a}function jN(r){return r!==2?!1:Wn(r).fenceSync!=null}function fi(r,t){Array.isArray(r)||(r=[r]),r.forEach(e=>{e!=null&&x.assert(e.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the WebGL backend.`)})}var Ft=V();Ft.registerFlag("HAS_WEBGL",()=>Ft.getNumber("WEBGL_VERSION")>0);Ft.registerFlag("WEBGL_VERSION",()=>lw(2)?2:lw(1)?1:0);Ft.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);Ft.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>Ft.get("WEBGL_VERSION")===2);Ft.registerFlag("WEBGL_CPU_FORWARD",()=>!0);Ft.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);Ft.registerFlag("WEBGL_PACK",()=>Ft.getBool("HAS_WEBGL"));Ft.registerFlag("WEBGL_PACK_NORMALIZATION",()=>Ft.getBool("WEBGL_PACK"));Ft.registerFlag("WEBGL_PACK_CLIP",()=>Ft.getBool("WEBGL_PACK"));Ft.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>Ft.getBool("WEBGL_PACK"));Ft.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>Ft.getBool("WEBGL_PACK"));Ft.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>Ft.getBool("WEBGL_PACK"));Ft.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>Ft.getBool("WEBGL_PACK"));Ft.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>Ft.getBool("WEBGL_PACK"));Ft.registerFlag("WEBGL_PACK_REDUCE",()=>Ft.getBool("WEBGL_PACK"));Ft.registerFlag("WEBGL_LAZILY_UNPACK",()=>Ft.getBool("WEBGL_PACK"));Ft.registerFlag("WEBGL_CONV_IM2COL",()=>Ft.getBool("WEBGL_PACK"));Ft.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>WN(Ft.getNumber("WEBGL_VERSION")));Ft.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>UN(Ft.getNumber("WEBGL_VERSION")));Ft.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{let r=Ft.getNumber("WEBGL_VERSION");return r===0?0:HN(r)});Ft.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>Ft.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!jl.isMobile());Ft.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>qN(Ft.getNumber("WEBGL_VERSION")));Ft.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>Ft.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:Ft.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));Ft.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>KN(Ft.getNumber("WEBGL_VERSION")));Ft.registerFlag("WEBGL_FENCE_API_ENABLED",()=>jN(Ft.getNumber("WEBGL_VERSION")));Ft.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>Ft.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);Ft.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,r=>{if(r<0&&r!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${r}.`)});Ft.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>jl.isMobile()?1:-1,r=>{if(r<0&&r!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${r}.`)});Ft.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);Ft.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);Ft.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);Ft.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);function qe(){let r,t,e,n,o,s,i,a,u,l;return V().getNumber("WEBGL_VERSION")===2?(r="#version 300 es",t="in",e="out",n="in",o="texture",s="outputColor",i="out vec4 outputColor;",a=`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `,u="",l=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(r="",t="attribute",e="varying",n="varying",o="texture2D",s="gl_FragColor",i="",a=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,u=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,l=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:r,attribute:t,varyingVs:e,varyingFs:n,texture2D:o,output:s,defineOutput:i,defineSpecialNaN:a,defineSpecialInf:u,defineRound:l}}function di(r,t,e="index"){let n=x.computeStrides(t);return n.map((o,s)=>{let i=`int ${r[s]} = ${e} / ${o}`,a=s===n.length-1?`int ${r[s+1]} = ${e} - ${r[s]} * ${o}`:`index -= ${r[s]} * ${o}`;return`${i}; ${a};`}).join("")}function Yc(r,t,e="index"){let n=x.computeStrides(t);return n.map((o,s)=>{let i=`int ${r[s]} = ${e} / outShapeStrides[${s}]`,a=s===n.length-1?`int ${r[s+1]} = ${e} - ${r[s]} * outShapeStrides[${s}]`:`index -= ${r[s]} * outShapeStrides[${s}]`;return`${i}; ${a};`}).join("")}function AQ(r,t){let e=r.length,n=r.map(s=>`${t}[${s}]`),o=new Array(e-1);o[e-2]=n[e-1];for(let s=e-3;s>=0;--s)o[s]=`(${o[s+1]} * ${n[s+1]})`;return o}function PM(r,t,e="index"){let n=r.map((s,i)=>i),o=AQ(n,t);return o.map((s,i)=>{let a=`int ${r[i]} = ${e} / ${o[i]}`,u=i===o.length-1?`int ${r[i+1]} = ${e} - ${r[i]} * ${o[i]}`:`index -= ${r[i]} * ${o[i]}`;return`${a}; ${u};`}).join("")}function pd(r){let t=x.computeStrides(r).map(e=>e.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;
  }
`}function md(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}var uw=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;var{getBroadcastDims:LM}=S;function zM(r,t,e){let n=[];if(r.forEach(f=>{let d=x.sizeFromShape(f.shapeInfo.logicalShape);if(f.shapeInfo.isUniform?n.push(`uniform float ${f.name}${d>1?`[${d}]`:""};`):(n.push(`uniform sampler2D ${f.name};`),n.push(`uniform int offset${f.name};`)),e.enableShapeUniforms){let{uniformShape:h}=cw(e.packedInputs,f.shapeInfo.logicalShape,f.shapeInfo.texShape);switch(h.length){case 1:n.push(`uniform int ${f.name}Shape;`);break;case 2:n.push(`uniform ivec2 ${f.name}Shape;`);break;case 3:n.push(`uniform ivec3 ${f.name}Shape;`);break;case 4:n.push(`uniform ivec4 ${f.name}Shape;`);break;default:break}n.push(`uniform ivec2 ${f.name}TexShape;`)}}),e.enableShapeUniforms){switch(t.logicalShape.length){case 1:n.push("uniform int outShape;");break;case 2:n.push("uniform ivec2 outShape;"),n.push("uniform int outShapeStrides;");break;case 3:n.push("uniform ivec3 outShape;"),n.push("uniform ivec2 outShapeStrides;");break;case 4:n.push("uniform ivec4 outShape;"),n.push("uniform ivec3 outShapeStrides;");break;default:break}n.push("uniform ivec2 outTexShape;")}e.customUniforms&&e.customUniforms.forEach(f=>{n.push(`uniform ${f.type} ${f.name}${f.arrayIndex?`[${f.arrayIndex}]`:""};`)});let o=n.join(`
`),s=r.map(f=>$Q(f,t,e.packedInputs,e.enableShapeUniforms)).join(`
`),i=t.texShape,a=qe(),u=FQ(a),l,c,p=PQ(a);return t.isPacked?(l=DQ(t.logicalShape,i,e.enableShapeUniforms),c=MQ(a)):(l=RQ(t.logicalShape,i,e.enableShapeUniforms),c=OQ(a)),e.packedInputs&&(p+=VQ),[p,u,c,o,l,s,e.userCode].join(`
`)}function dd(r,t=!1){let e=r.shapeInfo.logicalShape;switch(e.length){case 0:return QQ(r,t);case 1:return ett(r,t);case 2:return ntt(r,t);case 3:return stt(r,t);case 4:return att(r,t);case 5:return ltt(r);case 6:return utt(r);default:throw new Error(`${e.length}-D input sampling is not yet supported`)}}function BM(r,t){switch(r.shapeInfo.logicalShape.length){case 0:return JQ(r);case 1:return ttt(r,t);case 2:return rtt(r,t);case 3:return ott(r,t);default:return itt(r,t)}}function $Q(r,t,e=!1,n){let o="";e?o+=BM(r,n):o+=dd(r,n);let s=r.shapeInfo.logicalShape,i=t.logicalShape;return s.length<=i.length&&(e?o+=ctt(r,t):o+=ptt(r,t)),o}function DQ(r,t,e){switch(r.length){case 0:return VM();case 1:return GQ(r,t,e);case 2:return YQ(r,t,e);case 3:return UQ(r,t,e);default:return qQ(r,t,e)}}function RQ(r,t,e){switch(r.length){case 0:return VM();case 1:return WQ(r,t,e);case 2:return ZQ(r,t,e);case 3:return HQ(r,t,e);case 4:return KQ(r,t,e);case 5:return jQ(r,t);case 6:return XQ(r,t);default:throw new Error(`${r.length}-D output sampling is not yet supported`)}}function FQ(r){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${r.texture2D}(textureSampler, uv).r;
    }
  `}function OQ(r){return`
    void setOutput(float val) {
      ${r.output} = vec4(val, 0, 0, 0);
    }
  `}function MQ(r){return`
    void setOutput(vec4 val) {
      ${r.output} = val;
    }
  `}function PQ(r){return`${r.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${r.varyingFs} vec2 resultUV;
    ${r.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${r.defineSpecialNaN}
    ${r.defineSpecialInf}
    ${r.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${LQ}
    ${zQ}
    ${BQ}
  `}var LQ=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,zQ=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,BQ=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,VQ=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function VM(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function GQ(r,t,e){let n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return n[0]===1?e?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${n[1]}.0);
      }
    `:n[1]===1?e?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${n[0]}.0);
      }
    `:e?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${n[0]}, ${n[1]}));
      return 2 * (resTexRC.x * ${n[1]} + resTexRC.y);
    }
  `}function WQ(r,t,e){return t[0]===1?e?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${t[1]}.0);
      }
    `:t[1]===1?e?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${t[0]}.0);
      }
    `:e?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      return resTexRC.x * ${t[1]} + resTexRC.y;
    }
  `}function UQ(r,t,e){if(e)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;let n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],o=Math.ceil(r[2]/2),s=o*Math.ceil(r[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${n[0]}, ${n[1]}));
      int index = resTexRC.x * ${n[1]} + resTexRC.y;

      int b = index / ${s};
      index -= b * ${s};

      int r = 2 * (index / ${o});
      int c = imod(index, ${o}) * 2;

      return ivec3(b, r, c);
    }
  `}function HQ(r,t,e){if(e)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${Yc(["r","c","d"],r)}
    return ivec3(r, c, d);
  }
`;let n=di(["r","c","d"],r);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${n}
      return ivec3(r, c, d);
    }
  `}function qQ(r,t,e){if(e)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;let n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],o=Math.ceil(r[r.length-1]/2),s=o*Math.ceil(r[r.length-2]/2),i=s,a="",u="b, r, c";for(let l=2;l<r.length-1;l++)i*=r[r.length-l-1],a=`
      int b${l} = index / ${i};
      index -= b${l} * ${i};
    `+a,u=`b${l}, `+u;return`
    ivec${r.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${n[0]}, ${n[1]}));
      int index = resTexRC.x * ${n[1]} + resTexRC.y;

      ${a}

      int b = index / ${s};
      index -= b * ${s};

      int r = 2 * (index / ${o});
      int c = imod(index, ${o}) * 2;

      return ivec${r.length}(${u});
    }
  `}function KQ(r,t,e){if(e)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${Yc(["r","c","d","d2"],r)}
      return ivec4(r, c, d, d2);
    }
  `;let n=di(["r","c","d","d2"],r);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${n}
      return ivec4(r, c, d, d2);
    }
  `}function jQ(r,t){let e=di(["r","c","d","d2","d3"],r);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},
                             ${t[1]}));

      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${e}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function XQ(r,t){let e=di(["r","c","d","d2","d3","d4"],r);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${e}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function YQ(r,t,e){let n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(x.arraysEqual(r,t))return e?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${n[0]}, ${n[1]}));
      }
    `;let o=Math.ceil(r[1]/2);return e?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${n[0]}, ${n[1]}));

      int index = resTexRC.x * ${n[1]} + resTexRC.y;
      int r = 2 * (index / ${o});
      int c = imod(index, ${o}) * 2;

      return ivec2(r, c);
    }
  `}function ZQ(r,t,e){return x.arraysEqual(r,t)?e?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));
      }
    `:r[1]===1?e?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:r[0]===1?e?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:e?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      int r = index / ${r[1]};
      int c = index - r * ${r[1]};
      return ivec2(r, c);
    }
  `}function Zc(r){return`offset${r}`}function JQ(r){let t=r.name,e="get"+t.charAt(0).toUpperCase()+t.slice(1),n=qe();return`
    vec4 ${e}() {
      return ${n.texture2D}(${t}, halfCR);
    }
  `}function QQ(r,t){let e=r.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1);if(r.shapeInfo.isUniform)return`float ${n}() {return ${e};}`;let[o,s]=r.shapeInfo.texShape;if(o===1&&s===1)return`
      float ${n}() {
        return sampleTexture(${e}, halfCR);
      }
    `;let i=Zc(e);if(t)return`
    float ${n}() {
      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], ${i});
      return sampleTexture(${e}, uv);
    }
  `;let[a,u]=r.shapeInfo.texShape;return`
    float ${n}() {
      vec2 uv = uvFromFlat(${a}, ${u}, ${i});
      return sampleTexture(${e}, uv);
    }
  `}function ttt(r,t){let e=r.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1),o=r.shapeInfo.texShape,s=qe();if(t)return`
    vec4 ${n}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${s.texture2D}(${e}, uv);
    }
  `;let i=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];return`
    vec4 ${n}(int index) {
      vec2 uv = packedUVfrom1D(
        ${i[0]}, ${i[1]}, index);
      return ${s.texture2D}(${e}, uv);
    }
  `}function ett(r,t){let e=r.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1);if(r.shapeInfo.isUniform)return`
      float ${n}(int index) {
        ${hd(r)}
      }
    `;let o=r.shapeInfo.texShape,s=o[0],i=o[1];if(i===1&&s===1)return`
      float ${n}(int index) {
        return sampleTexture(${e}, halfCR);
      }
    `;let a=Zc(e);return i===1?t?`
      float ${n}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / float(${e}TexShape[0]));
        return sampleTexture(${e}, uv);
      }
    `:`
      float ${n}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / ${s}.0);
        return sampleTexture(${e}, uv);
      }
    `:s===1?t?`
      float ${n}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / float(${e}TexShape[1]), 0.5);
        return sampleTexture(${e}, uv);
      }
    `:`
      float ${n}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / ${i}.0, 0.5);
        return sampleTexture(${e}, uv);
      }
    `:t?`
    float ${n}(int index) {
      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], index + ${a});
      return sampleTexture(${e}, uv);
    }
  `:`
    float ${n}(int index) {
      vec2 uv = uvFromFlat(${s}, ${i}, index + ${a});
      return sampleTexture(${e}, uv);
    }
  `}function rtt(r,t){let e=r.shapeInfo.logicalShape,n=r.name,o="get"+n.charAt(0).toUpperCase()+n.slice(1),s=r.shapeInfo.texShape,i=s[0],a=s[1],u=qe();if(s!=null&&x.arraysEqual(e,s))return t?`
      vec4 ${o}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${n}TexShape[1], ${n}TexShape[0]);

        return ${u.texture2D}(${n}, uv);
      }
    `:`
      vec4 ${o}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}.0, ${i}.0);

        return ${u.texture2D}(${n}, uv);
      }
    `;if(t)return`
    vec4 ${o}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${n}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${u.texture2D}(${n}, uv);
    }
  `;let l=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)],c=Math.ceil(e[1]/2);return`
    vec4 ${o}(int row, int col) {
      vec2 uv = packedUVfrom2D(${c}, ${l[0]}, ${l[1]}, row, col);
      return ${u.texture2D}(${n}, uv);
    }
  `}function ntt(r,t){let e=r.shapeInfo.logicalShape,n=r.name,o="get"+n.charAt(0).toUpperCase()+n.slice(1),s=r.shapeInfo.texShape;if(s!=null&&x.arraysEqual(e,s)){if(t)return`
      float ${o}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${n}TexShape[1], ${n}TexShape[0]);
        return sampleTexture(${n}, uv);
      }
    `;let m=s[0],f=s[1];return`
    float ${o}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${f}.0, ${m}.0);
      return sampleTexture(${n}, uv);
    }
  `}let{newShape:i,keptDims:a}=x.squeezeShape(e),u=i;if(u.length<e.length){let m=gd(r,u),f=["row","col"];return`
      ${dd(m,t)}
      float ${o}(int row, int col) {
        return ${o}(${xd(f,a)});
      }
    `}if(r.shapeInfo.isUniform)return`
      float ${o}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${e[1]}, 1)));
        ${hd(r)}
      }
    `;let l=s[0],c=s[1],p=Zc(n);return c===1?t?`
      float ${o}(int row, int col) {
        float index = dot(vec3(row, col, ${p}), vec3(${n}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${n}TexShape[0]));
        return sampleTexture(${n}, uv);
      }
    `:`
    float ${o}(int row, int col) {
      float index = dot(vec3(row, col, ${p}), vec3(${e[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${l}.0);
      return sampleTexture(${n}, uv);
    }
  `:l===1?t?`
      float ${o}(int row, int col) {
        float index = dot(vec3(row, col, ${p}), vec3(${n}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${n}TexShape[1]), 0.5);
        return sampleTexture(${n}, uv);
      }
    `:`
    float ${o}(int row, int col) {
      float index = dot(vec3(row, col, ${p}), vec3(${e[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${c}.0, 0.5);
      return sampleTexture(${n}, uv);
    }
  `:t?`
      float ${o}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${n}Shape[1] + col + ${p};
        vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index);
        return sampleTexture(${n}, uv);
      }
    `:`
  float ${o}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${e[1]} + col + ${p};
    vec2 uv = uvFromFlat(${l}, ${c}, index);
    return sampleTexture(${n}, uv);
  }
`}function ott(r,t){let e=r.shapeInfo.logicalShape,n=r.name,o="get"+n.charAt(0).toUpperCase()+n.slice(1),s=r.shapeInfo.texShape,i=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];if(e[0]===1){let m=e.slice(1),f=[1,2],d=gd(r,m),h=["b","row","col"];return`
        ${BM(d,t)}
        vec4 ${o}(int b, int row, int col) {
          return ${o}(${xd(h,f)});
        }
      `}let a=qe();if(t)return`
    vec4 ${o}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${n}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${a.texture2D}(${n}, uv);
    }
  `;let u=i[0],l=i[1],c=Math.ceil(e[2]/2),p=c*Math.ceil(e[1]/2);return`
    vec4 ${o}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${u}, ${l}, ${p}, ${c}, b, row, col);
      return ${a.texture2D}(${n}, uv);
    }
  `}function stt(r,t){let e=r.shapeInfo.logicalShape,n=r.name,o="get"+n.charAt(0).toUpperCase()+n.slice(1),s=e[1]*e[2],i=e[2],{newShape:a,keptDims:u}=x.squeezeShape(e),l=a;if(l.length<e.length){let h=gd(r,l),g=["row","col","depth"];return`
        ${dd(h,t)}
        float ${o}(int row, int col, int depth) {
          return ${o}(${xd(g,u)});
        }
      `}if(r.shapeInfo.isUniform)return`
      float ${o}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${s}, ${i}, 1)));
        ${hd(r)}
      }
    `;let c=r.shapeInfo.texShape,p=c[0],m=c[1],f=r.shapeInfo.flatOffset;if(m===s&&f==null)return t?`
      float ${o}(int row, int col, int depth) {
        int stride1 = ${n}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${n}TexShape[1], ${n}TexShape[0]);
        return sampleTexture(${n}, uv);
      }
    `:`
        float ${o}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${i}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${m}.0, ${p}.0);
          return sampleTexture(${n}, uv);
        }
      `;if(m===i&&f==null)return t?`
      float ${o}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${n}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${n}TexShape[1], ${n}TexShape[0]);
        return sampleTexture(${n}, uv);
      }
    `:`
    float ${o}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${e[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${m}.0, ${p}.0);
      return sampleTexture(${n}, uv);
    }
  `;let d=Zc(n);return t?`
    float ${o}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${n}Shape[1] * ${n}Shape[2];
      int stride1 = ${n}Shape[2];
      int index = row * ${s} + col * ${i} + depth + ${d};
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index);
      return sampleTexture(${n}, uv);
    }
    `:`
      float ${o}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${s} + col * ${i} + depth + ${d};
        vec2 uv = uvFromFlat(${p}, ${m}, index);
        return sampleTexture(${n}, uv);
      }
  `}function itt(r,t){let e=r.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1),o=qe();if(t)return`
    vec4 ${n}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${e}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${e}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${e}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${o.texture2D}(${e}, uv);
    }
  `;let s=r.shapeInfo.logicalShape,i=s.length,a=r.shapeInfo.texShape,u=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],l=u[0],c=u[1],p=Math.ceil(s[i-1]/2),m=p*Math.ceil(s[i-2]/2),f="int b, int row, int col",d=`b * ${m} + (row / 2) * ${p} + (col / 2)`;for(let h=2;h<i-1;h++)f=`int b${h}, `+f,m*=s[i-h-1],d=`b${h} * ${m} + `+d;return`
    vec4 ${n}(${f}) {
      int index = ${d};
      int texR = index / ${c};
      int texC = index - texR * ${c};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}, ${l});
      return ${o.texture2D}(${e}, uv);
    }
  `}function att(r,t){let e=r.shapeInfo.logicalShape,n=r.name,o="get"+n.charAt(0).toUpperCase()+n.slice(1),s=e[3],i=e[2]*s,a=e[1]*i,{newShape:u,keptDims:l}=x.squeezeShape(e);if(u.length<e.length){let b=gd(r,u),w=["row","col","depth","depth2"];return`
      ${dd(b,t)}
      float ${o}(int row, int col, int depth, int depth2) {
        return ${o}(${xd(w,l)});
      }
    `}if(r.shapeInfo.isUniform)return`
      float ${o}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${a}, ${i}, ${s}, 1)));
        ${hd(r)}
      }
    `;let c=r.shapeInfo.flatOffset,p=r.shapeInfo.texShape,m=p[0],f=p[1],d=`int stride2 = ${n}Shape[3];`,h=`int stride1 = ${n}Shape[2] * stride2;`,g=`int stride0 = ${n}Shape[1] * stride1;`;if(f===a&&c==null)return t?`
      float ${o}(int row, int col, int depth, int depth2) {
        ${d}
        ${h}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${n}TexShape[1], ${n}TexShape[0]);
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${o}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${i}, ${s}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${m}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(f===s&&c==null)return t?`
      float ${o}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${n}Shape[1] * ${n}Shape[2], ${n}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${n}TexShape[1], ${n}TexShape[0]);
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${o}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${e[1]*e[2]}, ${e[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${m}.0);
        return sampleTexture(${n}, uv);
      }
    `;let y=Zc(n);return t?`
    float ${o}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${d}
      ${h}
      ${g}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${y});
      return sampleTexture(${n}, uv);
    }
  `:`
    float ${o}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${i} +
          depth * ${s} + depth2;
      vec2 uv = uvFromFlat(${m}, ${f}, index + ${y});
      return sampleTexture(${n}, uv);
    }
  `}function ltt(r){let t=r.shapeInfo.logicalShape,e=r.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1),o=t[4],s=t[3]*o,i=t[2]*s,a=t[1]*i,{newShape:u,keptDims:l}=x.squeezeShape(t);if(u.length<t.length){let h=gd(r,u),g=["row","col","depth","depth2","depth3"];return`
      ${dd(h)}
      float ${n}(int row, int col, int depth, int depth2, int depth3) {
        return ${n}(${xd(g,l)});
      }
    `}if(r.shapeInfo.isUniform)return`
      float ${n}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${a}, ${i}, ${s}, ${o})) +
          depth3;
        ${hd(r)}
      }
    `;let c=r.shapeInfo.flatOffset,p=r.shapeInfo.texShape,m=p[0],f=p[1];if(f===a&&c==null)return`
      float ${n}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${i}, ${s}, ${o}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${m}.0);
        return sampleTexture(${e}, uv);
      }
    `;if(f===o&&c==null)return`
      float ${n}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]},
               ${t[2]*t[3]}, ${t[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${m}.0);
        return sampleTexture(${e}, uv);
      }
    `;let d=Zc(e);return`
    float ${n}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${i} + depth * ${s} +
          depth2 * ${o} + depth3 + ${d};
      vec2 uv = uvFromFlat(${m}, ${f}, index);
      return sampleTexture(${e}, uv);
    }
  `}function utt(r){let t=r.shapeInfo.logicalShape,e=r.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1),{newShape:o,keptDims:s}=x.squeezeShape(t);if(o.length<t.length){let g=gd(r,o),y=["row","col","depth","depth2","depth3","depth4"];return`
      ${dd(g)}
      float ${n}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${n}(${xd(y,s)});
      }
    `}let i=t[5],a=t[4]*i,u=t[3]*a,l=t[2]*u,c=t[1]*l;if(r.shapeInfo.isUniform)return`
      float ${n}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${c}, ${l}, ${u}, ${a})) +
          dot(
            vec2(depth3, depth4),
            vec2(${i}, 1)));
        ${hd(r)}
      }
    `;let p=r.shapeInfo.flatOffset,m=r.shapeInfo.texShape,f=m[0],d=m[1];if(d===c&&p==null)return`
      float ${n}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${l}, ${u}, ${a}, ${i})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${d}.0, ${f}.0);
        return sampleTexture(${e}, uv);
      }
    `;if(d===i&&p==null)return`
      float ${n}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]*t[4]},
               ${t[2]*t[3]*t[4]},
               ${t[3]*t[4]},
               ${t[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${d}.0, ${f}.0);
        return sampleTexture(${e}, uv);
      }
    `;let h=Zc(e);return`
    float ${n}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${c} + col * ${l} + depth * ${u} +
          depth2 * ${a} + depth3 * ${i} + depth4 + ${h};
      vec2 uv = uvFromFlat(${f}, ${d}, index);
      return sampleTexture(${e}, uv);
    }
  `}function hd(r){let t=r.name,e=x.sizeFromShape(r.shapeInfo.logicalShape);return e<2?`return ${t};`:`
    for (int i = 0; i < ${e}; i++) {
      if (i == index) {
        return ${t}[i];
      }
    }
  `}function ctt(r,t){let e=r.name,n=e.charAt(0).toUpperCase()+e.slice(1),o="get"+n+"AtOutCoords",s=r.shapeInfo.logicalShape.length,i=t.logicalShape.length,a=LM(r.shapeInfo.logicalShape,t.logicalShape),u=Vt(i),l=i-s,c,p=["x","y","z","w","u","v"];s===0?c="":i<2&&a.length>=1?c="coords = 0;":c=a.map(b=>`coords.${p[b+l]} = 0;`).join(`
`);let m="";i<2&&s>0?m="coords":m=r.shapeInfo.logicalShape.map((b,w)=>`coords.${p[w+l]}`).join(", ");let f="return outputValue;",h=x.sizeFromShape(r.shapeInfo.logicalShape)===1,y=x.sizeFromShape(t.logicalShape)===1;if(s===1&&!h&&!y)f=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(h&&!y)i===1?f=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:f=`
        return vec4(outputValue.x);
      `;else if(a.length){let b=s-2,w=s-1;a.indexOf(b)>-1&&a.indexOf(w)>-1?f="return vec4(outputValue.x);":a.indexOf(b)>-1?f="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":a.indexOf(w)>-1&&(f="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${o}() {
      ${u} coords = getOutputCoords();
      ${c}
      vec4 outputValue = get${n}(${m});
      ${f}
    }
  `}function ptt(r,t){let e=r.name,n=e.charAt(0).toUpperCase()+e.slice(1),o="get"+n+"AtOutCoords",s=t.texShape,i=r.shapeInfo.texShape,a=r.shapeInfo.logicalShape.length,u=t.logicalShape.length;if(!r.shapeInfo.isUniform&&a===u&&r.shapeInfo.flatOffset==null&&x.arraysEqual(i,s))return`
      float ${o}() {
        return sampleTexture(${e}, resultUV);
      }
    `;let l=Vt(u),c=LM(r.shapeInfo.logicalShape,t.logicalShape),p=u-a,m,f=["x","y","z","w","u","v"];a===0?m="":u<2&&c.length>=1?m="coords = 0;":m=c.map(h=>`coords.${f[h+p]} = 0;`).join(`
`);let d="";return u<2&&a>0?d="coords":d=r.shapeInfo.logicalShape.map((h,g)=>`coords.${f[g+p]}`).join(", "),`
    float ${o}() {
      ${l} coords = getOutputCoords();
      ${m}
      return get${n}(${d});
    }
  `}function Vt(r){if(r<=1)return"int";if(r===2)return"ivec2";if(r===3)return"ivec3";if(r===4)return"ivec4";if(r===5)return"ivec5";if(r===6)return"ivec6";throw Error(`GPU for rank ${r} is not yet supported`)}function cw(r,t,e){let{newShape:n,keptDims:o}=x.squeezeShape(t),s=t.length,i=r&&s===3&&t[0]===1,a=i?t.slice(1):n,u=!r&&s>1&&!x.arraysEqual(t,e)&&n.length<s||i;return{useSqueezeShape:u,uniformShape:u?a:t,keptDims:o}}function gd(r,t){let e=JSON.parse(JSON.stringify(r));return e.shapeInfo.logicalShape=t,e}function xd(r,t){return t.map(e=>r[e]).join(", ")}function WM(r,t,e,n){let o=e.map((c,p)=>{let m={logicalShape:c.shape,texShape:c.isUniform?null:c.texData.texShape,isUniform:c.isUniform,isPacked:c.isUniform?!1:c.texData.isPacked,flatOffset:null};return c.texData!=null&&c.texData.slice!=null&&c.texData.slice.flatOffset>0&&(m.flatOffset=c.texData.slice.flatOffset),{name:t.variableNames[p],shapeInfo:m}}),s=o.map(c=>c.shapeInfo),i={logicalShape:n.shape,texShape:n.texData.texShape,isUniform:!1,isPacked:n.texData.isPacked,flatOffset:null},a=zM(o,i,t),u=$N(r.gl,a),l=r.createProgram(u);return V().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:u,source:a,webGLProgram:l,inShapeInfos:s,outShapeInfo:i,uniformLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,inShapesLocations:null,inTexShapesLocations:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:Object.assign({program:t,fragmentShader:u,source:a,webGLProgram:l,inShapeInfos:s,outShapeInfo:i},XN(r,t,l))}function XN(r,t,e){let n={},o={},s={},i=[],a,u,l,c=null,p=null;p=r.getUniformLocation(e,"NAN",!1),V().getNumber("WEBGL_VERSION")===1&&(c=r.getUniformLocation(e,"INFINITY",!1));let m=!1;for(let f=0;f<t.variableNames.length;f++){let d=t.variableNames[f];n[d]=r.getUniformLocation(e,d,m),n[`offset${d}`]=r.getUniformLocation(e,`offset${d}`,m),t.enableShapeUniforms&&(o[`${d}Shape`]=r.getUniformLocation(e,`${d}Shape`,m),s[`${d}TexShape`]=r.getUniformLocation(e,`${d}TexShape`,m))}return t.enableShapeUniforms&&(a=r.getUniformLocation(e,"outShape",m),l=r.getUniformLocation(e,"outShapeStrides",m),u=r.getUniformLocation(e,"outTexShape",m)),t.customUniforms&&t.customUniforms.forEach((f,d)=>{i[d]=r.getUniformLocation(e,f.name,m)}),{uniformLocations:n,customUniformLocations:i,infLoc:c,nanLoc:p,inShapesLocations:o,inTexShapesLocations:s,outShapeLocation:a,outShapeStridesLocation:l,outTexShapeLocation:u}}function GM(r,t){if(r.length!==t.length)throw Error(`Binary was compiled with ${r.length} inputs, but was executed with ${t.length} inputs`);r.forEach((e,n)=>{let o=e.logicalShape,s=t[n],i=s.shape;if(!x.arraysEqual(o,i))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${o} and ${i} must match`);if(e.isUniform&&s.isUniform)return;let a=e.texShape,u=s.isUniform?null:s.texData.texShape;if(!x.arraysEqual(a,u))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${a} and ${u} must match`)})}function UM(r,t,e,n,o){t.program.enableShapeUniforms||(GM(t.inShapeInfos,e),GM([t.outShapeInfo],[n]));let s=n.texData.texture,i=n.texData.texShape;n.texData.isPacked?r.setOutputPackedMatrixTexture(s.texture,i[0],i[1]):r.setOutputMatrixTexture(s.texture,i[0],i[1]),r.setProgram(t.webGLProgram),V().getNumber("WEBGL_VERSION")===1&&t.infLoc!==null&&r.gl.uniform1f(t.infLoc,1/0),t.nanLoc!==null&&r.gl.uniform1f(t.nanLoc,NaN),e.forEach((u,l)=>{let c=t.program.variableNames[l],p=t.uniformLocations[c],m=t.uniformLocations[`offset${c}`],f=t.inShapesLocations[`${c}Shape`],d=t.inTexShapesLocations[`${c}TexShape`];if(f){let{uniformShape:h}=cw(t.program.packedInputs,u.shape,u.texData.texShape);switch(h.length){case 1:r.gl.uniform1iv(f,new Int32Array(h));break;case 2:r.gl.uniform2iv(f,new Int32Array(h));break;case 3:r.gl.uniform3iv(f,new Int32Array(h));break;case 4:r.gl.uniform4iv(f,new Int32Array(h));break;default:break}}if(d&&r.gl.uniform2i(d,u.texData.texShape[0],u.texData.texShape[1]),p!=null){if(u.isUniform){if(x.sizeFromShape(u.shape)<2)r.gl.uniform1f(p,u.uniformValues[0]);else{let h=u.uniformValues;h instanceof Float32Array||(h=new Float32Array(h)),r.gl.uniform1fv(p,h)}return}u.texData.slice!=null&&m!=null&&r.gl.uniform1i(m,u.texData.slice.flatOffset),r.setInputMatrixTexture(u.texData.texture.texture,p,l)}});let a=t.outShapeLocation;if(a)switch(n.shape.length){case 1:r.gl.uniform1iv(a,new Int32Array(n.shape));break;case 2:r.gl.uniform2iv(a,new Int32Array(n.shape));break;case 3:r.gl.uniform3iv(a,new Int32Array(n.shape));break;case 4:r.gl.uniform4iv(a,new Int32Array(n.shape));break;default:break}if(t.outShapeStridesLocation){let u=x.computeStrides(n.shape);switch(n.shape.length){case 2:r.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(u));break;case 3:r.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(u));break;case 4:r.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(u));break;default:break}}t.outTexShapeLocation&&r.gl.uniform2i(t.outTexShapeLocation,n.texData.texShape[0],n.texData.texShape[1]),t.program.customUniforms&&o&&t.program.customUniforms.forEach((u,l)=>{let c=t.customUniformLocations[l],p=o[l];if(u.type==="float")r.gl.uniform1fv(c,p);else if(u.type==="vec2")r.gl.uniform2fv(c,p);else if(u.type==="vec3")r.gl.uniform3fv(c,p);else if(u.type==="vec4")r.gl.uniform4fv(c,p);else if(u.type==="int")r.gl.uniform1iv(c,p);else if(u.type==="ivec2")r.gl.uniform2iv(c,p);else if(u.type==="ivec3")r.gl.uniform3iv(c,p);else if(u.type==="ivec4")r.gl.uniform4iv(c,p);else throw Error(`uniform type ${u.type} is not supported yet.`)}),r.executeProgram()}function HM(r,t,e){let n="";t.concat(e).forEach(i=>{let a=i.texData!=null&&i.texData.slice!=null&&i.texData.slice.flatOffset>0;if(r.enableShapeUniforms&&!i.isUniform){let u=i.texData.texShape,{useSqueezeShape:l,uniformShape:c,keptDims:p}=cw(r.packedInputs,i.shape,u),m="",f="",d="";if(c.length===1&&r.packedInputs){let k=[Math.ceil(u[0]/2),Math.ceil(u[1]/2)];m=`${k[0]>1}_${k[1]>1}`}else if(c.length===2&&!r.packedInputs)f=`${c[0]>1}_${c[1]>1}`;else if(c.length>2&&!r.packedInputs){let k=x.computeStrides(c);d=`${k[0]===u[1]}_${k[k.length-1]===u[1]}`}let h=i.shape.length,g=c.length===2&&x.arraysEqual(i.shape,u),y=x.sizeFromShape(i.shape)===1,b=S.getBroadcastDims(i.shape,e.shape),w=!r.packedInputs&&h===e.shape.length&&x.arraysEqual(u,e.texData.texShape),v=r.packedInputs||c.length>2?"":`${u[0]>1}_${u[1]>1}`;n+=`${h}_${w}_${l?p:""}_${c.length}_${y}_${b}_${g}_${m}_${f}_${d}_${v}_${a}`}else{let u=i.isUniform?"uniform":i.texData.texShape;n+=`${i.shape}_${u}_${a}`}});let o=r.userCode,s=r.constructor.name;return s+="_"+n+"_"+o+`${V().getNumber("WEBGL_VERSION")}`,s}function De(r){return V().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&r<=4}var pw=class{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=xu.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let e=qe();this.outputShape=t,this.enableShapeUniforms=De(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Yc(["r","c","d"],t):di(["r","c","d"],t)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${e.output} = result;
      }
    `}};var mw=class{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=xu.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let e=qe();this.outputShape=t,this.enableShapeUniforms=De(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Yc(["r","c","d"],t):di(["r","c","d"],t)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${e.output} = result;
      }
    `}};var fw=class{constructor(t){this.variableNames=["A"],this.outTexUsage=Kr.DOWNLOAD;let e=qe();this.outputShape=t,this.userCode=`
      ${uw}

      void main() {
        float x = getAAtOutCoords();
        ${e.output} = encode_float(x);
      }
    `}};var dw=class{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=Kr.DOWNLOAD;let e=qe();this.outputShape=t,this.userCode=`
      ${uw}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${e.output} = encode_float(x);
      }
    `}};var hw=class{constructor(t,e=!1){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];let n=qe();this.outputShape=t,this.enableShapeUniforms=De(this.outputShape.length);let o="result";e&&(o="floor(result * 255. + 0.5)"),this.userCode=`
      ${this.enableShapeUniforms?md():pd(t)}

      void main() {
        ivec3 coords = getOutputCoords();

        int flatIndex = getFlatIndex(coords);
        int offset = imod(flatIndex, 4);

        flatIndex = idiv(flatIndex, 4, 1.);

        int r = flatIndex / texShape[1];
        int c = imod(flatIndex, texShape[1]);
        vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
        vec4 values = ${n.texture2D}(A, uv);

        float result;

        if(offset == 0) {
          result = values[0];
        } else if(offset == 1) {
          result = values[1];
        } else if(offset == 2) {
          result = values[2];
        } else {
          result = values[3];
        }

        ${n.output} = vec4(${o}, 0., 0., 0.);
      }
    `}};var gw=class{constructor(t,e=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];let n=qe();this.outputShape=t,this.enableShapeUniforms=De(this.outputShape.length);let o="",s="result";e&&(s="floor(result * 255. + 0.5)");for(let i=0;i<=1;i++)for(let a=0;a<=1;a++){let u=i*2+a;o+=`
          localCoords = coords;
          if(localCoords[2] + ${a} < ${this.enableShapeUniforms?"outShape[2]":`${t[2]}`}) {
          localCoords[2] += ${a};
          if (localCoords[1] + ${i} < ${this.enableShapeUniforms?"outShape[1]":`${t[1]}`}) {
            localCoords[1] += ${i};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${n.texture2D}(A, uv);

            if (offset == 0) {
              result[${u}] = values[0];
            } else if (offset == 1) {
              result[${u}] = values[1];
            } else if (offset == 2) {
              result[${u}] = values[2];
            } else {
              result[${u}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?md():pd(t)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${o}

          ${n.output} = ${s};
        }
    `}};var mT={};Yt(mT,{bindVertexProgramAttributeStreams:()=>oT,createBufferFromOutputTexture:()=>aT,createFloat16MatrixTexture:()=>tT,createFloat16PackedMatrixTexture:()=>nT,createFloat32MatrixTexture:()=>QN,createIndexBuffer:()=>JN,createPackedMatrixTexture:()=>rT,createUnsignedBytesMatrixTexture:()=>eT,createVertexBuffer:()=>ZN,createVertexShader:()=>YN,downloadByteEncodedFloatMatrixFromOutputTexture:()=>uT,downloadFloat32MatrixFromBuffer:()=>lT,downloadMatrixFromPackedOutputTexture:()=>pT,downloadPackedMatrixFromBuffer:()=>cT,getInternalFormatForFloat16MatrixTexture:()=>yw,getInternalFormatForFloat16PackedMatrixTexture:()=>vw,getInternalFormatForFloat32MatrixTexture:()=>xw,getInternalFormatForPackedMatrixTexture:()=>ww,getInternalFormatForUnsignedBytesMatrixTexture:()=>bw,uploadDenseMatrixToTexture:()=>sT,uploadPixelDataToTexture:()=>iT});function YN(r){let t=qe(),e=`${t.version}
    precision highp float;
    ${t.attribute} vec3 clipSpacePos;
    ${t.attribute} vec2 uv;
    ${t.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return AN(r,e)}function ZN(r){let t=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return FN(r,t)}function JN(r){let t=new Uint16Array([0,1,2,2,1,3]);return ON(r,t)}function Cg(r,t,e,n,o,s){PN(t,e);let i=MN(r),a=r.TEXTURE_2D;return vt(r,()=>r.bindTexture(a,i)),vt(r,()=>r.texParameteri(a,r.TEXTURE_WRAP_S,r.CLAMP_TO_EDGE)),vt(r,()=>r.texParameteri(a,r.TEXTURE_WRAP_T,r.CLAMP_TO_EDGE)),vt(r,()=>r.texParameteri(a,r.TEXTURE_MIN_FILTER,r.NEAREST)),vt(r,()=>r.texParameteri(a,r.TEXTURE_MAG_FILTER,r.NEAREST)),V().getNumber("WEBGL_VERSION")===1?vt(r,()=>r.texImage2D(a,0,n,t,e,0,o,s,null)):vt(r,()=>r.texStorage2D(a,1,n,t,e)),vt(r,()=>r.bindTexture(r.TEXTURE_2D,null)),{texture:i,texShape:[e,t]}}function xw(r){return r.internalFormatFloat}function QN(r,t,e,n){let[o,s]=Xc(t,e);return Cg(r,o,s,xw(n),n.textureFormatFloat,r.FLOAT)}function yw(r){return r.internalFormatHalfFloat}function tT(r,t,e,n){let[o,s]=Xc(t,e);return Cg(r,o,s,yw(n),n.textureFormatFloat,n.textureTypeHalfFloat)}function bw(r){return r.downloadTextureFormat}function eT(r,t,e,n){let[o,s]=Xc(t,e);return Cg(r,o,s,bw(n),r.RGBA,r.UNSIGNED_BYTE)}function ww(r){return r.internalFormatPackedFloat}function rT(r,t,e,n){let[o,s]=Zi(t,e);return Cg(r,o,s,ww(n),r.RGBA,r.FLOAT)}function vw(r){return r.internalFormatPackedHalfFloat}function nT(r,t,e,n){let[o,s]=Zi(t,e);return Cg(r,o,s,vw(n),r.RGBA,n.textureTypeHalfFloat)}function oT(r,t,e){return vt(r,()=>r.bindBuffer(r.ARRAY_BUFFER,e)),iw(r,t,"clipSpacePos",e,3,20,0)&&iw(r,t,"uv",e,2,20,12)}function sT(r,t,e,n,o,s){vt(r,()=>r.bindTexture(r.TEXTURE_2D,t));let i,a,u;o instanceof Uint8Array?(i=new Uint8Array(e*n*4),a=r.UNSIGNED_BYTE,u=r.RGBA):(i=new Float32Array(e*n*4),a=r.FLOAT,u=s.internalFormatPackedFloat),i.set(o),V().getNumber("WEBGL_VERSION")===2?vt(r,()=>r.texSubImage2D(r.TEXTURE_2D,0,0,0,e,n,r.RGBA,a,i)):vt(r,()=>r.texImage2D(r.TEXTURE_2D,0,u,e,n,0,r.RGBA,a,i)),vt(r,()=>r.bindTexture(r.TEXTURE_2D,null))}function iT(r,t,e){vt(r,()=>r.bindTexture(r.TEXTURE_2D,t)),e.data instanceof Uint8Array?V().getNumber("WEBGL_VERSION")===2?vt(r,()=>r.texSubImage2D(r.TEXTURE_2D,0,0,0,e.width,e.height,r.RGBA,r.UNSIGNED_BYTE,e.data)):vt(r,()=>r.texImage2D(r.TEXTURE_2D,0,r.RGBA,e.width,e.height,0,r.RGBA,r.UNSIGNED_BYTE,e.data)):V().getNumber("WEBGL_VERSION")===2?vt(r,()=>r.texSubImage2D(r.TEXTURE_2D,0,0,0,r.RGBA,r.UNSIGNED_BYTE,e)):vt(r,()=>r.texImage2D(r.TEXTURE_2D,0,r.RGBA,r.RGBA,r.UNSIGNED_BYTE,e)),vt(r,()=>r.bindTexture(r.TEXTURE_2D,null))}function aT(r,t,e,n){let o=r.createBuffer();vt(r,()=>r.bindBuffer(r.PIXEL_PACK_BUFFER,o));let a=4*4*t*e;return vt(r,()=>r.bufferData(r.PIXEL_PACK_BUFFER,a,r.STREAM_READ)),vt(r,()=>r.readPixels(0,0,e,t,r.RGBA,r.FLOAT,0)),vt(r,()=>r.bindBuffer(r.PIXEL_PACK_BUFFER,null)),o}function lT(r,t,e){let n=r,o=new Float32Array(e);return n.bindBuffer(n.PIXEL_PACK_BUFFER,t),n.getBufferSubData(n.PIXEL_PACK_BUFFER,0,o),n.bindBuffer(n.PIXEL_PACK_BUFFER,null),o}function uT(r,t,e,n){let[o,s]=Xc(t,e),i=4,a=new Uint8Array($M(t*e,i));return vt(r,()=>r.readPixels(0,0,o,s,n.downloadTextureFormat,r.UNSIGNED_BYTE,a)),new Float32Array(a.buffer)}function cT(r,t,e,n,o,s,i,a){let u=r,l=new Float32Array(DM(s,i));return u.bindBuffer(u.PIXEL_PACK_BUFFER,t),u.getBufferSubData(u.PIXEL_PACK_BUFFER,0,l),u.bindBuffer(u.PIXEL_PACK_BUFFER,null),l}function pT(r,t,e){let n=new Float32Array(t*e*4);return vt(r,()=>r.readPixels(0,0,e,t,r.RGBA,r.FLOAT,n)),n}var Jc=class{constructor(t){this.outputTexture=null,this.program=null,this.disposed=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[];let e=V().getNumber("WEBGL_VERSION");t!=null?(this.gl=t,NN(e,t)):this.gl=Wn(e);let n="WEBGL_color_buffer_float",o="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),V().getNumber("WEBGL_VERSION")===1){let s="OES_texture_float",i="OES_texture_half_float";if(this.textureFloatExtension=ld(this.gl,s),Un(this.gl,i))this.textureHalfFloatExtension=ld(this.gl,i);else if(V().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),Un(this.gl,o))this.colorBufferHalfFloatExtension=ld(this.gl,o);else if(V().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",Un(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else if(Un(this.gl,o))this.colorBufferHalfFloatExtension=this.gl.getExtension(o);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=ZN(this.gl),this.indexBuffer=JN(this.gl),this.framebuffer=LN(this.gl),this.textureConfig=yg(this.gl,this.textureHalfFloatExtension)}get debug(){return V().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");let t=this.gl;vt(t,()=>t.finish()),vt(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,null)),vt(t,()=>t.deleteFramebuffer(this.framebuffer)),vt(t,()=>t.bindBuffer(t.ARRAY_BUFFER,null)),vt(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null)),vt(t,()=>t.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(t,e){return this.throwIfDisposed(),QN(this.gl,t,e,this.textureConfig)}createFloat16MatrixTexture(t,e){return this.throwIfDisposed(),tT(this.gl,t,e,this.textureConfig)}createUnsignedBytesMatrixTexture(t,e){return this.throwIfDisposed(),eT(this.gl,t,e,this.textureConfig)}uploadPixelDataToTexture(t,e){this.throwIfDisposed(),iT(this.gl,t,e)}uploadDenseMatrixToTexture(t,e,n,o){this.throwIfDisposed(),sT(this.gl,t,e,n,o,this.textureConfig)}createFloat16PackedMatrixTexture(t,e){return this.throwIfDisposed(),nT(this.gl,t,e,this.textureConfig)}createPackedMatrixTexture(t,e){return this.throwIfDisposed(),rT(this.gl,t,e,this.textureConfig)}deleteMatrixTexture(t){this.throwIfDisposed(),this.outputTexture===t&&(aw(this.gl,this.framebuffer),this.outputTexture=null),vt(this.gl,()=>this.gl.deleteTexture(t))}downloadByteEncodedFloatMatrixFromOutputTexture(t,e,n){return this.downloadMatrixDriver(t,()=>uT(this.gl,e,n,this.textureConfig))}downloadPackedMatrixFromBuffer(t,e,n,o,s,i){return cT(this.gl,t,e,n,o,s,i,this.textureConfig)}downloadFloat32MatrixFromBuffer(t,e){return lT(this.gl,t,e)}createBufferFromTexture(t,e,n){this.bindTextureToFrameBuffer(t);let o=aT(this.gl,e,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),o}createAndWaitForFence(){let t=this.createFence(this.gl);return this.pollFence(t)}createFence(t){let e,n;if(V().getBool("WEBGL_FENCE_API_ENABLED")){let o=t,s=o.fenceSync(o.SYNC_GPU_COMMANDS_COMPLETE,0);t.flush(),n=()=>{let i=o.clientWaitSync(s,0,0);return i===o.ALREADY_SIGNALED||i===o.CONDITION_SATISFIED},e=s}else V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(e=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(e,V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:e,isFencePassed:n}}downloadMatrixFromPackedTexture(t,e,n){return this.downloadMatrixDriver(t,()=>pT(this.gl,e,n))}createProgram(t){this.throwIfDisposed();let e=this.gl;this.vertexShader==null&&(this.vertexShader=YN(e));let n=DN(e);return vt(e,()=>e.attachShader(n,this.vertexShader)),vt(e,()=>e.attachShader(n,t)),RN(e,n),this.debug&&bg(e,n),this.vertexAttrsAreBound||(this.setProgram(n),this.vertexAttrsAreBound=oT(e,this.program,this.vertexBuffer)),n}deleteProgram(t){this.throwIfDisposed(),t===this.program&&(this.program=null),t!=null&&vt(this.gl,()=>this.gl.deleteProgram(t))}setProgram(t){this.throwIfDisposed(),this.program=t,this.program!=null&&this.debug&&bg(this.gl,this.program),vt(this.gl,()=>this.gl.useProgram(t))}getUniformLocation(t,e,n=!0){return this.throwIfDisposed(),n?zN(this.gl,t,e):BN(this.gl,t,e)}getAttributeLocation(t,e){return this.throwIfDisposed(),vt(this.gl,()=>this.gl.getAttribLocation(t,e))}getUniformLocationNoThrow(t,e){return this.throwIfDisposed(),this.gl.getUniformLocation(t,e)}setInputMatrixTexture(t,e,n){this.throwIfDisposed(),this.throwIfNoProgram(),VN(this.gl,t,e,n)}setOutputMatrixTexture(t,e,n){this.setOutputMatrixTextureDriver(t,n,e)}setOutputPackedMatrixTexture(t,e,n){this.throwIfDisposed();let[o,s]=Zi(e,n);this.setOutputMatrixTextureDriver(t,o,s)}setOutputMatrixWriteRegion(t,e,n,o){this.setOutputMatrixWriteRegionDriver(n,t,o,e)}setOutputPackedMatrixWriteRegion(t,e,n,o){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&bg(this.gl,this.program),ud(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();let t=this.gl;this.debug&&this.debugValidate(),vt(t,()=>t.drawElements(t.TRIANGLES,6,t.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),vt(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=ld(this.gl,V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let n=this.gl,o=this.getQueryTimerExtensionWebGL2(),s=n.createQuery();return n.beginQuery(o.TIME_ELAPSED_EXT,s),s}let t=this.getQueryTimerExtensionWebGL1(),e=t.createQueryEXT();return t.beginQueryEXT(t.TIME_ELAPSED_EXT,e),e}endQuery(){if(V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let e=this.gl,n=this.getQueryTimerExtensionWebGL2();e.endQuery(n.TIME_ELAPSED_EXT);return}let t=this.getQueryTimerExtensionWebGL1();t.endQueryEXT(t.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(t){return await x.repeatedTry(()=>this.disposed||this.isQueryAvailable(t,V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(t,V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(t,e){if(e===0)return null;if(e===2){let n=this.gl;return n.getQueryParameter(t,n.QUERY_RESULT)/1e6}else{let n=this.getQueryTimerExtensionWebGL1();return n.getQueryObjectEXT(t,n.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(t,e){if(e===0)return!0;if(e===2){let n=this.gl,o=this.getQueryTimerExtensionWebGL2(),s=n.getQueryParameter(t,n.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(o.GPU_DISJOINT_EXT)),s&&!this.disjoint}else{let n=this.getQueryTimerExtensionWebGL1(),o=n.getQueryObjectEXT(t,n.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),o&&!this.disjoint}}pollFence(t){return new Promise(e=>{this.addItemToPoll(()=>t.isFencePassed(),()=>e())})}pollItems(){let t=dtt(this.itemsToPoll.map(e=>e.isDoneFn));for(let e=0;e<=t;++e){let{resolveFn:n}=this.itemsToPoll[e];n()}this.itemsToPoll=this.itemsToPoll.slice(t+1)}addItemToPoll(t,e){this.itemsToPoll.push({isDoneFn:t,resolveFn:e}),!(this.itemsToPoll.length>1)&&x.repeatedTry(()=>(this.pollItems(),this.itemsToPoll.length===0))}bindTextureToFrameBuffer(t){this.throwIfDisposed(),wg(this.gl,t,this.framebuffer),this.debug&&ud(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(wg(this.gl,this.outputTexture,this.framebuffer),this.debug&&ud(this.gl)):aw(this.gl,this.framebuffer)}downloadMatrixDriver(t,e){this.bindTextureToFrameBuffer(t);let n=e();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(t,e,n){this.throwIfDisposed();let o=this.gl;wg(o,t,this.framebuffer),this.debug&&ud(o),this.outputTexture=t,vt(o,()=>o.viewport(0,0,e,n)),vt(o,()=>o.scissor(0,0,e,n))}setOutputMatrixWriteRegionDriver(t,e,n,o){this.throwIfDisposed(),vt(this.gl,()=>this.gl.scissor(t,e,n,o))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}};function dtt(r){let t=0;for(;t<r.length&&r[t]();++t);return t-1}var{addImpl:qM,bincountImpl:Cw,bincountReduceImpl:KM,ceilImpl:jM,concatImpl:XM,equalImpl:YM,expImpl:ZM,expm1Impl:JM,floorImpl:QM,gatherNdImpl:tP,gatherV2Impl:eP,greaterImpl:rP,greaterEqualImpl:nP,lessImpl:oP,lessEqualImpl:sP,linSpaceImpl:iP,logImpl:aP,maxImpl:lP,maximumImpl:uP,minimumImpl:cP,multiplyImpl:pP,negImpl:mP,notEqualImpl:fP,prodImpl:dP,rangeImpl:hP,rsqrtImpl:gP,sigmoidImpl:xP,simpleAbsImpl:Iw,sliceImpl:yP,sparseFillEmptyRowsImpl:bP,sparseReshapeImpl:wP,sparseSegmentReductionImpl:Sw,sqrtImpl:vP,stridedSliceImpl:CP,stringNGramsImpl:IP,stringSplitImpl:SP,stringToHashBucketFastImpl:kP,subImpl:NP,tileImpl:TP,topKImpl:_P,transposeImpl:Qc,uniqueImpl:EP}=Yb;function fT(r,t){return["x","y","z","w","u","v"].slice(0,t).map(e=>`${r}.${e}`)}function nr(r,t){return t===1?[r]:fT(r,t)}function AP(r,t){if(r===1)return"rc";let e="";for(let n=0;n<r;n++)e+=t[n],n<r-1&&(e+=",");return e}var kw=class{constructor(t){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.enableShapeUniforms=De(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{let e=nr("rc",this.rank),n=Vt(this.rank),o=this.getOutOfBoundsCondition(e),s=this.getSetup(e),i=this.getOutput(e);this.userCode=`
        void main() {
          ${n} rc = getOutputCoords();

          if(${o}) {
            setOutput(vec4(0));
          } else {
            ${s}

            setOutput(vec4(${i}));
          }
        }
      `}}getSourceCoordsArr(t){let e=[];for(let n=0;n<=1;n++)for(let o=0;o<=1;o++){let s=`${n===0?"r":"rp1"}, ${o===0?"c":"cp1"}`;for(let i=2;i<this.rank;i++)s=`${t[t.length-1-i]},`+s;e.push(s)}return e}getOutOfBoundsCondition(t){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let e="";for(let n=this.rank-2;n<this.rank;n++)e+=`${t[n]} >= ${this.enableShapeUniforms?`outShape[${n}]`:this.outputShape[n]}`,n<this.rank-1&&(e+="||");return e}getSetup(t){if(this.rank===1)return"";let e=t.slice(-2),n=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],o=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${e[0]};
      int c = ${e[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${n};
      bool rEdge = rp1 >= ${o};
    `}getOutput(t){let e=this.getSourceCoordsArr(t);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${e[0]}),
            cEdge ? 0. : getA(${e[1]}),
            rEdge ? 0. : getA(${e[2]}),
            rEdge || cEdge ? 0. : getA(${e[3]})`}};var yd=class{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=t,this.enableShapeUniforms=De(this.outputShape.length);let n="";for(let o=0;o<4;o++){let s="thisRC = rc;";o%2===1&&(s+="thisRC.z += 1;"),o>1&&(s+="thisRC.y += 1;"),n+=`
        ${s}
        ${o>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${o}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${o>0?"}":""}
      `}this.userCode=`
      ${htt(e,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?md():pd(t)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":t[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":t[2]};

        ${n}

        setOutput(result);
      }
    `}};function htt(r,t){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${t?PM(["r","c","d"],"inputShape"):di(["r","c","d"],r)}
      return ivec3(r, c, d);
    }
  `}var Nw=class{constructor(t){this.gpgpu=t,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(t,e,n){let o=DP(e,n),s=RP(t,o,n);s in this.freeTextures||(this.freeTextures[s]=[]),s in this.usedTextures||(this.usedTextures[s]=[]);let i=$P(t,o,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[s].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=i,this.log();let u=this.freeTextures[s].shift();return this.usedTextures[s].push(u),u}let a;return o===Rr.PACKED_2X2_FLOAT32?a=this.gpgpu.createPackedMatrixTexture(t[0],t[1]):o===Rr.PACKED_2X2_FLOAT16?a=this.gpgpu.createFloat16PackedMatrixTexture(t[0],t[1]):o===Rr.UNPACKED_FLOAT32?a=this.gpgpu.createFloat32MatrixTexture(t[0],t[1]):o===Rr.UNPACKED_FLOAT16?a=this.gpgpu.createFloat16MatrixTexture(t[0],t[1]):o===Rr.PACKED_4X1_UNSIGNED_BYTE&&(a=this.gpgpu.createUnsignedBytesMatrixTexture(t[0],t[1])),this.usedTextures[s].push(a),this.numUsedTextures++,this._numBytesAllocated+=i,this.log(),a}releaseTexture(t,e,n,o){if(this.freeTextures==null)return;let s=DP(n,o),i=RP(e,s,o);i in this.freeTextures||(this.freeTextures[i]=[]);let a=$P(e,s,this.gpgpu.gl,this.gpgpu.textureConfig,o),u=V().get("WEBGL_DELETE_TEXTURE_THRESHOLD");u!==-1&&this._numBytesAllocated>u?(this.gpgpu.deleteMatrixTexture(t.texture),this._numBytesAllocated-=a):(this.freeTextures[i].push(t),this.numFreeTextures++,this._numBytesFree+=a),this.numUsedTextures--;let l=this.usedTextures[i],c=l.indexOf(t);if(c<0)throw new Error("Cannot release a texture that was never provided by this texture manager");l.splice(c,1),this.log()}log(){if(!this.logEnabled)return;let t=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${t})`);let e=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*e)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(let t in this.freeTextures)this.freeTextures[t].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});for(let t in this.usedTextures)this.usedTextures[t].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}};function gtt(r,t){let e=r;if(t===e.R32F)return 4;if(t===e.R16F)return 2;if(t===e.RGBA32F)return 16;if(t===r.RGBA)return 16;if(t===e.RGBA16F)return 8;if(t===e.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}function $P(r,t,e,n,o){let s=xtt(t,n),i;if(o){let[u,l]=Zi(r[0],r[1]);i=u*l}else{let[u,l]=Xc(r[0],r[1]);i=u*l}let a=gtt(e,s);return i*a}function xtt(r,t){switch(r){case Rr.PACKED_2X2_FLOAT32:return ww(t);case Rr.PACKED_2X2_FLOAT16:return vw(t);case Rr.UNPACKED_FLOAT32:return xw(t);case Rr.UNPACKED_FLOAT16:return yw(t);case Rr.PACKED_4X1_UNSIGNED_BYTE:return bw(t);default:throw new Error(`Unknown physical texture type ${r}`)}}function ytt(r){return V().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?r?Rr.PACKED_2X2_FLOAT32:Rr.UNPACKED_FLOAT32:r?Rr.PACKED_2X2_FLOAT16:Rr.UNPACKED_FLOAT16}function DP(r,t){if(r===Kr.UPLOAD)return Rr.PACKED_2X2_FLOAT32;if(r===Kr.RENDER||r==null)return ytt(t);if(r===Kr.DOWNLOAD||r===Kr.PIXELS)return Rr.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${r}`)}function RP(r,t,e){return`${r[0]}_${r[1]}_${t}_${e}`}var en=class{constructor(t,e){this.variableNames=["A"],this.outputShape=t,this.enableShapeUniforms=De(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${e}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}},hr="if (isnan(x)) return x;",FP="return x;",dT="return abs(x);";var OP="return (x >= 0.0) ? x : (exp(x) - 1.0);",MP=hr+`
  return (x < 0.0) ? 0.0 : x;
`,PP=hr+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,tp="return x;",LP="return 1.0 / (1.0 + exp(-1.0 * x));";var BP="return x;",VP=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,GP=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,WP=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,UP="return 1.0 / (1.0 + exp(-1.0 * x));",eo=class{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.enableShapeUniforms=De(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${e}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}};var Tw=class{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=t,this.enableShapeUniforms=De(this.outputShape.length);let e=t.length,n=nr("rc",e),o=Vt(e),s=AP(e,n),i=n.slice(-2),a=e<=1?"rc":`vec2(${i.join(",")})`;this.userCode=`
      void main() {
        ${o} rc = getOutputCoords();
        vec4 packedInput = getA(${s});

        setOutput(getChannel(packedInput, ${a}));
      }
    `}};var wtt=Gr.whereImpl,vtt=1e-7,Ctt=1e-4,_w={};function Itt(r){return r in _w||(_w[r]={}),_w[r]}var Stt=V().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),ktt=600;function Ntt(){return V().global.screen==null?1024:V().global.screen.height*V().global.screen.width*window.devicePixelRatio*ktt/1024/1024}var bu=class extends jo{constructor(t){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!V().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let e;if(t!=null){if(t instanceof Jc)e=t;else{let n=Wn(V().getNumber("WEBGL_VERSION"),t);e=new Jc(n)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{let n=Wn(V().getNumber("WEBGL_VERSION"));e=new Jc(n),this.binaryCache=Itt(V().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=e,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new Nw(this.gpgpu),this.numMBBeforeWarning=Ntt(),this.texData=new Ji(this,go())}nextDataId(){return bu.nextDataId++}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}write(t,e,n){if((V().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||V().getBool("DEBUG"))&&this.checkNumericalProblems(t),n==="complex64"&&t!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");let o={id:this.nextDataId()};return this.texData.set(o,{shape:e,dtype:n,values:t,usage:Kr.UPLOAD,refCount:1}),o}refCount(t){return this.texData.has(t)?this.texData.get(t).refCount:0}incRef(t){let e=this.texData.get(t);e.refCount++}decRef(t){if(this.texData.has(t)){let e=this.texData.get(t);e.refCount--}}move(t,e,n,o,s){if(V().getBool("DEBUG")&&this.checkNumericalProblems(e),o==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(t,{shape:n,dtype:o,values:e,usage:Kr.UPLOAD,refCount:s})}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}readSync(t){let e=this.texData.get(t),{values:n,dtype:o,complexTensorInfos:s,slice:i,shape:a,isPacked:u}=e;if(i!=null){let m;u?m=new eo(a,tp):m=new en(a,tp);let f=this.runWebGLProgram(m,[{dataId:t,shape:a,dtype:o}],o),d=this.readSync(f.dataId);return this.disposeIntermediateTensorInfo(f),d}if(n!=null)return this.convertAndCacheOnCPU(t);if(o==="string")return n;let l=this.activeTimers!=null,c;l&&(c=x.now());let p;if(o==="complex64"){let m=this.readSync(s.real.dataId),f=this.readSync(s.imag.dataId);p=S.mergeRealAndImagArrays(m,f)}else p=this.getValuesFromTexture(t);return l&&(this.downloadWaitMs+=x.now()-c),this.convertAndCacheOnCPU(t,p)}async read(t){if(this.pendingRead.has(t)){let d=this.pendingRead.get(t);return new Promise(h=>d.push(h))}let e=this.texData.get(t),{values:n,shape:o,slice:s,dtype:i,complexTensorInfos:a,isPacked:u}=e;if(s!=null){let d;u?d=new eo(o,tp):d=new en(o,tp);let h=this.runWebGLProgram(d,[{dataId:t,shape:o,dtype:i}],i),g=this.read(h.dataId);return this.disposeIntermediateTensorInfo(h),g}if(n!=null)return this.convertAndCacheOnCPU(t);if(V().getBool("DEBUG")&&!V().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&V().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let l=null,c;if(i!=="complex64"&&V().get("WEBGL_BUFFER_SUPPORTED")){c=this.decode(t);let d=this.texData.get(c.dataId);l=this.gpgpu.createBufferFromTexture(d.texture.texture,...xg(o))}this.pendingRead.set(t,[]),i!=="complex64"&&await this.gpgpu.createAndWaitForFence();let p;if(i==="complex64"){let d=await Promise.all([this.read(a.real.dataId),this.read(a.imag.dataId)]),h=d[0],g=d[1];p=S.mergeRealAndImagArrays(h,g)}else if(l==null)p=this.getValuesFromTexture(t);else{let d=x.sizeFromShape(o);p=this.gpgpu.downloadFloat32MatrixFromBuffer(l,d)}if(c!=null&&this.disposeIntermediateTensorInfo(c),l!=null){let d=this.gpgpu.gl;vt(d,()=>d.deleteBuffer(l))}let m=this.convertAndCacheOnCPU(t,p),f=this.pendingRead.get(t);return this.pendingRead.delete(t),f.forEach(d=>d(m)),this.pendingDisposal.has(t)&&(this.pendingDisposal.delete(t),this.disposeData(t)&&go().removeDataId(t,this),this.pendingDeletes--),m}readToGPU(t,e={}){let n=this.texData.get(t),{values:o,shape:s,slice:i,dtype:a,isPacked:u,texture:l}=n;if(a==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(i!=null){let f;u?f=new eo(s,tp):f=new en(s,tp);let d=this.runWebGLProgram(f,[{dataId:t,shape:s,dtype:a}],a),h=this.readToGPU(d,e);return this.disposeIntermediateTensorInfo(d),h}if(l==null)throw o!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");let c=this.decode(t,e.customTexShape),p=go().makeTensorFromDataId(c.dataId,c.shape,c.dtype),m=this.texData.get(c.dataId);return Object.assign({tensorRef:p},m.texture)}bufferSync(t){let e=this.readSync(t.dataId),n=e;if(t.dtype==="string")try{n=e.map(o=>x.decodeString(o))}catch(o){throw new Error("Failed to decode encoded string bytes into utf-8")}return It(t.shape,t.dtype,n)}checkNumericalProblems(t){if(t!=null)for(let e=0;e<t.length;e++){let n=t[e];if(!EN(n))throw V().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${n} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${n} cannot be represented on this device.`)}}getValuesFromTexture(t){let{shape:e,dtype:n,isPacked:o}=this.texData.get(t),s=x.sizeFromShape(e);if(V().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){let m=this.decode(t),f=this.texData.get(m.dataId),d=this.gpgpu.downloadMatrixFromPackedTexture(f.texture.texture,...xg(e)).subarray(0,s);return this.disposeIntermediateTensorInfo(m),d}let i=V().getBool("WEBGL_PACK")&&o===!0,a=i?vg(e):e,u=i?new dw(a):new fw(a),l=this.runWebGLProgram(u,[{shape:a,dtype:n,dataId:t}],"float32"),c=this.texData.get(l.dataId),p=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(c.texture.texture,c.texShape[0],c.texShape[1]).subarray(0,s);return this.disposeIntermediateTensorInfo(l),p}timerAvailable(){return V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(t){let e=this.activeTimers,n=[],o=!1;this.programTimersStack==null?(this.programTimersStack=n,o=!0):this.activeTimers.push(n),this.activeTimers=n,t();let s=x.flatten(this.activeTimers.map(u=>u.query)).filter(u=>u!=null),i=x.flatten(this.activeTimers.map(u=>u.name)).filter(u=>u!=null);this.activeTimers=e,o&&(this.programTimersStack=null);let a={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){let u=await Promise.all(s);a.kernelMs=x.sum(u),a.getExtraProfileInfo=()=>u.map((l,c)=>({name:i[c],ms:l})).map(l=>`${l.name}: ${l.ms}`).join(", ")}else a.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,a})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:x.now(),endMs:null}}endTimer(t){return V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),t):(t.endMs=x.now(),t)}async getQueryTime(t){if(V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(t);let e=t;return e.endMs-e.startMs}disposeData(t,e=!1){if(this.pendingDisposal.has(t))return!1;if(!this.texData.has(t))return!0;if(e?this.texData.get(t).refCount=0:this.texData.get(t).refCount--,!e&&this.texData.get(t).refCount>0)return!1;if(this.pendingRead.has(t))return this.pendingDisposal.add(t),this.pendingDeletes++,!1;this.releaseGPUData(t);let{complexTensorInfos:n}=this.texData.get(t);return n!=null&&(this.disposeData(n.real.dataId,e),this.disposeData(n.imag.dataId,e)),this.texData.delete(t),!0}releaseGPUData(t){let{texture:e,dtype:n,texShape:o,usage:s,isPacked:i,slice:a}=this.texData.get(t),u=a&&a.origDataId||t,l=this.dataRefCount.get(u);l>1?this.dataRefCount.set(u,l-1):(this.dataRefCount.delete(u),e!=null&&(this.numBytesInGPU-=this.computeBytes(o,n),this.textureManager.releaseTexture(e,o,s,i)));let c=this.texData.get(t);c.texture=null,c.texShape=null,c.isPacked=!1,c.slice=null}getTexture(t){return this.uploadToGPU(t),this.texData.get(t).texture.texture}getDataInfo(t){return this.texData.get(t)}shouldExecuteOnCPU(t,e=Stt){return V().getBool("WEBGL_CPU_FORWARD")&&t.every(n=>this.texData.get(n.dataId).texture==null&&x.sizeFromShape(n.shape)<e)}getGPGPUContext(){return this.gpgpu}where(t){S.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");let e=t.dataSync();return wtt(t.shape,e)}packedUnaryOp(t,e,n){let o=new eo(t.shape,e),s=this.compileAndRun(o,[t],n);return go().makeTensorFromDataId(s.dataId,s.shape,s.dtype)}abs(t){if(this.shouldExecuteOnCPU([t])&&t.dtype!=="complex64"){let o=Iw(this.texData.get(t.dataId).values);return this.makeOutput(t.shape,t.dtype,o)}if(V().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,dT,t.dtype);let e=new en(t.shape,dT),n=this.compileAndRun(e,[t]);return go().makeTensorFromDataId(n.dataId,n.shape,n.dtype)}makeTensorInfo(t,e,n){let o;if(e==="string"&&n!=null&&n.length>0&&x.isString(n[0])){let s=n.map(i=>x.encodeString(i));o=this.write(s,t,e)}else o=this.write(n,t,e);return this.texData.get(o).usage=null,{dataId:o,shape:t,dtype:e}}makeOutput(t,e,n){let{dataId:o}=this.makeTensorInfo(t,e,n);return go().makeTensorFromDataId(o,t,e,this)}unpackTensor(t){let e=new Tw(t.shape);return this.runWebGLProgram(e,[t],t.dtype)}packTensor(t){let e=new kw(t.shape),n=!0;return this.runWebGLProgram(e,[t],t.dtype,null,n)}packedReshape(t,e){let n=[vl(t.shape),...Cl(t.shape)],o={dtype:t.dtype,shape:n,dataId:t.dataId},s=[vl(e),...Cl(e)],i=new yd(s,n),a=!0,u=[n],l=this.runWebGLProgram(i,[o],t.dtype,u,a);return{dataId:l.dataId,shape:e,dtype:l.dtype}}decode(t,e){let n=this.texData.get(t),{isPacked:o,shape:s,dtype:i}=n;if(e!=null){let m=x.sizeFromShape(s),f=e[0]*e[1]*4;x.assert(m<=f,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}let a=vg(s),u;o?u=new mw(a):u=new pw(a);let l=!0,c=[e!=null?e:xg(a)],p=this.runWebGLProgram(u,[{shape:a,dtype:i,dataId:t}],i,c,l,e);return{dtype:i,shape:s,dataId:p.dataId}}runWebGLProgram(t,e,n,o,s=!1,i){let a=this.makeTensorInfo(t.outputShape,n),u=this.texData.get(a.dataId);if(t.packedOutput&&(u.isPacked=!0),t.outPackingScheme===xu.DENSE){let y=i!=null?i:xg(t.outputShape);u.texShape=y.map(b=>b*2)}if(t.outTexUsage!=null&&(u.usage=t.outTexUsage),x.sizeFromShape(a.shape)===0)return u.values=x.getTypedArrayFromDType(a.dtype,0),a;let l=[],c=e.map(y=>{if(y.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let b=this.texData.get(y.dataId);if(b.texture==null){if(!t.packedInputs&&x.sizeFromShape(y.shape)<=V().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:y.shape,texData:null,isUniform:!0,uniformValues:b.values};t.packedInputs&&(b.isPacked=!0,b.shape=y.shape)}if(this.uploadToGPU(y.dataId),!!b.isPacked!=!!t.packedInputs)y=b.isPacked?this.unpackTensor(y):this.packTensor(y),l.push(y),b=this.texData.get(y.dataId);else if(b.isPacked&&!yu(b.shape,y.shape)){let w=y,v=y.shape;y.shape=b.shape,y=this.packedReshape(y,v),l.push(y),b=this.texData.get(y.dataId),w.shape=v}return{shape:y.shape,texData:b,isUniform:!1}});this.uploadToGPU(a.dataId);let p={shape:a.shape,texData:u,isUniform:!1},m=HM(t,c,p),f=this.getAndSaveBinary(m,()=>WM(this.gpgpu,t,c,p)),d=this.activeTimers!=null,h;d&&(h=this.startTimer()),V().get("ENGINE_COMPILE_ONLY")||UM(this.gpgpu,f,c,p,o),l.forEach(y=>this.disposeIntermediateTensorInfo(y)),d&&(h=this.endTimer(h),this.activeTimers.push({name:t.constructor.name,query:this.getQueryTime(h)}));let g=V().get("WEBGL_FLUSH_THRESHOLD");if(g>0){let y=x.now();y-this.lastGlFlushTime>g&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=y)}if(!V().getBool("WEBGL_LAZILY_UNPACK")&&u.isPacked&&s===!1){let y=this.unpackTensor(a);return this.disposeIntermediateTensorInfo(a),y}return a}compileAndRun(t,e,n,o,s=!1){return n=n||e[0].dtype,this.runWebGLProgram(t,e,n,o,s)}getAndSaveBinary(t,e){return t in this.binaryCache||(this.binaryCache[t]=e()),this.binaryCache[t]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(V().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement!="undefined"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=B(()=>{if(!V().get("WEBGL_RENDER_FLOAT32_ENABLED")){let t=V().getBool("DEBUG");V().set("DEBUG",!1);let e=this.abs(pt(1e-8)).dataSync()[0];if(V().set("DEBUG",t),e>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?vtt:Ctt}uploadToGPU(t){let e=this.texData.get(t),{shape:n,dtype:o,values:s,texture:i,usage:a,isPacked:u}=e;if(i!=null)return;let l=this.activeTimers!=null,c;l&&(c=x.now());let p=e.texShape;if(p==null&&(p=GN(n,u),e.texShape=p),s!=null){let m=vg(n),f,d=p[1],h=p[0],g=s instanceof Uint8Array||s instanceof Uint8ClampedArray;(u||!g)&&([d,h]=Zi(p[0],p[1])),u?f=new gw(m,g):f=new hw(m,g);let y=g?[h,d]:p,b=this.makeTensorInfo(y,o),w=this.texData.get(b.dataId);g?w.usage=Kr.PIXELS:w.usage=Kr.UPLOAD,w.texShape=y,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(b.dataId),d,h,s);let v=[[h,d]],k=!0,E=this.runWebGLProgram(f,[b],o,v,k),$=this.texData.get(E.dataId);e.texShape=$.texShape,e.isPacked=$.isPacked,e.usage=$.usage,V().get("ENGINE_COMPILE_ONLY")?this.disposeData(E.dataId):(e.texture=$.texture,e.values=null,this.texData.delete(E.dataId)),this.disposeIntermediateTensorInfo(b),l&&(this.uploadWaitMs+=x.now()-c)}else{let m=this.acquireTexture(p,a,o,u);e.texture=m}}convertAndCacheOnCPU(t,e){let n=this.texData.get(t),{dtype:o}=n;return this.releaseGPUData(t),e!=null&&(n.values=Ttt(e,o)),n.values}acquireTexture(t,e,n,o){if(this.numBytesInGPU+=this.computeBytes(t,n),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){let s=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${s} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(t,e,o)}computeBytes(t,e){return t[0]*t[1]*x.bytesPerElement(e)}checkCompileCompletion(){for(let[,t]of Object.entries(this.binaryCache))this.checkCompletion_(t)}async checkCompileCompletionAsync(){let t=[];if(this.gpgpu.parallelCompilationExtension){for(let[,e]of Object.entries(this.binaryCache))t.push(this.checkCompletionAsync_(e));return Promise.all(t)}else{for(let[,e]of Object.entries(this.binaryCache)){let n=new Promise(o=>{try{this.checkCompletion_(e),o(!0)}catch(s){throw s}});t.push(n)}return Promise.all(t)}}async checkCompletionAsync_(t){return this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(t):(await Vh(),this.checkCompletionAsync_(t))}checkCompletion_(t){if(this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(t.webGLProgram)),this.gpgpu.gl.getShaderParameter(t.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(sw(t.source,this.gpgpu.gl.getShaderInfoLog(t.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(let[,t]of Object.entries(this.binaryCache)){let{uniformLocations:e,customUniformLocations:n,infLoc:o,nanLoc:s,inShapesLocations:i,inTexShapesLocations:a,outShapeLocation:u,outShapeStridesLocation:l,outTexShapeLocation:c}=XN(this.gpgpu,t.program,t.webGLProgram);t.uniformLocations=e,t.customUniformLocations=n,t.infLoc=o,t.nanLoc=s,t.inShapesLocations=i,t.inTexShapesLocations=a,t.outShapeLocation=u,t.outShapeStridesLocation=l,t.outTexShapeLocation=c}}};bu.nextDataId=0;function Ttt(r,t){if(t==="float32"||t==="complex64")return r;if(t==="int32"||t==="bool"){let e=t==="int32"?new Int32Array(r.length):new Uint8Array(r.length);for(let n=0;n<e.length;++n)e[n]=Math.round(r[n]);return e}else throw new Error(`Unknown dtype ${t}`)}var HP="3.15.0";function qP(){V().set("WEBGL_FORCE_F16_TEXTURES",!0)}jl.isBrowser()&&fm("webgl",()=>new bu,2);var YSe={forceHalfFloat:qP};var Ew=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;var ro=class{constructor(t,e,n){this.variableNames=["A","B"],this.outputShape=S.assertAndGetBroadcastShape(e,n),this.enableShapeUniforms=De(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${t}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}};var wu=`
  result.r = isNaN.r > 0. ? NAN : result.r;
  result.g = isNaN.g > 0. ? NAN : result.g;
  result.b = isNaN.b > 0. ? NAN : result.b;
  result.a = isNaN.a > 0. ? NAN : result.a;
`;var Po=class{constructor(t,e,n,o=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=S.assertAndGetBroadcastShape(e,n);let s=this.outputShape.length;this.enableShapeUniforms=De(s);let i="";if(o)if(s===0||x.sizeFromShape(this.outputShape)===1)i=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(i=`
          ${Vt(s)} coords = getOutputCoords();
        `,s===1)this.enableShapeUniforms?i+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:i+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{let u=nr("coords",s);this.enableShapeUniforms?i+=`
            bool nextRowOutOfBounds =
              (${u[s-2]} + 1) >= outShape[${s} - 2];
            bool nextColOutOfBounds =
              (${u[s-1]} + 1) >= outShape[${s} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:i+=`
            bool nextRowOutOfBounds =
              (${u[s-2]} + 1) >= ${this.outputShape[s-2]};
            bool nextColOutOfBounds =
              (${u[s-1]} + 1) >= ${this.outputShape[s-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${t}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${i}

        setOutput(result);
      }
    `}};function Ke(r){let{inputs:t,backend:e}=r,{x:n}=t;return e.incRef(n.dataId),{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}var KP={kernelName:lo,backendName:"webgl",kernelFunc:Ke};function Rn(r){let{inputs:t,backend:e}=r,{real:n,imag:o}=t,s=e.makeTensorInfo(n.shape,"complex64"),i=e.texData.get(s.dataId),a=Ke({inputs:{x:n},backend:e}),u=Ke({inputs:{x:o},backend:e});return i.complexTensorInfos={real:a,imag:u},s}var jP={kernelName:Ap,backendName:"webgl",kernelFunc:Rn};var hT="return (a < 0.) ? b * a : a;",gT=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function _tt(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{alpha:s}=n,i=e.makeTensorInfo([],"float32",x.createScalarValue(s,"float32")),a=V().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Po(gT,o.shape,i.shape):new ro(hT,o.shape,i.shape),u=e.runWebGLProgram(a,[o,i],"float32");return e.disposeIntermediateTensorInfo(i),u}var XP={kernelName:hs,backendName:"webgl",kernelFunc:_tt};var xT="return (a < 0.) ? b * a : a;",yT=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function Ett(r){let{inputs:t,backend:e}=r,{x:n,alpha:o}=t,s=V().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Po(yT,n.shape,o.shape):new ro(xT,n.shape,o.shape);return e.runWebGLProgram(s,[n,o],"float32")}var YP={kernelName:_s,backendName:"webgl",kernelFunc:Ett};var Lo="if (isnan(x)) return x;",ZP=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`,JP=`
  result.r = isNaN.r > 0. ? NAN : result.r;
  result.g = isNaN.g > 0. ? NAN : result.g;
  result.b = isNaN.b > 0. ? NAN : result.b;
  result.a = isNaN.a > 0. ? NAN : result.a;
`;function Ct({opSnippet:r,packedOpSnippet:t,cpuKernelImpl:e,dtype:n}){return({inputs:o,backend:s})=>{let{x:i}=o,a=s,u=n||i.dtype;if(a.shouldExecuteOnCPU([i])&&e!=null){let p=a.texData.get(i.dataId),m=e(p.values,u);return a.makeTensorInfo(i.shape,u,m)}let l=V().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&t!=null,c;return l?c=new eo(i.shape,t):c=new en(i.shape,r),a.runWebGLProgram(c,[i],u)}}function le({opSnippet:r,packedOpSnippet:t,checkOutOfBounds:e=!1,supportsComplex:n=!1,cpuKernelImpl:o,dtype:s}){return({inputs:i,backend:a})=>{let{a:u,b:l}=i,c=a;if(n&&u.dtype==="complex64"){let d=c.texData.get(u.dataId),h=c.texData.get(l.dataId),[g,y]=[[d.complexTensorInfos.real,h.complexTensorInfos.real],[d.complexTensorInfos.imag,h.complexTensorInfos.imag]].map(w=>{let[v,k]=w,E={dataId:v.dataId,dtype:v.dtype,shape:u.shape},$={dataId:k.dataId,dtype:k.dtype,shape:l.shape},D=new ro(r,u.shape,l.shape);return c.runWebGLProgram(D,[E,$],ar(v.dtype,k.dtype))}),b=Rn({inputs:{real:g,imag:y},backend:c});return c.disposeIntermediateTensorInfo(g),c.disposeIntermediateTensorInfo(y),b}let p=s||ar(u.dtype,l.dtype);if((u.dtype==="string"||l.dtype==="string"||c.shouldExecuteOnCPU([u,l]))&&o!=null){let d=c.texData.get(u.dataId).values,h=c.texData.get(l.dataId).values,g=u.dtype==="string"?S.fromUint8ToStringArray(d):d,y=u.dtype==="string"?S.fromUint8ToStringArray(h):h,[b,w]=o(u.shape,l.shape,g,y,p),v=c.makeTensorInfo(w,p),k=c.texData.get(v.dataId);return k.values=b,v}let m=V().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&t!=null,f;return m?f=new Po(t,u.shape,l.shape,e):f=new ro(r,u.shape,l.shape),c.runWebGLProgram(f,[u,l],p)}}function vu(r,t=!1){if(r==="linear")return t?BP:FP;if(r==="relu")return t?GP:MP;if(r==="elu")return t?VP:OP;if(r==="relu6")return t?WP:PP;if(r==="prelu")return t?yT:xT;if(r==="leakyrelu")return t?gT:hT;if(r==="sigmoid")return t?UP:LP;throw new Error(`Activation ${r} has not been implemented for the WebGL backend.`)}var bd=class{constructor(t,e,n,o=!1,s=!1,i=!1,a=null,u=!1,l=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=De(this.outputShape.length);let c=o?t[1]:t[2],p=Math.ceil(c/2),m=o?"i * 2, rc.y":"rc.y, i * 2",f=s?"rc.z, i * 2":"i * 2, rc.z",d=o?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],h=s?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"],g="",y="";a&&(u?g=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${a}
        }`:l?g=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${a}
        }`:g=`vec4 activation(vec4 x) {
          ${a}
        }`,y="result = activation(result);");let b=i?"result += getBiasAtOutCoords();":"";i&&this.variableNames.push("bias"),u&&this.variableNames.push("preluActivationWeights"),l&&this.variableNames.push("leakyreluAlpha");let w="rc.x",v="rc.x";t[0]<e[0]?w=`int(min(float(rc.x), ${t[0]-1}.))`:e[0]<t[0]&&(v=`int(min(float(rc.x), ${e[0]-1}.))`),this.userCode=`
      ${g}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${p}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        for (int i = 0; i < ${p}; i++) {
          int batchA = ${w};
          int batchB = ${v};
          vec4 a = getMatrixA(batchA, ${m});
          vec4 b = getMatrixB(batchB, ${f});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${d[0]} * ${h[0]});
          result += (${d[1]} * ${h[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${b}

        ${y}

        setOutput(result);
      }
    `}};var bT={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"},Ig=class{constructor(t,e,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=S.assertAndGetBroadcastShape(e,n),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${t}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}};var QP="return a * b;";function Sg(r){let{inputs:t,backend:e}=r,{a:n,b:o}=t,s=S.upcastType(n.dtype,o.dtype);if(n.dtype==="complex64"){let a=e.texData.get(n.dataId),u=e.texData.get(o.dataId),l=new Ig(bT.REAL,n.shape,o.shape),c=new Ig(bT.IMAG,n.shape,o.shape),p=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:n.shape},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:n.shape},{dataId:u.complexTensorInfos.real.dataId,dtype:u.complexTensorInfos.real.dtype,shape:o.shape},{dataId:u.complexTensorInfos.imag.dataId,dtype:u.complexTensorInfos.imag.dtype,shape:o.shape}],m=e.runWebGLProgram(l,p,"float32"),f=e.runWebGLProgram(c,p,"float32"),d=Rn({inputs:{real:m,imag:f},backend:e});return e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(f),d}if(e.shouldExecuteOnCPU([n,o])){let a=e.texData.get(n.dataId),u=e.texData.get(o.dataId),[l,c]=pP(n.shape,o.shape,a.values,u.values,s),p=e.makeTensorInfo(c,s),m=e.texData.get(p.dataId);return m.values=l,p}let i;return V().getBool("WEBGL_PACK_BINARY_OPERATIONS")?i=new Po(QP,n.shape,o.shape):i=new ro(QP,n.shape,o.shape),e.runWebGLProgram(i,[n,o],s)}var tL={kernelName:Ss,backendName:"webgl",kernelFunc:Sg};function eL(r,t,e){let n=[vl(r.shape),...Cl(r.shape)],o={dtype:r.dtype,shape:n,dataId:r.dataId},s=[vl(t),...Cl(t)],i=new yd(s,n),a=!0,u=[n],l=e.runWebGLProgram(i,[o],r.dtype,u,a);return{dataId:l.dataId,shape:t,dtype:l.dtype}}function ut(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{shape:s}=n,i=e,a=x.sizeFromShape(o.shape),u=x.inferFromImplicitShape(s,a),l=x.sizeFromShape(u);x.assert(a===l,()=>`The new shape (${u}) has ${l} elements and the old shape (${o.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`);let c=i.texData.get(o.dataId);return c.isPacked&&!yu(o.shape,u)&&!(c.texture!==null&&yu(c.shape,u))?eL(o,u,i):(i.incRef(o.dataId),{dataId:o.dataId,shape:u,dtype:o.dtype})}var rL={kernelName:Ti,backendName:"webgl",kernelFunc:ut};var kg=class{constructor(t,e){this.variableNames=["x"];let{windowSize:n,batchSize:o,inSize:s,outSize:i}=t;this.outputShape=[o,i];let a=Math.floor(n/4)*4,u=n%4,l="sumValue += dot(values, ones);";if(e!=null){let p=1/e;l=`sumValue += dot(values * ${x.isInt(p)?p.toPrecision(2):p}, ones);`}let c="";s%n>0&&(c=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${c}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n};

        float sumValue = 0.0;

        for (int i = 0; i < ${a}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${l}
        }

        int inIdx = inOffset + ${a};
        if (${u===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${l}
        } else if (${u===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${l}
        } else if (${u===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${l}
        }
        setOutput(sumValue);
      }
    `}};var Aw=class{constructor(t,e){this.variableNames=["x"];let{windowSize:n,batchSize:o,inSize:s,outSize:i}=t;this.outputShape=[o,i];let a="0.0",u="";e==="prod"?a="1.0":e==="min"?(a="1.0 / 1e-20",u="min"):e==="max"&&(a="-1.0 / 1e-20",u="max");let l=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;e==="sum"?l="sumValue":e==="prod"?l="prodValue":e==="all"?l="allValue":e==="any"&&(l="anyValue");let c=Math.floor(n/4)*4,p=n%4,m=`
      if (${e==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${e==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${u}(values, minMaxValue);
        if (${e==="min"} || ${e==="max"}) {
          minMaxValue = ${u}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,f="vec4";e==="all"?(a="1.0",m=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,f="bvec4"):e==="any"&&(a="0.0",m=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,f="bvec4");let d="";s%n>0&&(d=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${a};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${d}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n};

        vec4 minMaxValue = vec4(${a});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${c}; i += 4) {
          int inIdx = inOffset + i;
          ${f} values = ${f}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${m}
        }

        int inIdx = inOffset + ${c};
        if (${p===1}) {
          ${f} values = ${f}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${m}
        } else if (${p===2}) {
          ${f} values = ${f}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${m}
        } else if (${p===3}) {
          ${f} values = ${f}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${m}
        }
        setOutput(${l});
      }
    `}};function $tt(r){let t=[];for(;t.length===0||t[t.length-1].outSize!==1;){let e=t.length?t[t.length-1].outSize:r[1],n=S.computeOptimalWindowSize(e);t.push({inSize:e,windowSize:n,outSize:Math.ceil(e/n)})}return t}function Hn(r,t,e,n){let o=$tt(r.shape),s=r;for(let i=0;i<o.length;i++){let{inSize:a,windowSize:u,outSize:l}=o[i],c,p;e==="mean"?c=i===0?new kg({windowSize:u,inSize:a,batchSize:r.shape[0],outSize:l},a):new kg({windowSize:u,inSize:a,batchSize:r.shape[0],outSize:l}):c=new Aw({windowSize:u,inSize:a,batchSize:r.shape[0],outSize:l},e),p=s,s=n.runWebGLProgram(c,[s],t),p.dataId!==r.dataId&&n.disposeIntermediateTensorInfo(p)}return s}var $w=class{constructor(t,e){this.variableNames=["A"];let n=new Array(t.length);for(let i=0;i<n.length;i++)n[i]=t[e[i]];this.outputShape=n,this.rank=n.length;let o=Vt(this.rank),s=Dtt(e);this.userCode=`
    void main() {
      ${o} resRC = getOutputCoords();
      setOutput(getA(${s}));
    }
    `}};function Dtt(r){let t=r.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);let e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],n=new Array(t);for(let o=0;o<r.length;o++)n[r[o]]=e[o];return n.join()}var Dw=class{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;let n=new Array(t.length);for(let c=0;c<n.length;c++)n[c]=t[e[c]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);let o=Vt(this.rank),s=fT("rc",this.rank),i=new Array(this.rank);for(let c=0;c<e.length;c++)i[e[c]]=s[c];let a=`vec2(${i.slice(-2).join()})`,u=`++${s[this.rank-1]} < ${n[this.rank-1]}`,l=`getChannel(getA(${i.join()}), ${a})`;this.userCode=`
    void main() {
      ${o} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${l};
      if(${u}) {
        result[1] = ${l};
      }
      --${s[this.rank-1]};
      if(++${s[this.rank-2]} < ${n[this.rank-2]}) {
        result[2] = ${l};
        if(${u}) {
          result[3] = ${l};
        }
      }
      setOutput(result);
    }
    `}};function Cu(r,t,e){let n=V().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Dw(r.shape,t):new $w(r.shape,t);return e.runWebGLProgram(n,[r],r.dtype)}function nL(r,t,e,n){let o=t,s=r.shape.length,i=x.parseAxisParam(o,r.shape),a=i,u=S.getAxesPermutation(a,s),l=u!=null,c=r;l&&(c=Cu(r,u,n),a=S.getInnerMostAxes(a.length,s)),S.assertAxesAreInnerMostDims("sum",a,s);let[p,m]=S.computeOutAndReduceShapes(c.shape,a),f=p;e&&(f=S.expandShapeToKeepDim(p,i));let d=x.sizeFromShape(m),g=x.sizeFromShape(r.shape)/d,y=ut({inputs:{x:c},attrs:{shape:[g,d]},backend:n}),b=Wu(r.dtype),w=Hn(y,b,"sum",n),v=ut({inputs:{x:w},attrs:{shape:f},backend:n});return n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(w),l&&n.disposeIntermediateTensorInfo(c),v}function ep(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,keepDims:i}=n;return nL(o,s,i,e)}var oL={kernelName:Ls,backendName:"webgl",kernelFunc:ep};function Ae(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{perm:s}=n,i=e,a=o.shape.length,u=new Array(a);for(let c=0;c<u.length;c++)u[c]=o.shape[s[c]];let l;if(i.shouldExecuteOnCPU([o])){let p=i.texData.get(o.dataId).values,m=Qc(p,o.shape,o.dtype,s,u);l=i.makeTensorInfo(u,o.dtype);let f=i.texData.get(l.dataId);f.values=m}else l=Cu(o,s,i);return l}var sL={kernelName:Us,backendName:"webgl",kernelFunc:Ae};var wT=1e3;function rp({a:r,b:t,transposeA:e,transposeB:n,backend:o,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:a=0,activation:u=null}){let l=r.shape.length,c=t.shape.length,p=e?r.shape[l-2]:r.shape[l-1],m=n?t.shape[c-1]:t.shape[c-2],f=e?r.shape[l-1]:r.shape[l-2],d=n?t.shape[c-2]:t.shape[c-1],h=r.shape.slice(0,-2),g=t.shape.slice(0,-2),y=x.sizeFromShape(h),b=x.sizeFromShape(g),v=Pr.assertAndGetBroadcastShape(r.shape.slice(0,-2),t.shape.slice(0,-2)).concat([f,d]);x.assert(p===m,()=>`Error in matMul: inner shapes (${p}) and (${m}) of Tensors with shapes ${r.shape} and ${t.shape} and transposeA=${e} and transposeB=${n} must match.`);let k=e?[y,p,f]:[y,f,p],E=n?[b,d,m]:[b,m,d],$=ut({inputs:{x:r},backend:o,attrs:{shape:k}}),D=ut({inputs:{x:t},backend:o,attrs:{shape:E}}),R=[$,D],P=Math.max(y,b),W=e?$.shape[1]:$.shape[2],U=s!=null,q=i!=null,K=u==="leakyrelu",j=u!=null?vu(u,!0):null,Q=U||q||K||j!=null,rt;if((f===1||d===1)&&W>wT&&Q===!1){let ot=$,st=D;e&&(ot=Ae({inputs:{x:$},backend:o,attrs:{perm:[0,2,1]}}),R.push(ot)),n&&(st=Ae({inputs:{x:D},backend:o,attrs:{perm:[0,2,1]}}),R.push(st));let it=d!==1,ft=d===1,at=ot;it&&(at=ut({inputs:{x:ot},backend:o,attrs:{shape:[P,W,1]}}),R.push(at));let xt=d===1?2:1,dt=st;ft&&(dt=ut({inputs:{x:st},backend:o,attrs:{shape:[P,1,W]}}),R.push(dt));let bt=Sg({inputs:{a:at,b:dt},backend:o});rt=ep({inputs:{x:bt},backend:o,attrs:{axis:xt,keepDims:!0}}),R.push(bt)}else{let ot=ar(r.dtype,t.dtype),st=new bd(k,E,[P,f,d],e,n,U,j,q,K),it=[$,D];if(s!=null&&it.push(s),q&&it.push(i),K){let ft=o.makeTensorInfo([],"float32",x.createScalarValue(a,"float32"));it.push(ft),R.push(ft)}rt=o.runWebGLProgram(st,it,ot)}let X=ut({inputs:{x:rt},backend:o,attrs:{shape:v}});R.push(rt);for(let ot of R)o.disposeIntermediateTensorInfo(ot);return X}function Rtt(r){let{inputs:t,backend:e,attrs:n}=r,{a:o,b:s,bias:i,preluActivationWeights:a}=t,{transposeA:u,transposeB:l,activation:c,leakyreluAlpha:p}=n;return rp({a:o,b:s,transposeA:u,transposeB:l,backend:e,bias:i,preluActivationWeights:a,leakyreluAlpha:p,activation:c})}var iL={kernelName:Fi,backendName:"webgl",kernelFunc:Rtt};var aL="return abs(x);";function Ftt(r){let{inputs:t,backend:e}=r,{x:n}=t;if(e.shouldExecuteOnCPU([n])&&n.dtype!=="complex64"){let s=e.texData.get(n.dataId),i=Iw(s.values);return e.makeTensorInfo(n.shape,n.dtype,i)}let o;return V().getBool("WEBGL_PACK_UNARY_OPERATIONS")?o=new eo(n.shape,aL):o=new en(n.shape,aL),e.runWebGLProgram(o,[n],n.dtype)}var lL={kernelName:bi,backendName:"webgl",kernelFunc:Ftt};var Ott=hr+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,Mtt=Ct({opSnippet:Ott}),uL={kernelName:ta,backendName:"webgl",kernelFunc:Mtt};var Ptt=hr+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,Ltt=Ct({opSnippet:Ptt}),cL={kernelName:ea,backendName:"webgl",kernelFunc:Ltt};var pL="return a + b;",ztt=le({opSnippet:pL,packedOpSnippet:pL,supportsComplex:!0,cpuKernelImpl:qM}),mL={kernelName:Xn,backendName:"webgl",kernelFunc:ztt};var Rw=class{constructor(t,e){this.outputShape=[],this.outputShape=t,this.variableNames=e.map((s,i)=>`T${i}`);let n=[];this.variableNames.forEach(s=>{n.push(`float v${s} = get${s}AtOutCoords();`)});let o=this.variableNames.map(s=>`v${s}`).join(" + ");this.userCode=`
      void main() {
        ${n.join(`
        `)}

        float result = ${o};
        setOutput(result);
      }
    `}};var Fw=class{constructor(t,e){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.variableNames=e.map((s,i)=>`T${i}`);let n=[];this.variableNames.forEach(s=>{n.push(`vec4 v${s} = get${s}AtOutCoords();`)});let o=this.variableNames.map(s=>`v${s}`).join(" + ");this.userCode=`
      void main() {
        ${n.join(`
        `)}

        vec4 result = ${o};
        setOutput(result);
      }
    `}};function Ow(r){let{inputs:t,backend:e}=r,n=t;if(n.length===1)return Ke({inputs:{x:n[0]},backend:e});if(n.length>V().get("WEBGL_MAX_TEXTURES_IN_SHADER")){let u=Math.floor(n.length/2),l=Ow({inputs:n.slice(0,u),backend:e}),c=Ow({inputs:n.slice(u),backend:e});return Ow({inputs:[l,c],backend:e})}let o=n.map(u=>u.dtype).reduce((u,l)=>ar(u,l)),s=n.map(u=>u.shape),a=V().getBool("WEBGL_PACK")?new Fw(n[0].shape,s):new Rw(n[0].shape,s);return e.runWebGLProgram(a,n,o)}var fL={kernelName:Zo,backendName:"webgl",kernelFunc:Ow};function Btt(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,keepDims:i}=n,a=o.shape.length,u=x.parseAxisParam(s,o.shape),l=u,c=S.getAxesPermutation(l,a),p=o;c!=null&&(p=Ae({inputs:{x:o},backend:e,attrs:{perm:c}}),l=S.getInnerMostAxes(l.length,a)),S.assertAxesAreInnerMostDims("all",l,a);let[m,f]=S.computeOutAndReduceShapes(p.shape,l),d=x.sizeFromShape(f),h=ut({inputs:{x:p},backend:e,attrs:{shape:[-1,d]}}),g=Hn(h,h.dtype,"all",e),y;if(i){let b=S.expandShapeToKeepDim(m,u);y=ut({inputs:{x:g},backend:e,attrs:{shape:b}})}else y=ut({inputs:{x:g},backend:e,attrs:{shape:m}});return e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(g),c!=null&&e.disposeIntermediateTensorInfo(p),y}var dL={kernelName:ra,backendName:"webgl",kernelFunc:Btt};function Vtt(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,keepDims:i}=n,a=o.shape.length,u=x.parseAxisParam(s,o.shape),l=u,c=S.getAxesPermutation(l,a),p=o;c!=null&&(p=Ae({inputs:{x:o},backend:e,attrs:{perm:c}}),l=S.getInnerMostAxes(l.length,a)),S.assertAxesAreInnerMostDims("any",l,a);let[m,f]=S.computeOutAndReduceShapes(p.shape,l),d=x.sizeFromShape(f),h=ut({inputs:{x:p},backend:e,attrs:{shape:[-1,d]}}),g=Hn(h,h.dtype,"any",e),y;if(i){let b=S.expandShapeToKeepDim(m,u);y=ut({inputs:{x:g},backend:e,attrs:{shape:b}})}else y=ut({inputs:{x:g},backend:e,attrs:{shape:m}});return e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(g),c!=null&&e.disposeIntermediateTensorInfo(p),y}var hL={kernelName:na,backendName:"webgl",kernelFunc:Vtt};var Mw=class{constructor(t,e,n){this.variableNames=["A"];let{windowSize:o,batchSize:s,outSize:i}=t;n||this.variableNames.push("bestIndicesA"),this.outputShape=[s,i];let a=e==="max"?">":"<",u=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${o};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${o}; i++) {
          int inIdx = ${u};
          float candidate = getA(batch, inIdx);
          if (candidate ${a} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}};var Pw=class{constructor(t,e,n,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,x.assert(t.length>2,()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`);let s=t[t.length-1],i=Math.ceil(s/e);this.outputShape=t.slice(0,-1),i>1&&this.outputShape.push(i),o||this.variableNames.push("bestIndicesA");let a=this.outputShape,u=a.length,l=Vt(u),c=nr("coords",u),p,m;if(i===1){m=u+1;let D=Vt(m);p=`
        ${D} sourceLocR = ${D}(${c.join()}, 0);
        ++${c[u-1]};
        ${D} sourceLocG = ${D}(${c.join()}, 0);
        ++${c[u-2]};
        ${D} sourceLocA = ${D}(${c.join()}, 0);
        --${c[u-1]};
        ${D} sourceLocB = ${D}(${c.join()}, 0);
        --${c[u-2]};`}else m=u,p=`
        ${l} sourceLocR = coords;
        ++${c[u-1]};
        ${l} sourceLocG = coords;
        ++${c[u-2]};
        ${l} sourceLocA = coords;
        --${c[u-1]};
        ${l} sourceLocB = coords;
        --${c[u-2]};`;let f=["x","y","z","w","u","v"].slice(0,m),d="."+f[m-1],h=f.map(D=>"int "+D),g=nr("sourceLocR",m-1).concat("inIdx.r"),y=nr("sourceLocG",m-1).concat("inIdx.g"),b=nr("sourceLocB",m-1).concat("inIdx.b"),w=nr("sourceLocA",m-1).concat("inIdx.a"),v=n==="max"?"greaterThan":"lessThan",k=o?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${g.join()}),
                             getBestIndicesAChannel(${y.join()}),
                             getBestIndicesAChannel(${b.join()}),
                             getBestIndicesAChannel(${w.join()})));`,E=`vec4(
            getAChannel(${g.join()}),
            hasNextCol ? getAChannel(${y.join()}) : 0.,
            hasNextRow ? getAChannel(${b.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${w.join()}) : 0.)`,$=o?"":`
      float getBestIndicesAChannel(${h.join()}) {
        return getChannel(getBestIndicesA(${f.join()}),
                                          vec2(${f.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${h.join()}) {
        return getChannel(getA(${f.join()}),
                               vec2(${f.slice(-2).join()}));
      }
      ${$}
      void main() {
        ${l} coords = getOutputCoords();
        bool hasNextCol = ${c[u-1]} < ${a[u-1]-1};
        bool hasNextRow = ${c[u-2]} < ${a[u-2]-1};
        ${p}
        ivec4 srcIdx = ivec4(sourceLocR${d}, sourceLocG${d},
          sourceLocB${d}, sourceLocA${d}) * ${e};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${E};

        for (int i = 0; i < ${e}; i++) {
          inIdx = srcIdx;
          ${k}
          vec4 candidate = ${E};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${v}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}};function gL(r,t,e,n=null){let o=t.shape[0],s=t.shape[1];n!=null&&(o=n.shape[0],s=n.shape[1]);let i=S.computeOptimalWindowSize(s),a={windowSize:i,inSize:s,batchSize:o,outSize:Math.ceil(s/i)},u=new Mw(a,e,n==null),l=[t];n!=null&&l.push(n);let c=r.runWebGLProgram(u,l,"int32");if(c.shape[1]===1)return c;let p=gL(r,t,e,c);return r.disposeIntermediateTensorInfo(c),p}function xL(r,t,e,n=null){let o=n!=null?n.shape:t.shape,s=o[o.length-1],i=S.computeOptimalWindowSize(s),a=new Pw(o,i,e,n==null),u=n==null?[t]:[t,n],l=r.runWebGLProgram(a,u,"int32");if(l.shape.length===t.shape.length){let c=xL(r,t,e,l);return r.disposeIntermediateTensorInfo(l),c}return l}function Lw(r,t,e,n){let o=[e];if(S.assertAxesAreInnerMostDims("arg"+n.charAt(0).toUpperCase()+n.slice(1),o,t.shape.length),!V().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){let s=[],i=r.texData.get(t.dataId),a=i!==null&&i.isPacked,u=t;a&&(u=r.unpackTensor(t),s.push(u));let[l,c]=S.computeOutAndReduceShapes(u.shape,o),p=x.sizeFromShape(c),m=ut({inputs:{x:u},backend:r,attrs:{shape:[-1,p]}});s.push(m);let f=gL(r,m,n);s.push(f);let d=ut({inputs:{x:f},backend:r,attrs:{shape:l}});return s.forEach(h=>r.disposeIntermediateTensorInfo(h)),d}return xL(r,t,n)}function Gtt(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s}=n,i=x.parseAxisParam(s,o.shape),a=S.getAxesPermutation(i,o.shape.length),u=o,l=[];a!=null&&(u=Ae({inputs:{x:o},backend:e,attrs:{perm:a}}),l.push(u),i=S.getInnerMostAxes(i.length,u.shape.length)),S.assertAxesAreInnerMostDims("argMax",[i[0]],u.shape.length);let c=Lw(e,u,i[0],"max");return l.forEach(p=>e.disposeIntermediateTensorInfo(p)),c}var yL={kernelName:Jo,backendName:"webgl",kernelFunc:Gtt};function Wtt(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s}=n,i=x.parseAxisParam(s,o.shape),a=S.getAxesPermutation(i,o.shape.length),u=o,l=[];a!=null&&(u=Ae({inputs:{x:o},backend:e,attrs:{perm:a}}),l.push(u),i=S.getInnerMostAxes(i.length,u.shape.length)),S.assertAxesAreInnerMostDims("argMin",[i[0]],u.shape.length);let c=Lw(e,u,i[0],"min");return l.forEach(p=>e.disposeIntermediateTensorInfo(p)),c}var bL={kernelName:Al,backendName:"webgl",kernelFunc:Wtt};var Utt=hr+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,Htt=Ct({opSnippet:Utt}),wL={kernelName:oa,backendName:"webgl",kernelFunc:Htt};var qtt=hr+"return log(x + sqrt(x * x + 1.0));",Ktt=Ct({opSnippet:qtt}),vL={kernelName:sa,backendName:"webgl",kernelFunc:Ktt};var jtt=hr+`
  return atan(x);
`,Xtt=Ct({opSnippet:jtt}),CL={kernelName:ia,backendName:"webgl",kernelFunc:Xtt};var Ytt=ZP+`
  return atan(a, b);
`,Ztt=`
  vec4 result = atan(a, b);
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  `+JP+`
  return result;
`,Jtt=le({opSnippet:Ytt,packedOpSnippet:Ztt}),IL={kernelName:la,backendName:"webgl",kernelFunc:Jtt};var Qtt=hr+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,tet=Ct({opSnippet:Qtt}),SL={kernelName:aa,backendName:"webgl",kernelFunc:tet};var hi=class{constructor(t,e,n,o=!1,s=!1){if(this.variableNames=["x"],e==="avg"&&n)throw new Error("Cannot compute positions for average pool.");let i=t.filterWidth,a=t.strideHeight,u=t.strideWidth,l=t.dilationHeight,c=t.dilationWidth,p=t.effectiveFilterHeight,m=t.effectiveFilterWidth,f=t.padInfo.top,d=t.padInfo.left;this.outputShape=t.outShape;let h=e==="avg",g=`((batch  * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + d`,y=`(xR * ${t.inWidth} + xC) * ${t.inChannels} + d`,b="0.0";if(h||(b="-1.0 / 1e-20"),n){let D=">=";this.userCode=`
        const ivec2 strides = ivec2(${a}, ${u});
        const ivec2 pads = ivec2(${f}, ${d});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${p};
              wR += ${l}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${m};
                wC += ${c}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${D} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${o?s?g:y:`wR * ${m} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let w="max",v=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;e==="avg"&&(v="avgValue / count");let k=Math.floor(i/4)*4,E=i%4,$=`
      if (${h}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${w}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${a}, ${u});
      const ivec2 pads = ivec2(${f}, ${d});
      const float initializationValue = ${b};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${t.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${b});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${p};
            wR += ${l}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${t.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${k}; wC += 4) {
            int xC = xCCorner + wC * ${c};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              getValue(batch, xR, xC + 2 * ${c}, d),
              getValue(batch, xR, xC + 3 * ${c}, d)
            );

            ${$}
          }

          int xC = xCCorner + ${k};
          if (${E===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${$}
          } else if (${E===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              initializationValue,
              initializationValue
            );

            ${$}
          } else if (${E===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              getValue(batch, xR, xC + 2 * ${c}, d),
              initializationValue
            );

            ${$}
          }
        }
        setOutput(${v});
      }
    `}},Iu=class{constructor(t,e,n,o=!1,s=!1){if(this.variableNames=["x"],e==="avg"&&n)throw new Error("Cannot compute positions for average pool.");let i=t.filterWidth,a=t.strideDepth,u=t.strideHeight,l=t.strideWidth,c=t.dilationDepth,p=t.dilationHeight,m=t.dilationWidth,f=t.effectiveFilterDepth,d=t.effectiveFilterHeight,h=t.effectiveFilterWidth,g=t.padInfo.front,y=t.padInfo.top,b=t.padInfo.left;this.outputShape=t.outShape;let w=e==="avg",v="0.0";if(w||(v="-1.0 / 1e-20"),n){let P=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${a}, ${u}, ${l});
        const ivec3 pads = ivec3(${g}, ${y}, ${b});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${f};
              wD += ${c}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${t.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${d};
                wR += ${p}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${t.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${h};
                  wC += ${m}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${t.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${P} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${o?s?`(((batch * ${t.inDepth} + xD) * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`((xD * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`wD * ${d} * ${h} +
                      wR * ${h} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let k="max",E=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;e==="avg"&&(E="avgValue / count");let $=Math.floor(i/4)*4,D=i%4,R=`
      if (${w}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${k}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${a}, ${u}, ${l});
      const ivec3 pads = ivec3(${g}, ${y}, ${b});
      const float initializationValue = ${v};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${t.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${v});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${f};
            wD += ${c}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${t.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${d};
            wR += ${p}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${$}; wC += 4) {
              int xC = xCCorner + wC * ${m};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${m}, ch),
                getValue(batch, xD, xR, xC + 2 * ${m}, ch),
                getValue(batch, xD, xR, xC + 3 * ${m}, ch)
              );

              ${R}
            }

            int xC = xCCorner + ${$};
            if (${D===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${R}
            } else if (${D===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${m}, ch),
                initializationValue,
                initializationValue
              );

              ${R}
            } else if (${D===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${m}, ch),
                getValue(batch, xD, xR, xC + 2 * ${m}, ch),
                initializationValue
              );

              ${R}
            }
          }
          setOutput(${E});
        }
      }
    `}};function eet(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t;fi(o,"avgPool");let{filterSize:s,strides:i,pad:a,dimRoundingMode:u}=n,l=1;x.assert(S.eitherStridesOrDilationsAreOne(i,l),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${l}'`);let c=S.computePool2DInfo(o.shape,s,i,l,a,u);if(c.filterWidth===1&&c.filterHeight===1&&x.arraysEqual(c.inShape,c.outShape))return Ke({inputs:{x:o},backend:e});let p=new hi(c,"avg",!1);return e.runWebGLProgram(p,[o],"float32")}var kL={kernelName:Qo,backendName:"webgl",kernelFunc:eet};function ret(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{filterSize:s,strides:i,pad:a,dimRoundingMode:u,dataFormat:l}=n,c=[1,1,1],p=S.computePool3DInfo(o.shape,s,i,c,a,u,l),m=new Iu(p,"avg",!1);return e.runWebGLProgram(m,[o],"float32")}var NL={kernelName:$l,backendName:"webgl",kernelFunc:ret};var zw=class{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;let e=t.filterHeight,n=t.filterWidth,o=t.strideHeight,s=t.strideWidth,i=t.dilationHeight,a=t.dilationWidth,u=t.effectiveFilterHeight,l=t.effectiveFilterWidth,c=u-1-t.padInfo.top,p=l-1-t.padInfo.left,m=1/(e*n);this.userCode=`
      const ivec2 pads = ivec2(${c}, ${p});
      const float avgMultiplier = float(${m});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${u};
            wR += ${i}) {
          float dyR = float(dyRCorner + wR) / ${o}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${l};
            wC+= ${a}) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}},Bw=class{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;let e=t.filterDepth,n=t.filterHeight,o=t.filterWidth,s=t.strideDepth,i=t.strideHeight,a=t.strideWidth,u=t.dilationDepth,l=t.dilationHeight,c=t.dilationWidth,p=t.effectiveFilterDepth,m=t.effectiveFilterHeight,f=t.effectiveFilterWidth,d=p-1-t.padInfo.front,h=m-1-t.padInfo.top,g=f-1-t.padInfo.left,y=1/(e*n*o);this.userCode=`
      const ivec3 pads = ivec3(${d}, ${h}, ${g});
      const float avgMultiplier = float(${y});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${p};
            wD += ${u}) {
          float dyD = float(dyDCorner + wD) / ${s}.0;

          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${m};
              wR += ${l}) {
            float dyR = float(dyRCorner + wR) / ${i}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${f};
                wC += ${c}) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function net(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,input:s}=t,i=s,{filterSize:a,strides:u,pad:l,dimRoundingMode:c}=n,p=[1,1,1],m=S.computePool3DInfo(i.shape,a,u,p,l,c),f=new Bw(m);return e.runWebGLProgram(f,[o],i.dtype)}var TL={kernelName:Tp,backendName:"webgl",kernelFunc:net};function oet(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,input:s}=t,i=s;fi([o,s],"avgPoolGrad");let{filterSize:a,strides:u,pad:l}=n,c=S.computePool2DInfo(i.shape,a,u,1,l),p=new zw(c);return e.runWebGLProgram(p,[o],i.dtype)}var _L={kernelName:Np,backendName:"webgl",kernelFunc:oet};function set(r){let{inputs:t,backend:e,attrs:n}=r,{a:o,b:s}=t,{transposeA:i,transposeB:a}=n;return rp({a:o,b:s,transposeA:i,transposeB:a,backend:e})}var EL={kernelName:ts,backendName:"webgl",kernelFunc:set};var Vw=class{constructor(t,e,n,o,s,i){this.outputShape=[],this.variableNames=["x","mean","variance"],S.assertAndGetBroadcastShape(t,e),S.assertAndGetBroadcastShape(t,n);let a="0.0";o!=null&&(S.assertAndGetBroadcastShape(t,o),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let u="1.0";s!=null&&(S.assertAndGetBroadcastShape(t,s),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${a};
        float scale = ${u};
        float inv = scale * inversesqrt(variance + float(${i}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}};var Gw=class{constructor(t,e,n,o,s,i){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],S.assertAndGetBroadcastShape(t,e),S.assertAndGetBroadcastShape(t,n);let a="vec4(0.0)";o!=null&&(S.assertAndGetBroadcastShape(t,o),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let u="vec4(1.0)";s!=null&&(S.assertAndGetBroadcastShape(t,s),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`
      void main() {
        vec4 offset = ${a};
        vec4 scale = ${u};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${i}));

        setOutput((x - mean) * inv + offset);
      }
    `}};var iet=({inputs:r,backend:t,attrs:e})=>{let{x:n,mean:o,variance:s,offset:i,scale:a}=r;x.assert(o.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),x.assert(i==null||o.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),x.assert(a==null||o.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:u}=e;u==null&&(u=.001);let l=[n,o,s],c=null;i!=null&&(c=i.shape,l.push(i));let p=null;a!=null&&(p=a.shape,l.push(a));let m=V().getBool("WEBGL_PACK_NORMALIZATION")?new Gw(n.shape,o.shape,s.shape,c,p,u):new Vw(n.shape,o.shape,s.shape,c,p,u);return t.runWebGLProgram(m,l,l[0].dtype)},AL={kernelName:fs,backendName:"webgl",kernelFunc:iet};var Ww=class{constructor(t){this.variableNames=["source"],this.outputShape=t,this.rank=t.length;let e=Vt(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let n=aet(this.rank),o,s=t.map((i,a)=>`sourceLoc.${vT[a]} = start[${a}] + coords.${vT[a]};`);o=`
        ${e} sourceLoc;
        ${e} coords = getOutputCoords();
        ${s.join(`
`)}
      `,this.userCode=`
      void main() {
        ${o}
        setOutput(getSource(${n}));
      }
    `}},vT=["x","y","z","w","u","v"];function aet(r){if(r===1)return"sourceLoc";if(r<=6)return vT.slice(0,r).map(t=>"sourceLoc."+t).join(",");throw Error(`Slicing for rank ${r} is not yet supported`)}var Uw=class{constructor(t){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let e=Vt(this.rank),n=nr("coords",this.rank),o=nr("sourceLoc",this.rank),s=this.rank===1?"sourceLoc":`vec2(${o.slice(-2).join()})`,i=`getChannel(getSource(${o.join()}), ${s})`,a=`
      result.x = ${i};
      if (++${n[this.rank-1]} < ${t[this.rank-1]}) {
        ++${o[this.rank-1]};
        result.y = ${i};
        --${o[this.rank-1]};
      }
    `,u=this.rank===1?"":`
      --${n[this.rank-1]};
      if (++${n[this.rank-2]} < ${t[this.rank-2]}) {
        ++${o[this.rank-2]};
        result.z = ${i};
        if (++${n[this.rank-1]} < ${t[this.rank-1]}) {
          ++${o[this.rank-1]};
          result.w = ${i};
        }
      }
    `,l=this.rank<=4?`sourceLoc = coords +
            ${e}(${t.map((c,p)=>`start[${p}]`).join()});`:t.map((c,p)=>`${o[p]} = ${n[p]} + start[${p}];`).join(`
`);this.userCode=`
      void main() {
        ${e} coords = getOutputCoords();
        ${e} sourceLoc;
        ${l}
        vec4 result = vec4(0.);
        ${a}
        ${u}
        setOutput(result);
      }
    `}};function uet(r,t,e,n){let o=n.texData.get(r.dataId),s=n.makeTensorInfo(e,r.dtype),i=n.texData.get(s.dataId);Object.assign(i,o),i.refCount=1,i.shape=e,i.dtype=r.dtype;let a=Ve.computeFlatOffset(t,x.computeStrides(r.shape));o.slice&&(a+=o.slice.flatOffset),i.slice={flatOffset:a,origDataId:o.slice&&o.slice.origDataId||r.dataId};let u=n.dataRefCount.get(i.slice.origDataId)||1;return n.dataRefCount.set(i.slice.origDataId,u+1),s}function gi(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{begin:s,size:i}=n,[a,u]=Ve.parseSliceParams(o,s,i);if(Ve.assertParamsValid(o,a,u),x.sizeFromShape(u)===0)return e.makeTensorInfo(u,o.dtype,[]);if(e.shouldExecuteOnCPU([o])||o.dtype==="string"){let p=e.texData.get(o.dataId),m=yP(p.values,a,u,o.shape,o.dtype);return e.makeTensorInfo(u,o.dtype,m)}let{isPacked:l}=e.texData.get(o.dataId),c=Ve.isSliceContinous(o.shape,a,u);if(l||!c){let p=V().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Uw(u):new Ww(u),m=[a];return e.runWebGLProgram(p,[o],o.dtype,m)}return e.uploadToGPU(o.dataId),uet(o,a,u,e)}var $L={kernelName:Ei,backendName:"webgl",kernelFunc:gi};var cet=r=>{let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{blockShape:s,crops:i}=n;x.assert(o.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");let a=s.reduce((b,w)=>b*w),u=S.getReshaped(o.shape,s,a),l=S.getPermuted(u.length,s.length),c=S.getReshapedPermuted(o.shape,s,a),p=S.getSliceBeginCoords(i,s.length),m=S.getSliceSize(c,i,s.length),f=[],d=ut({inputs:{x:o},backend:e,attrs:{shape:u}}),h=Ae({inputs:{x:d},backend:e,attrs:{perm:l}}),g=ut({inputs:{x:h},backend:e,attrs:{shape:c}}),y=gi({inputs:{x:g},backend:e,attrs:{begin:p,size:m}});return f.push(d),f.push(h),f.push(g),f.forEach(b=>e.disposeIntermediateTensorInfo(b)),y},DL={kernelName:wi,backendName:"webgl",kernelFunc:cet};function pet(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,weights:s}=t,{size:i}=n,a=e.readSync(o.dataId),u=e.readSync(s.dataId),l=Cw(a,u,s.dtype,s.shape,i);return e.makeTensorInfo([i],s.dtype,l)}var RL={kernelName:_p,backendName:"webgl",kernelFunc:pet};function met(r){let{inputs:t,backend:e}=r,{s0:n,s1:o}=t,s=e.readSync(n.dataId),i=e.readSync(o.dataId),a=S.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return e.makeTensorInfo([a.length],"int32",Int32Array.from(a))}var FL={kernelName:Ep,backendName:"webgl",kernelFunc:met};var fet="return float(a != b);",CT=le({opSnippet:fet,cpuKernelImpl:fP,dtype:"bool"}),OL={kernelName:Na,backendName:"webgl",kernelFunc:CT};function Il(r){let{inputs:t,backend:e}=r,{input:n}=t,o=e.texData.get(n.dataId);return Ke({inputs:{x:o.complexTensorInfos.real},backend:e})}var ML={kernelName:Xp,backendName:"webgl",kernelFunc:Il};var det="return float(int(x));";function PL(r,t){let e=new en(r.shape,det),n=t.runWebGLProgram(e,[r],"int32");return{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}function IT(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{dtype:s}=n;if(s==="complex64"){if(o.dtype==="complex64")return Ke({inputs:{x:o},backend:e});let i=ye(o.shape),a=IT({inputs:{x:o},backend:e,attrs:{dtype:"float32"}}),u=Rn({inputs:{real:a,imag:i},backend:e});return i.dispose(),e.disposeIntermediateTensorInfo(a),u}if(o.dtype==="complex64"){let i=Il({inputs:{input:o},backend:e}),a=IT({inputs:{x:i},backend:e,attrs:{dtype:s}});return e.disposeIntermediateTensorInfo(i),a}if(!x.hasEncodingLoss(o.dtype,s)){let i=Ke({inputs:{x:o},backend:e});return{dataId:i.dataId,shape:i.shape,dtype:s}}if(s==="int32")return PL(o,e);if(s==="bool"){let i=e.makeTensorInfo([],"bool",x.getTypedArrayFromDType("bool",1)),u=CT({inputs:{a:o,b:i},backend:e});return e.disposeIntermediateTensorInfo(i),u}throw new Error(`Error in Cast: failed to cast ${o.dtype} to ${s}`)}var LL={kernelName:io,backendName:"webgl",kernelFunc:IT};var zL="return ceil(x);",het=Ct({opSnippet:zL,packedOpSnippet:zL,cpuKernelImpl:jM}),BL={kernelName:es,backendName:"webgl",kernelFunc:het};var Hw=class{constructor(t){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}};var qw=class{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}};function get(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{clipValueMin:s,clipValueMax:i}=n,a;V().getBool("WEBGL_PACK_CLIP")?a=new qw(o.shape):a=new Hw(o.shape);let u=[[s],[i]];return e.runWebGLProgram(a,[o],o.dtype,u)}var VL={kernelName:ao,backendName:"webgl",kernelFunc:get};var Kw=class{constructor(t){this.variableNames=["real","imag"],this.outputShape=t,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}};function GL(r,t){return{dataId:t.dataId,dtype:t.dtype,shape:r.shape}}function xet(r){let{inputs:t,backend:e}=r,{x:n}=t,o=e.texData.get(n.dataId),s=new Kw(n.shape),i=[GL(n,o.complexTensorInfos.real),GL(n,o.complexTensorInfos.imag)];return e.runWebGLProgram(s,i,i[0].dtype)}var WL={kernelName:Dl,backendName:"webgl",kernelFunc:xet};var jw=class{constructor(t){this.outputShape=[],this.outputShape=S.computeOutShape(t,1),this.variableNames=t.map((i,a)=>`T${a}`);let e=new Array(t.length-1);e[0]=t[0][1];for(let i=1;i<e.length;i++)e[i]=e[i-1]+t[i][1];let n=[`if (yC < ${e[0]}) setOutput(getT0(yR, yC));`];for(let i=1;i<e.length;i++){let a=e[i-1];n.push(`else if (yC < ${e[i]}) setOutput(getT${i}(yR, yC-${a}));`)}let o=e.length,s=e[e.length-1];n.push(`else setOutput(getT${o}(yR, yC-${s}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${n.join(`
        `)}
      }
    `}};var Yw=class{constructor(t,e){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=S.computeOutShape(t,e);let n=this.outputShape,o=n.length,s=Vt(o),i=nr("coords",o),a=["x","y","z","w","u","v"].slice(0,o);this.variableNames=t.map((h,g)=>`T${g}`);let u=new Array(t.length-1);u[0]=t[0][e];for(let h=1;h<u.length;h++)u[h]=u[h-1]+t[h][e];let l=a[e],c=a.slice(-2),p=a.join(),m=`if (${l} < ${u[0]}) {
        return getChannel(
            getT0(${p}), vec2(${c.join()}));
        }`;for(let h=1;h<u.length;h++){let g=u[h-1];m+=`
        if (${l} < ${u[h]}  && ${l} >= ${u[h-1]}) {
          return getChannel(
            getT${h}(${Xw(a,l,g)}),
            vec2(${Xw(c,l,g)}));
        }`}let f=u.length,d=u[u.length-1];m+=`
        return getChannel(
          getT${f}(${Xw(a,l,d)}),
          vec2(${Xw(c,l,d)}));`,this.userCode=`
      float getValue(${a.map(h=>"int "+h)}) {
        ${m}
      }

      void main() {
        ${s} coords = getOutputCoords();
        vec4 result = vec4(getValue(${i}), 0., 0., 0.);

        ${i[o-1]} = ${i[o-1]} + 1;
        if (${i[o-1]} < ${n[o-1]}) {
          result.g = getValue(${i});
        }

        ${i[o-2]} = ${i[o-2]} + 1;
        if (${i[o-2]} < ${n[o-2]}) {
          result.a = getValue(${i});
        }

        ${i[o-1]} = ${i[o-1]} - 1;
        if (${i[o-2]} < ${n[o-2]} &&
            ${i[o-1]} < ${n[o-1]}) {
          result.b = getValue(${i});
        }
        setOutput(result);
      }
    `}};function Xw(r,t,e){let n=r.indexOf(t);return r.map((s,i)=>i===n?`${s} - ${e}`:s).join()}function np(r){let{inputs:t,backend:e}=r,{input:n}=t,o=e.texData.get(n.dataId);return Ke({inputs:{x:o.complexTensorInfos.imag},backend:e})}var UL={kernelName:Gp,backendName:"webgl",kernelFunc:np};function op(r,t,e){let n=r[0].dtype;if(n==="complex64"){let c=r.map(h=>Il({inputs:{input:h},backend:e})),p=r.map(h=>np({inputs:{input:h},backend:e})),m=op(c,t,e),f=op(p,t,e),d=Rn({inputs:{real:m,imag:f},backend:e});return c.forEach(h=>e.disposeIntermediateTensorInfo(h)),p.forEach(h=>e.disposeIntermediateTensorInfo(h)),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(f),d}let o=e.shouldExecuteOnCPU(r);if(n==="string"&&(o=!0),o){let c=r.map(y=>{let b=x.sizeFromShape(y.shape.slice(t));return ut({inputs:{x:y},backend:e,attrs:{shape:[-1,b]}})}),p=c.map(y=>({vals:e.readSync(y.dataId),shape:y.shape})),m=S.computeOutShape(c.map(y=>y.shape),1),f=c[0].shape[0]===1,d=XM(p,m,n,f),h=S.computeOutShape(r.map(y=>y.shape),t),g=e.makeTensorInfo(h,n,d);return c.forEach(y=>e.disposeIntermediateTensorInfo(y)),g}if(r.length>V().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){let c=Math.floor(r.length/2),p=op(r.slice(0,c),t,e),m=op(r.slice(c),t,e),f=op([p,m],t,e);return e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(m),f}if(V().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&r[0].shape.length>1){let c=new Yw(r.map(p=>p.shape),t);return e.runWebGLProgram(c,r,n)}let{tensors2D:s,outShape:i}=yet(r,t,e),a=new jw(s.map(c=>c.shape)),u=e.runWebGLProgram(a,s,n);s.forEach(c=>e.disposeIntermediateTensorInfo(c));let l=ut({inputs:{x:u},attrs:{shape:i},backend:e});return e.disposeIntermediateTensorInfo(u),l}function yet(r,t,e){let n=S.computeOutShape(r.map(s=>s.shape),t);return{tensors2D:r.map(s=>ut({inputs:{x:s},attrs:{shape:[-1,x.sizeFromShape(s.shape.slice(t))]},backend:e})),outShape:n}}function ST(r){let{inputs:t,backend:e,attrs:n}=r,{axis:o}=n,s=x.parseAxisParam(o,t[0].shape)[0],i=S.computeOutShape(t.map(l=>l.shape),s);if(x.sizeFromShape(i)===0)return e.makeTensorInfo(i,t[0].dtype,[]);let a=t.filter(l=>x.sizeFromShape(l.shape)>0);if(a.length===1)return Ke({inputs:{x:a[0]},backend:e});let u=a.map(l=>l.shape);return S.assertParamsConsistent(u,s),op(a,s,e)}var HL={kernelName:vi,backendName:"webgl",kernelFunc:ST};var wd=class{constructor(t,e=!1,n=null,o=!1,s=!1){this.variableNames=["x","W"],this.outputShape=t.outShape;let i=t.padInfo.top,a=t.padInfo.left,u=t.strideHeight,l=t.strideWidth,c=t.dilationHeight,p=t.dilationWidth,m=t.filterHeight,f=t.filterWidth,d=Math.floor(t.inChannels/4)*4,h=t.inChannels%4,g=t.dataFormat==="channelsLast",y=g?1:2,b=g?2:3,w=g?3:1,v="",k="";n&&(o?v=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:s?v=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:v=`
          float activation(float x) {
            ${n}
          }
        `,k="result = activation(result);");let E=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${v}

      const ivec2 strides = ivec2(${u}, ${l});
      const ivec2 pads = ivec2(${i}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${w}];

        ivec2 xRCCorner =
            ivec2(coords[${y}], coords[${b}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${m}; wR++) {
          int xR = xRCorner + wR * ${c};

          if (xR < 0 || xR >= ${t.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${f}; wC++) {
            int xC = xCCorner + wC * ${p};

            if (xC < 0 || xC >= ${t.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${d}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${g}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${h===1}) {

              if (${g}) {
                dotProd +=
                    getX(batch, xR, xC, ${d}) *
                    getW(wR, wC, ${d}, d2);
              } else {
                dotProd +=
                    getX(batch, ${d}, xR, xC) *
                    getW(wR, wC, ${d}, d2);
              }

            } else if (${h===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${d}, d2),
                getW(wR, wC, ${d} + 1, d2)
              );

              if (${g}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${d}),
                  getX(batch, xR, xC, ${d} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${d}, xR, xC),
                  getX(batch, ${d} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${h===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${d}, d2),
                getW(wR, wC, ${d} + 1, d2),
                getW(wR, wC, ${d} + 2, d2)
              );

              if (${g}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${d}),
                  getX(batch, xR, xC, ${d} + 1),
                  getX(batch, xR, xC, ${d} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${d}, xR, xC),
                  getX(batch, ${d} + 1, xR, xC),
                  getX(batch, ${d} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${E}
        ${k}
        setOutput(result);
      }
    `}},Zw=class{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;let e=t.padInfo.front,n=t.padInfo.top,o=t.padInfo.left,s=t.strideDepth,i=t.strideHeight,a=t.strideWidth,u=t.dilationDepth,l=t.dilationHeight,c=t.dilationWidth,p=t.filterDepth,m=t.filterHeight,f=t.filterWidth,d=Math.floor(t.inChannels/4)*4,h=t.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${s}, ${i}, ${a});
      const ivec3 pads = ivec3(${e}, ${n}, ${o});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${p}; wF++) {
          int xF = xFCorner + wF * ${u};

          if (xF < 0 || xF >= ${t.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${m}; wR++) {
            int xR = xRCorner + wR * ${l};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${f}; wC++) {
              int xC = xCCorner + wC * ${c};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${d}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${h===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${d}) *
                  getW(wF, wR, wC, ${d}, d2);
              } else if (${h===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${d}),
                  getX(batch, xF, xR, xC, ${d} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${d}, d2),
                  getW(wF, wR, wC, ${d} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${h===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${d}),
                  getX(batch, xF, xR, xC, ${d} + 1),
                  getX(batch, xF, xR, xC, ${d} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${d}, d2),
                  getW(wF, wR, wC, ${d} + 1, d2),
                  getW(wF, wR, wC, ${d} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}};var Jw=class{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=t,this.enableShapeUniforms=De(this.outputShape.length);let{dataFormat:n}=e,o=qe(),s=n==="channelsLast",i=s?0:1,a=s?1:2,u=this.enableShapeUniforms?"if(blockIndex < outShape[1] && pos < outShape[0]) {":`if(blockIndex < ${t[1]} && pos < ${t[0]}) {`,l="";for(let c=0;c<=1;c++)for(let p=0;p<=1;p++)l+=`
          blockIndex = rc.y + ${p};
          pos = rc.x + ${c};

          ${u}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${i}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${a}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${s}) {
                  innerDims = vec2(d1, ch);
                  result[${c*2+p}] = getChannel(
                    getA(d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${c*2+p}] = getChannel(
                    getA(ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec2 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${l}

        ${o.output} = result;
      }
    `}};function Qw({x:r,filter:t,convInfo:e,backend:n,bias:o=null,preluActivationWeights:s=null,leakyreluAlpha:i=0,activation:a=null}){let u=r.shape,l=n.texData.get(r.dataId),c=e.inChannels,p=u[0]*u[1]*u[2],m=e.outChannels,f=e.dataFormat==="channelsLast",d=!1,h=!1,g,y=[];if(!((p===1||m===1)&&c>wT)&&l.isPacked&&f&&l.texture!=null&&u[2]%2!==0&&x.arraysEqual(l.shape.slice(-3),u.slice(-3))){let v=u[0]*u[1]*(u[2]+1),k={dataId:r.dataId,shape:[1,v,e.inChannels],dtype:r.dtype},E=l.shape;l.shape=l.shape.slice(),l.shape[l.shape.length-2]++,x.assert(yu(l.shape,k.shape),()=>`packed reshape ${l.shape} to ${k.shape} isn't free`);let $=ut({inputs:{x:t},backend:n,attrs:{shape:[1,e.inChannels,e.outChannels]}});y.push($);let D=rp({a:k,b:$,backend:n,transposeA:d,transposeB:h,bias:o,activation:a,preluActivationWeights:s,leakyreluAlpha:i}),R=n.texData.get(D.dataId);x.assert(R.isPacked,()=>"batchMatMul result is expected to be packed"),l.shape=E,R.shape=e.outShape,g=Ke({inputs:{x:D},backend:n}),g.shape=e.outShape,y.push(D)}else{let v=f?u[0]*u[1]*u[2]:u[0]*u[2]*u[3],k=ut({inputs:{x:r},backend:n,attrs:{shape:[1,v,e.inChannels]}}),E=ut({inputs:{x:t},backend:n,attrs:{shape:[1,e.inChannels,e.outChannels]}}),$=rp({a:k,b:E,transposeA:d,transposeB:h,backend:n,bias:o,activation:a,preluActivationWeights:s,leakyreluAlpha:i});g=ut({inputs:{x:$},backend:n,attrs:{shape:e.outShape}}),y.push(k),y.push(E),y.push($)}for(let v of y)n.disposeIntermediateTensorInfo(v);return g}function tv({x:r,filter:t,convInfo:e,backend:n,bias:o=null,preluActivationWeights:s=null,leakyreluAlpha:i=0,activation:a=null}){let{filterWidth:u,filterHeight:l,inChannels:c,outWidth:p,outHeight:m,dataFormat:f}=e,d=f==="channelsLast",h=u*l*c,g=m*p,y=[h,g],b=!0,w=!1,v=[],k=ut({inputs:{x:r},backend:n,attrs:{shape:r.shape.slice(1)}}),E=ut({inputs:{x:t},backend:n,attrs:{shape:[1,h,x.sizeFromShape(t.shape)/h]}});v.push(k),v.push(E);let $=new Jw(y,e),D=[k.shape,[e.padInfo.top,e.padInfo.left],[e.strideHeight,e.strideWidth],[e.dilationHeight,e.dilationWidth],[e.inChannels],[e.filterWidth*e.inChannels],[e.outWidth]],R=n.runWebGLProgram($,[k],"float32",D),P=ut({inputs:{x:R},backend:n,attrs:{shape:[1,y[0],y[1]]}});v.push(R),v.push(P);let W=o!=null,U=s!=null,q=a==="leakyrelu",K=a?vu(a,!0):null,j=new bd(P.shape,E.shape,[1,g,e.outChannels],b,w,W,K,U,q),Q=[P,E];if(o&&Q.push(o),U&&Q.push(s),q){let st=n.makeTensorInfo([],"float32",x.createScalarValue(i,"float32"));Q.push(st),v.push(st)}let rt=n.runWebGLProgram(j,Q,"float32"),X=d?[1,m,p,e.outChannels]:[1,e.outChannels,m,p],ot=ut({inputs:{x:rt},backend:n,attrs:{shape:X}});v.push(rt);for(let st of v)n.disposeIntermediateTensorInfo(st);return ot}function bet(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,filter:s}=t,{strides:i,pad:a,dataFormat:u,dilations:l,dimRoundingMode:c}=n,p=S.convertConv2DDataFormat(u),m=S.computeConv2DInfo(o.shape,s.shape,i,l,a,c,!1,p),f;if(m.filterHeight===1&&m.filterWidth===1&&m.dilationHeight===1&&m.dilationWidth===1&&m.strideHeight===1&&m.strideWidth===1&&(m.padInfo.type==="SAME"||m.padInfo.type==="VALID"))f=Qw({x:o,filter:s,convInfo:m,backend:e});else if(V().getBool("WEBGL_CONV_IM2COL")&&o.shape[0]===1)f=tv({x:o,filter:s,convInfo:m,backend:e});else{let h=new wd(m);f=e.runWebGLProgram(h,[o,s],"float32")}let d=ut({inputs:{x:f},backend:e,attrs:{shape:m.outShape}});return e.disposeIntermediateTensorInfo(f),d}var qL={kernelName:rs,backendName:"webgl",kernelFunc:bet};var ev=class{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;let e=t.strideHeight,n=t.strideWidth,o=t.padInfo.top,s=t.padInfo.left,i=t.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yR = 0; yR < ${t.outHeight}; yR++) {
            int xR = wR + yR * ${e} - ${o};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${t.outWidth}; yC++) {
              int xC = wC + yC * ${n} - ${s};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              if (${i}) {
                float dyValue = getDy(b, yR, yC, d2);
                float xValue = getX(b, xR, xC, d1);
                dotProd += (xValue * dyValue);
              } else {
                float dyValue = getDy(b, d2, yR, yC);
                float xValue = getX(b, d1, xR, xC);
                dotProd += (xValue * dyValue);
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}},rv=class{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;let e=t.filterHeight,n=t.filterWidth,o=t.strideHeight,s=t.strideWidth,i=t.dataFormat==="channelsLast",a=e-1-t.padInfo.top,u=n-1-t.padInfo.left,l=i?1:2,c=i?2:3,p=i?3:1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${u});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${p}];

        ivec2 dyCorner = ivec2(coords[${l}], coords[${c}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${e}; wR++) {
          float dyR = float(dyRCorner + wR) / ${o}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${e} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${n} - 1 - wC;

            for (int d2 = 0; d2 < ${t.outChannels}; d2++) {

              if (${i}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}},nv=class{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;let e=t.strideDepth,n=t.strideHeight,o=t.strideWidth,s=t.padInfo.front,i=t.padInfo.top,a=t.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yF = 0; yF < ${t.outDepth}; yF++) {
            int xF = wF + yF * ${e} - ${s};

            if (xF < 0 || xF >= ${t.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${t.outHeight}; yR++) {
              int xR = wR + yR * ${n} - ${i};

              if (xR < 0 || xR >= ${t.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${t.outWidth}; yC++) {
                int xC = wC + yC * ${o} - ${a};

                if (xC < 0 || xC >= ${t.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}},ov=class{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;let e=t.filterDepth,n=t.filterHeight,o=t.filterWidth,s=t.strideDepth,i=t.strideHeight,a=t.strideWidth,u=e-1-t.padInfo.front,l=n-1-t.padInfo.top,c=o-1-t.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${u}, ${l}, ${c});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${e}; wF++) {
          float dyF = float(dyFCorner + wF) / ${s}.0;

          if (dyF < 0.0 || dyF >= ${t.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${e} - 1 - wF;

          for (int wR = 0; wR < ${n}; wR++) {
            float dyR = float(dyRCorner + wR) / ${i}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${n} - 1 - wR;

            for (int wC = 0; wC < ${o}; wC++) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${o} - 1 - wC;

              for (int d2 = 0; d2 < ${t.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function wet(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,dy:s}=t,{strides:i,pad:a,dataFormat:u,dimRoundingMode:l,filterShape:c}=n,p=S.convertConv2DDataFormat(u),m=S.computeConv2DInfo(o.shape,c,i,1,a,l,!1,p),f=new ev(m);return e.runWebGLProgram(f,[o,s],"float32")}var KL={kernelName:$p,backendName:"webgl",kernelFunc:wet};function vet(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,filter:s}=t,{inputShape:i,strides:a,pad:u,dataFormat:l,dimRoundingMode:c}=n,p=S.convertConv2DDataFormat(l),m=S.computeConv2DInfo(i,s.shape,a,1,u,c,!1,p),f=new rv(m);return e.runWebGLProgram(f,[o,s],"float32")}var jL={kernelName:ns,backendName:"webgl",kernelFunc:vet};function Cet(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,filter:s}=t,{strides:i,pad:a,dilations:u}=n,l=S.computeConv3DInfo(o.shape,s.shape,i,u,a),c=new Zw(l);return e.runWebGLProgram(c,[o,s],"float32")}var XL={kernelName:Rl,backendName:"webgl",kernelFunc:Cet};function Iet(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,dy:s}=t,{strides:i,pad:a,filterShape:u}=n,l=S.computeConv3DInfo(o.shape,u,i,1,a),c=new nv(l);return e.runWebGLProgram(c,[o,s],"float32")}var YL={kernelName:Dp,backendName:"webgl",kernelFunc:Iet};function ket(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,filter:s}=t,{pad:i,strides:a,inputShape:u}=n,l=S.computeConv3DInfo(u,s.shape,a,1,i),c=new ov(l);return e.runWebGLProgram(c,[o,s],"float32")}var ZL={kernelName:Rp,backendName:"webgl",kernelFunc:ket};var Net=Lo+`
  return cos(x);
`,Tet=Ct({opSnippet:Net}),JL={kernelName:os,backendName:"webgl",kernelFunc:Tet};var _et=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,Eet=Ct({opSnippet:_et}),QL={kernelName:ss,backendName:"webgl",kernelFunc:Eet};var sv=class{constructor(t,e,n,o,s){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];let[i,a,u,l]=t,[c]=e,[p,m]=n;this.outputShape=[c,p,m,l];let f=o==="bilinear"?1:0,[d,h]=[`${a-1}.0`,`${u-1}.0`],[g,y,b]=p>1?[`${(a-1)/(p-1)}`,"(y2-y1) * height_ratio",`y1*${d} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${d}`],[w,v,k]=m>1?[`${(u-1)/(m-1)}`,"(x2-x1) * width_ratio",`x1*${h} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${h}`];this.userCode=`
      const float height_ratio = float(${g});
      const float width_ratio = float(${w});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${i}) {
          return;
        }

        float height_scale = ${y};
        float width_scale = ${v};

        float in_y = ${b};
        if( in_y < 0.0 || in_y > ${d} ) {
          setOutput(float(${s}));
          return;
        }
        float in_x = ${k};
        if( in_x < 0.0 || in_x > ${h} ) {
          setOutput(float(${s}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${f} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}};var Aet=r=>{let{inputs:t,backend:e,attrs:n}=r,{image:o,boxes:s,boxInd:i}=t,{cropSize:a,method:u,extrapolationValue:l}=n,c=new sv(o.shape,s.shape,a,u,l);return e.runWebGLProgram(c,[o,s,i],"float32")},t3={kernelName:ca,backendName:"webgl",kernelFunc:Aet};var Ng=class{constructor(t,e,n){this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}],this.outputShape=t;let o=t.length,s=e?"1.0":`getX(${e3(o,"coords")})`,i=t[t.length-1],a="",u="";e?(a=n?`end != ${i-1}`:"end != 0",u=n?"end + 1":"end - 1"):(a=n?`end + pow2 < ${i}`:"end >= pow2",u=n?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${Vt(o)} coords = getOutputCoords();
        int end = ${r3(o,"coords")};
        float val = ${s};
        int pow2 = int(pow(2.0, index));
        if (${a}) {
          int idx = ${u};
          ${r3(o,"coords")} = idx;
          val *= getX(${e3(o,"coords")});
        }
        setOutput(val);
      }
    `}};function e3(r,t){if(r===1)return`${t}`;if(r===2)return`${t}.x, ${t}.y`;if(r===3)return`${t}.x, ${t}.y, ${t}.z`;if(r===4)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw Error(`Cumulative product for rank ${r} is not yet supported`)}function r3(r,t){if(r===1)return`${t}`;if(r===2)return`${t}.y`;if(r===3)return`${t}.z`;if(r===4)return`${t}.w`;throw Error(`Cumulative product for rank ${r} is not yet supported`)}function $et(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,exclusive:i,reverse:a}=n,u=o.shape.length,l=S.getAxesPermutation([s],u),c=o;l!=null&&(c=Ae({inputs:{x:o},backend:e,attrs:{perm:l}}));let p=S.getInnerMostAxes(1,u)[0];if(p!==u-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${o.shape.length-1} but got axis=${s}`);let m=c.shape[p],f=Ke({inputs:{x:c},backend:e});for(let d=0;d<=Math.ceil(Math.log2(m))-1;d++){let h=new Ng(c.shape,!1,a),g=[[d]],y=f;f=e.runWebGLProgram(h,[f],f.dtype,g),e.disposeIntermediateTensorInfo(y)}if(i){let d=new Ng(c.shape,i,a),h=f;f=e.runWebGLProgram(d,[f],f.dtype),e.disposeIntermediateTensorInfo(h)}if(l!=null){let d=S.getUndoAxesPermutation(l),h=Ae({inputs:{x:f},backend:e,attrs:{perm:d}});return e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(c),h}return f}var n3={kernelName:ua,backendName:"webgl",kernelFunc:$et};var Tg=class{constructor(t,e,n){this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}],this.outputShape=t;let o=t.length,s=e?"0.0":`getX(${o3(o,"coords")})`,i=t[t.length-1],a="",u="";e?(a=n?`end != ${i-1}`:"end != 0",u=n?"end + 1":"end - 1"):(a=n?`end + pow2 < ${i}`:"end >= pow2",u=n?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${Vt(o)} coords = getOutputCoords();
        int end = ${s3(o,"coords")};
        float val = ${s};
        int pow2 = int(pow(2.0, index));
        if (${a}) {
          int idx = ${u};
          ${s3(o,"coords")} = idx;
          val += getX(${o3(o,"coords")});
        }
        setOutput(val);
      }
    `}};function o3(r,t){if(r===1)return`${t}`;if(r===2)return`${t}.x, ${t}.y`;if(r===3)return`${t}.x, ${t}.y, ${t}.z`;if(r===4)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw Error(`Cumulative sum for rank ${r} is not yet supported`)}function s3(r,t){if(r===1)return`${t}`;if(r===2)return`${t}.y`;if(r===3)return`${t}.z`;if(r===4)return`${t}.w`;throw Error(`Cumulative sum for rank ${r} is not yet supported`)}function Det(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,exclusive:i,reverse:a}=n,u=o.shape.length,l=S.getAxesPermutation([s],u),c=o;l!=null&&(c=Ae({inputs:{x:o},backend:e,attrs:{perm:l}}));let p=S.getInnerMostAxes(1,u)[0];if(p!==u-1)throw new Error(`WebGL cumsum shader expects an inner-most axis=${o.shape.length-1} but got axis=${s}`);let m=c.shape[p],f=Ke({inputs:{x:c},backend:e});for(let d=0;d<=Math.ceil(Math.log2(m))-1;d++){let h=new Tg(c.shape,!1,a),g=[[d]],y=f;f=e.runWebGLProgram(h,[f],f.dtype,g),e.disposeIntermediateTensorInfo(y)}if(i){let d=new Tg(c.shape,i,a),h=f;f=e.runWebGLProgram(d,[f],f.dtype),e.disposeIntermediateTensorInfo(h)}if(l!=null){let d=S.getUndoAxesPermutation(l),h=Ae({inputs:{x:f},backend:e,attrs:{perm:d}});return e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(c),h}return f}var i3={kernelName:is,backendName:"webgl",kernelFunc:Det};function Ret(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,weights:s}=t,{size:i,binaryOutput:a}=n;if(o.shape.length===1){let u=e.readSync(o.dataId),l=e.readSync(s.dataId),c=Cw(u,l,s.dtype,s.shape,i);return e.makeTensorInfo([i],s.dtype,c)}else if(o.shape.length===2){let u=e.bufferSync(o),l=e.bufferSync(s),c=KM(u,l,i,a);return e.makeTensorInfo(c.shape,s.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${o.shape.length}.`)}var a3={kernelName:Fp,backendName:"webgl",kernelFunc:Ret};var iv=class{constructor(t,e,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=t,this.blockSize=e,this.dataFormat=n,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${e};
      int offset_h = imod(h, ${e});
      int in_w = w / ${e};
      int offset_w = imod(w, ${e});
      int offset_d = (offset_h * ${e} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}};function Fet(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{blockSize:s,dataFormat:i}=n,a=o.shape[0],u=i==="NHWC"?o.shape[1]:o.shape[2],l=i==="NHWC"?o.shape[2]:o.shape[3],c=i==="NHWC"?o.shape[3]:o.shape[1],p=u*s,m=l*s,f=c/(s*s),d=i==="NHWC"?[a,p,m,f]:[a,f,p,m],h=new iv(d,s,i);return e.runWebGLProgram(h,[o],o.dtype)}var l3={kernelName:pa,backendName:"webgl",kernelFunc:Fet};var vd=class{constructor(t,e=!1,n=null,o=!1,s=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=De(this.outputShape.length);let i=t.filterHeight,a=t.filterWidth,u=t.outChannels/t.inChannels,l="",c="";n&&(o?l=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:s?l=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:l=`
          float activation(float x) {
            ${n}
          }
        `,c="result = activation(result);");let p=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${l}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${u};
        int q = d2 - d1 * ${u};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${i}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${a}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${p}
        ${c}
        setOutput(result);
      }
    `}};var Cd=class{constructor(t,e=!1,n=null,o=!1,s=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=De(this.outputShape.length);let i=t.outChannels/t.inChannels,a=t.padInfo.left,u=t.strideWidth,l=t.dilationWidth,c=t.filterHeight,p=t.filterWidth,m=p,f=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let y=0;y<p;y++)f+=`
          vec4 xTexelC${y*2};
          int xTexelC${y*2}Ready;
          vec4 xTexelC${y*2+1};
          int xTexelC${y*2+1}Ready;
          vec4 xC${y};`;f+=`
    for (int r = 0; r < ${c}; r++) {
      `;for(let y=0;y<p;y++)f+=`
          xTexelC${y*2} = vec4(0.0);
          xTexelC${y*2}Ready = 0;
          xTexelC${y*2+1} = vec4(0.0);
          xTexelC${y*2+1}Ready = 0;
          xC${y} = vec4(0.0);`;f+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let y=0;y<(m+1)/2;y++){let b=y*2;if(f+=`
          xC = xCCorner + ${b*l};
          `,u===1){if(b<p&&(a%2===1?(f+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }
              `,l===1&&b>0?f+=`
                xC${b} = vec4(xTexelC${b-2}.zw, xTexelC${b}.xy);
                `:f+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${b} = vec4(previous.zw, xTexelC${b}.xy);
                  } else {
                    xC${b} = vec4(0.0, 0.0, xTexelC${b}.xy);
                  }
                  `):f+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                xC${b} = xTexelC${b};
                `,b+1<p)){let w=a%2===0?x.nearestLargerEven(l):l;l%2===0&&a%2===1||l%2!==0&&a%2!==1?(f+=`
                  xCOffset = xC + imod(pads[1], 2) + ${w};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                    xTexelC${b+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${b+1}.zw = vec2(0.0);
                    }
                    xTexelC${b+1}Ready = 1;
                  }
                  `,l>1&&(f+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                      xTexelC${b} = getX(batch, xR, xCOffset, d1);
                      xTexelC${b}Ready = 1;
                    }
                    `),f+=`
                  xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.xy);
                  `):w===1?f+=`
                    xC${b+1} = xTexelC${b};
                    `:f+=`
                    xCOffset = xC + ${w};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                      xTexelC${b+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${b+1}.zw = vec2(0.0);
                      }
                      xTexelC${b+1}Ready = 1;
                    }

                    xC${b+1} = xTexelC${b+1};
                    `}}else b<p&&(a%2===1?(f+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${b+1}Ready == 0) {
                  xTexelC${b+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${b+1}.zw = vec2(0.0);
                  }
                  xTexelC${b+1}Ready = 1;
                }

                xC${b} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);
              `,b+1<p&&(f+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${b+1} = vec4(xTexelC${b+1}.xy, final.xy);
                `)):(f+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                  xTexelC${b+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b+1}.zw = vec2(0.);
                  }
                  xTexelC${b+1}Ready = 1;
                }

                xC${b} = vec4(
                  xTexelC${b}.xy, xTexelC${b+1}.xy);
              `,b+1<p&&(f+=`
                  xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);
                `)));b<p&&(f+=`
            wTexel = getW(r, ${b}, d1, q);
            dotProd += xC${b} * vec4(wTexel.xz, wTexel.xz);
          `,b+1<p&&(f+=`
              wTexel = getW(r, ${b+1}, d1, q);
              dotProd += xC${b+1} * vec4(wTexel.xz, wTexel.xz);
            `))}f+=`
    }
  `,f+=`
      }
    `;let d="",h="";n&&(o?d=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:s?d=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:d=`vec4 activation(vec4 x) {
          ${n}
        }`,h="result = activation(result);");let g=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${d}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${i};
        int q = d2 - d1 * ${i};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${f}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${g}
        ${h}
        setOutput(result);
      }
    `}};function Oet(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,filter:s}=t,{strides:i,pad:a,dilations:u,dimRoundingMode:l}=n,c=u;c==null&&(c=[1,1]),x.assert(S.eitherStridesOrDilationsAreOne(i,c),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);let p=S.computeConv2DInfo(o.shape,s.shape,i,c,a,l,!0),m;V().getBool("WEBGL_PACK_DEPTHWISECONV")&&p.strideWidth<=2&&p.outChannels/p.inChannels===1?m=new Cd(p):m=new vd(p);let f=[[p.padInfo.top,p.padInfo.left],[p.strideHeight,p.strideWidth],[p.dilationHeight,p.dilationWidth],[p.inHeight,p.inWidth]];return e.runWebGLProgram(m,[o,s],"float32",f)}var u3={kernelName:as,backendName:"webgl",kernelFunc:Oet};var av=class{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;let e=t.strideHeight,n=t.strideWidth,o=t.padInfo.top,s=t.padInfo.left,i=t.outChannels/t.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${i} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yR = 0; yR < ${t.outHeight}; yR++) {
            int xR = wR + yR * ${e} - ${o};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${t.outWidth}; yC++) {
              int xC = wC + yC * ${n} - ${s};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}},lv=class{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;let e=t.filterHeight,n=t.filterWidth,o=t.strideHeight,s=t.strideWidth,i=e-1-t.padInfo.top,a=n-1-t.padInfo.left,u=t.outChannels/t.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${e}; wR++) {
          float dyR = float(dyRCorner + wR) / ${o}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${e} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${n} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${u}; dm++) {
              int d2 = d1 * ${u} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function Met(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,dy:s}=t,{strides:i,dilations:a,pad:u,dimRoundingMode:l,filterShape:c}=n,p=S.computeConv2DInfo(o.shape,c,i,a,u,l,!0),m=new av(p);return e.runWebGLProgram(m,[o,s],"float32")}var c3={kernelName:Op,backendName:"webgl",kernelFunc:Met};function Pet(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,filter:s}=t,{strides:i,dilations:a,pad:u,dimRoundingMode:l,inputShape:c}=n,p=S.computeConv2DInfo(c,s.shape,i,a,u,l,!0),m=new lv(p);return e.runWebGLProgram(m,[o,s],"float32")}var p3={kernelName:Mp,backendName:"webgl",kernelFunc:Pet};var uv=class{constructor(t){this.variableNames=["X"],this.outputShape=[t,t],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}};function Let(r){let{inputs:t,backend:e}=r,{x:n}=t,o=[...n.shape,...n.shape],s=x.sizeFromShape(n.shape),i=ut({inputs:{x:n},backend:e,attrs:{shape:[s]}}),a=new uv(s),u=e.runWebGLProgram(a,[i],i.dtype),l=ut({inputs:{x:u},backend:e,attrs:{shape:o}});return e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(u),l}var m3={kernelName:Pp,backendName:"webgl",kernelFunc:Let};var cv=class{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;let{inHeight:e,inWidth:n,padInfo:o,strideHeight:s,strideWidth:i,filterHeight:a,filterWidth:u,dilationHeight:l,dilationWidth:c}=t,{top:p,left:m}=o;this.userCode=`
      const ivec2 strides = ivec2(${s}, ${i});
      const ivec2 pads = ivec2(${p}, ${m});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${a}; h++) {
          int hIn = hBeg + h * ${l};

          if (hIn >= 0 && hIn < ${e}) {
            for (int w = 0; w < ${u}; w++) {
              int wIn = wBeg + w * ${c};

              if (wIn >= 0 && wIn < ${n}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}};function zet(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,filter:s}=t,{strides:i,pad:a,dilations:u}=n,l=S.computeDilation2DInfo(o.shape,s.shape,i,a,"NHWC",u),c,p=new cv(l);c=e.runWebGLProgram(p,[o,s],"float32");let m=ut({inputs:{x:c},backend:e,attrs:{shape:l.outShape}});return e.disposeIntermediateTensorInfo(c),m}var f3={kernelName:Fl,backendName:"webgl",kernelFunc:zet};function Bet(r){let{inputs:t,backend:e,attrs:n}=r,{equation:o}=n,s=t,{allDims:i,summedDims:a,idDims:u}=S.decodeEinsumEquation(o,s.length);S.checkEinsumDimSizes(i.length,u,s);let{path:l,steps:c}=S.getEinsumComputePath(a,u),p=c.length,m=null,f=i.length,d=[];for(let h=0;h<p;++h){for(let g of c[h]){let{permutationIndices:y,expandDims:b}=S.getEinsumPermutation(f,u[g]),w;S.isIdentityPermutation(y)?w=s[g]:(w=Ae({inputs:{x:s[g]},backend:e,attrs:{perm:y}}),d.push(w));let v=w.shape.slice();for(let k=0;k<b.length;++k)v.splice(b[k],0,1);x.arraysEqual(w.shape,v)||(w=ut({inputs:{x:w},backend:e,attrs:{shape:v}}),d.push(w)),m===null?m=w:(m=Sg({inputs:{a:w,b:m},backend:e}),d.push(m))}h<p-1&&(l[h]>=0&&(m=ep({inputs:{x:m},backend:e,attrs:{axis:l[h]-(i.length-f),keepDims:!1}}),d.push(m)),f--)}for(let h of d)h!==m&&e.disposeIntermediateTensorInfo(h);return m}var d3={kernelName:Lp,backendName:"webgl",kernelFunc:Bet};var Vet="return (x >= 0.0) ? x : (exp(x) - 1.0);",Get=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,Wet=Ct({opSnippet:Vet,packedOpSnippet:Get}),h3={kernelName:us,backendName:"webgl",kernelFunc:Wet};var Uet="return (b >= 1.0) ? a : a * (b + 1.0);",Het=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,qet=r=>{let{inputs:t,backend:e}=r,{dy:n,y:o}=t,s=V().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Po(Het,n.shape,o.shape):new ro(Uet,n.shape,o.shape);return e.runWebGLProgram(s,[n,o],n.dtype)},g3={kernelName:zp,backendName:"webgl",kernelFunc:qet};var Ket=`
  return vec4(equal(a, b));
`,jet="return float(a == b);",Xet=le({opSnippet:jet,packedOpSnippet:Ket,dtype:"bool",cpuKernelImpl:YM}),x3={kernelName:fa,backendName:"webgl",kernelFunc:Xet};var Yet=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${S.ERF_P};
  float a1 = ${S.ERF_A1};
  float a2 = ${S.ERF_A2};
  float a3 = ${S.ERF_A3};
  float a4 = ${S.ERF_A4};
  float a5 = ${S.ERF_A5};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,Zet=Ct({opSnippet:Yet}),y3={kernelName:ma,backendName:"webgl",kernelFunc:Zet};var Jet=Lo+`
  return exp(x);
`,Qet=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,kT=Ct({opSnippet:Jet,packedOpSnippet:Qet,cpuKernelImpl:ZM,dtype:"float32"}),b3={kernelName:cs,backendName:"webgl",kernelFunc:kT};function pv(r){let{inputs:t,attrs:e,backend:n}=r,{dim:o}=e,{input:s}=t,i=s.shape.length,a=s.shape.slice(),u=o;return o<0&&(x.assert(-(i+1)<=o,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),u=i+o+1),a.splice(u,0,1),ut({inputs:{x:s},backend:n,attrs:{shape:a}})}var w3={kernelName:Ci,backendName:"webgl",kernelFunc:pv};var v3="return exp(x) - 1.0;",trt=Ct({opSnippet:v3,packedOpSnippet:v3,cpuKernelImpl:JM}),C3={kernelName:da,backendName:"webgl",kernelFunc:trt};var _g=class{constructor(t,e,n){this.variableNames=["real","imag"];let o=e[1];this.outputShape=e;let s=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,i=n?`${o}.0`:"1.0",a;if(t==="real")a="return real * expR - imag * expI;";else if(t==="imag")a="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${t}.`);this.userCode=`
      const float exponentMultiplier = ${s};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${a}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${o});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${o}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${i};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}};function mv(r,t,e){let n=e.texData.get(r.dataId),o=x.sizeFromShape(r.shape),s=r.shape[r.shape.length-1],i=o/s,a=ut({inputs:{x:r},backend:e,attrs:{shape:[i,s]}}),u=a.shape,l=new _g("real",u,t),c=new _g("imag",u,t),p=[{dataId:n.complexTensorInfos.real.dataId,dtype:n.complexTensorInfos.real.dtype,shape:u},{dataId:n.complexTensorInfos.imag.dataId,dtype:n.complexTensorInfos.imag.dtype,shape:u}],m=e.runWebGLProgram(l,p,"float32"),f=e.runWebGLProgram(c,p,"float32"),d=Rn({inputs:{real:m,imag:f},backend:e});e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(f);let h=ut({inputs:{x:d},backend:e,attrs:{shape:r.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(d),h}function ert(r){let{inputs:t,backend:e}=r,{input:n}=t;return mv(n,!1,e)}var I3={kernelName:Bp,backendName:"webgl",kernelFunc:ert};var fv=class{constructor(t,e){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=t,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}};function Sl(r){let{backend:t,attrs:e}=r,{shape:n,value:o}=e,{dtype:s}=e;if(s=s||x.inferDtype(o),s==="string"){let i=x.getArrayFromDType(s,x.sizeFromShape(n));return i.fill(o),t.makeTensorInfo(n,s,i)}else{let i=new fv(n,o),a=[[o]];return t.runWebGLProgram(i,[],s,a)}}var S3={kernelName:Ol,backendName:"webgl",kernelFunc:Sl};var dv=class{constructor(t){this.variableNames=["Image"],this.outputShape=[];let e=t[2];this.outputShape=t,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${e} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${e}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}};var k3={kernelName:ha,backendName:"webgl",kernelFunc:({inputs:r,backend:t})=>{let{image:e}=r,n=t,o=new dv(e.shape);return n.runWebGLProgram(o,[e],e.dtype)}};var N3="return floor(x);",rrt=Ct({opSnippet:N3,packedOpSnippet:N3,cpuKernelImpl:QM}),T3={kernelName:ps,backendName:"webgl",kernelFunc:rrt};var nrt=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,ort=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,srt=le({opSnippet:nrt,packedOpSnippet:ort,dtype:"int32"}),_3={kernelName:ms,backendName:"webgl",kernelFunc:srt};var hv=class{constructor(t){this.variableNames=["A"];let e=qe(),[n,o]=t;this.outputShape=t,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${o}.0, ${n}.0);

        vec4 values = ${e.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}};var gv=class{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;let e=qe(),[n,o]=t;this.outputShape=t,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${o}.0, ${n}.0);
            vec4 values = ${e.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${e.output} = result;
      }
    `}};var E3={kernelName:Hd,backendName:"webgl",kernelFunc:irt},Id;function irt(r){let{inputs:t,backend:e,attrs:n}=r,{pixels:o}=t,{numChannels:s}=n,i=typeof HTMLVideoElement!="undefined"&&o instanceof HTMLVideoElement,a=typeof HTMLImageElement!="undefined"&&o instanceof HTMLImageElement,[u,l]=i?[o.videoWidth,o.videoHeight]:[o.width,o.height],c=[l,u],p=[l,u,s];(a||i)&&(Id==null&&(Id=document.createElement("canvas").getContext("2d")),Id.canvas.width=u,Id.canvas.height=l,Id.drawImage(o,0,0,u,l),o=Id.canvas);let m=e.makeTensorInfo(c,"int32");e.texData.get(m.dataId).usage=Kr.PIXELS,e.gpgpu.uploadPixelDataToTexture(e.getTexture(m.dataId),o);let f=V().getBool("WEBGL_PACK")?new gv(p):new hv(p),d=e.runWebGLProgram(f,[m],"int32");return e.disposeData(m.dataId),d}function art(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,filter:s,bias:i,preluActivationWeights:a}=t,{strides:u,pad:l,dataFormat:c,dilations:p,dimRoundingMode:m,activation:f,leakyreluAlpha:d}=n,h=S.convertConv2DDataFormat(c),g=S.computeConv2DInfo(o.shape,s.shape,u,p,l,m,!1,h),y,b=[];if(g.filterHeight===1&&g.filterWidth===1&&g.dilationHeight===1&&g.dilationWidth===1&&g.strideHeight===1&&g.strideWidth===1&&(g.padInfo.type==="SAME"||g.padInfo.type==="VALID"))y=Qw({x:o,filter:s,convInfo:g,backend:e,bias:i,activation:f,preluActivationWeights:a,leakyreluAlpha:d});else if(V().getBool("WEBGL_CONV_IM2COL")&&o.shape[0]===1)y=tv({x:o,filter:s,convInfo:g,backend:e,bias:i,activation:f,preluActivationWeights:a,leakyreluAlpha:d});else{let v=i!=null,k=a!=null,E=f==="leakyrelu",$=f?vu(f,!1):null,D=new wd(g,v,$,k,E),R=[o,s];if(i&&R.push(i),a&&R.push(a),E){let P=e.makeTensorInfo([],"float32",x.createScalarValue(d,"float32"));R.push(P),b.push(P)}y=e.runWebGLProgram(D,R,"float32")}let w=ut({inputs:{x:y},backend:e,attrs:{shape:g.outShape}});return b.push(y),b.forEach(v=>e.disposeIntermediateTensorInfo(v)),w}var A3={kernelName:Oi,backendName:"webgl",kernelFunc:art};function lrt(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,filter:s,bias:i,preluActivationWeights:a}=t,{strides:u,pad:l,dilations:c,dimRoundingMode:p,activation:m,leakyreluAlpha:f}=n,d=[],h=c;h==null&&(h=[1,1]),x.assert(S.eitherStridesOrDilationsAreOne(u,h),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${u} and dilations '${h}'`);let g=S.computeConv2DInfo(o.shape,s.shape,u,h,l,p,!0),y=V().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels===1,b=m?vu(m,y):null,w=[o,s],v=i!=null,k=a!=null,E=m==="leakyrelu";if(v&&w.push(i),k&&w.push(a),E){let P=e.makeTensorInfo([],"float32",x.createScalarValue(f,"float32"));w.push(P),d.push(P)}let $;y?$=new Cd(g,v,b,k,E):$=new vd(g,v,b,k,E);let D=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],R=e.runWebGLProgram($,w,"float32",D);return d.forEach(P=>e.disposeIntermediateTensorInfo(P)),R}var $3={kernelName:Mi,backendName:"webgl",kernelFunc:lrt};var xv=class{constructor(t,e,n){this.sliceDim=t,this.strides=e,this.variableNames=["x","indices"],this.outputShape=n;let o=Vt(e.length),s=Vt(n.length),i=this.sliceDim>1?"strides[j]":"strides";this.userCode=`
        ${o} strides = ${o}(${this.strides});
         void main() {
          ${s} coords = getOutputCoords();
          int flattenIndex = 0;
          for (int j = 0; j < ${this.sliceDim}; j++) {
            int index = round(getIndices(coords[0], j));
            flattenIndex += index * ${i};
          }
          setOutput(getX(flattenIndex, coords[1]));
        }
      `}};function urt(r){let{inputs:t,backend:e}=r,{params:n,indices:o}=t,s=o.shape,i=s[s.length-1],a=x.sizeFromShape(n.shape),[u,l,c,p]=S.prepareAndValidate(n,o),m=ut({inputs:{x:o},backend:e,attrs:{shape:[l,i]}}),f=ut({inputs:{x:n},backend:e,attrs:{shape:[x.sizeFromShape(n.shape)/c,c]}});if(e.shouldExecuteOnCPU([n,o])||n.dtype==="string"){let y=e.readSync(o.dataId),b=e.bufferSync(n),w=tP(y,b,n.dtype,l,i,c,p,n.shape,a);return e.makeTensorInfo(u,n.dtype,w.values)}let d=new xv(i,p,[l,c]),h=e.runWebGLProgram(d,[f,m],f.dtype),g=ut({inputs:{x:h},backend:e,attrs:{shape:u}});return e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(h),g}var D3={kernelName:ga,backendName:"webgl",kernelFunc:urt};var yv=class{constructor(t,e){this.variableNames=["A","indices"],this.outputShape=e,this.rank=e.length;let n=Vt(this.rank),o=crt(t,2);this.userCode=`
      void main() {
        ${n} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${t[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${o}));
      }
    `}};function crt(r,t){let e=["resRC.x","resRC.y","resRC.z","resRC.w"],n=[];for(let o=0;o<r.length;o++)o===2?n.push("index"):n.push(`${e[o]}`);return n.join()}function NT(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,indices:s}=t,{axis:i,batchDims:a}=n,u=x.parseAxisParam(i,o.shape)[0];if(V().get("DEBUG")){let b=e.readSync(s.dataId),w=o.shape[u];for(let v=0;v<b.length;++v){let k=b[v];x.assert(k<=w-1&&k>=0,()=>`GatherV2: the index value ${k} is not in [0, ${w-1}]`)}}let l=S.segment_util.collectGatherOpShapeInfo(o,s,u,a),c=x.sizeFromShape(s.shape),p=[],m=ut({inputs:{x:o},backend:e,attrs:{shape:[l.batchSize,l.outerSize,l.dimSize,l.sliceSize]}}),f=ut({inputs:{x:s},backend:e,attrs:{shape:[l.batchSize,c/l.batchSize]}});p.push(m),p.push(f);let d=[l.batchSize,l.outerSize,c/l.batchSize,l.sliceSize];if(e.shouldExecuteOnCPU([o,s])||o.dtype==="string"){let b=e.bufferSync(f),w=e.bufferSync(m),v=eP(w,b,d);return p.forEach(k=>e.disposeIntermediateTensorInfo(k)),e.makeTensorInfo(l.outputShape,v.dtype,v.values)}let h=new yv(m.shape,d),g=e.runWebGLProgram(h,[m,f],m.dtype);p.push(g);let y=ut({inputs:{x:g},backend:e,attrs:{shape:l.outputShape}});return p.forEach(b=>e.disposeIntermediateTensorInfo(b)),y}var R3={kernelName:Ii,backendName:"webgl",kernelFunc:NT};var prt="return float(a > b);",mrt=`
  return vec4(greaterThan(a, b));
`,frt=le({opSnippet:prt,packedOpSnippet:mrt,cpuKernelImpl:rP,dtype:"bool"}),F3={kernelName:xa,backendName:"webgl",kernelFunc:frt};var drt="return float(a >= b);",hrt=`
  return vec4(greaterThanEqual(a, b));
`,grt=le({opSnippet:drt,packedOpSnippet:hrt,dtype:"bool",cpuKernelImpl:nP}),O3={kernelName:ds,backendName:"webgl",kernelFunc:grt};function xrt(r){let{inputs:t,backend:e}=r,{input:n}=t;return mv(n,!0,e)}var M3={kernelName:Vp,backendName:"webgl",kernelFunc:xrt};var yrt="return float(!isnan(x) && !isinf(x));",brt=Ct({opSnippet:yrt,dtype:"bool"}),P3={kernelName:ya,backendName:"webgl",kernelFunc:brt};var wrt="return float(isinf(x));",vrt=Ct({opSnippet:wrt,dtype:"bool"}),L3={kernelName:ba,backendName:"webgl",kernelFunc:vrt};var Crt="return float(isnan(x));",Irt=Ct({opSnippet:Crt,dtype:"bool"}),z3={kernelName:wa,backendName:"webgl",kernelFunc:Irt};var Srt="return float(a < b);",krt=`
  return vec4(lessThan(a, b));
`,Nrt=le({opSnippet:Srt,packedOpSnippet:krt,cpuKernelImpl:oP,dtype:"bool"}),B3={kernelName:va,backendName:"webgl",kernelFunc:Nrt};var Trt="return float(a <= b);",_rt=`
  return vec4(lessThanEqual(a, b));
`,Ert=le({opSnippet:Trt,packedOpSnippet:_rt,cpuKernelImpl:sP,dtype:"bool"}),V3={kernelName:Ca,backendName:"webgl",kernelFunc:Ert};function Art(r){let{backend:t,attrs:e}=r,{start:n,stop:o,num:s}=e,i=iP(n,o,s);return t.makeTensorInfo([i.length],"float32",i)}var G3={kernelName:Wp,backendName:"webgl",kernelFunc:Art};var $rt=Lo+`
  return x < 0.0 ? 0./0. : log(x);
`,Drt=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,Rrt=Ct({opSnippet:$rt,packedOpSnippet:Drt,cpuKernelImpl:aP}),W3={kernelName:gs,backendName:"webgl",kernelFunc:Rrt};var Frt=Lo+`
  return log(1.0 + x);
`,Ort=Ct({opSnippet:Frt}),U3={kernelName:Ia,backendName:"webgl",kernelFunc:Ort};var Mrt="return float(a >= 1.0 && b >= 1.0);",Prt=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,Lrt=le({opSnippet:Mrt,packedOpSnippet:Prt,dtype:"bool"}),H3={kernelName:Sa,backendName:"webgl",kernelFunc:Lrt};var zrt="return float(!(x >= 1.0));",Brt=Ct({opSnippet:zrt}),q3={kernelName:Ou,backendName:"webgl",kernelFunc:Brt};var Vrt="return float(a >= 1.0 || b >= 1.0);",Grt=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,Wrt=le({opSnippet:Vrt,packedOpSnippet:Grt,dtype:"bool"}),K3={kernelName:Mu,backendName:"webgl",kernelFunc:Wrt};var bv=class{constructor(t,e,n,o,s){this.variableNames=["x"],this.outputShape=[];let i=e,a=t[3]-1;this.outputShape=t;let u,l=`float(${n}) + float(${o}) * sum`;s===.5?u=`inversesqrt(${l})`:s===1?u=`1.0/(${l})`:u=`exp(log(${l}) * float(-${s}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${i}; j <= ${i}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${a}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${u};
        setOutput(val);
      }
    `}};var wv=class{constructor(t,e,n,o,s){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;let i=e,a=t[3]-1;this.outputShape=t;let u,l=`float(${n}) + float(${o}) * sum`;s===.5?u=`inversesqrt(${l})`:s===1?u=`1.0/(${l})`:u=`exp(log(${l}) * float(-${s}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${i};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${i}; j <= ${i}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${a}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${u};
        setOutput(result);
      }
    `}};var Urt=r=>{let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{depthRadius:s,bias:i,alpha:a,beta:u}=n,l=V().getBool("WEBGL_PACK_NORMALIZATION")?new wv(o.shape,s,i,a,u):new bv(o.shape,s,i,a,u);return e.runWebGLProgram(l,[o],o.dtype)},j3={kernelName:Ml,backendName:"webgl",kernelFunc:Urt};var vv=class{constructor(t,e,n,o,s){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=t,this.depth=t[3],this.depthRadius=e,this.bias=n,this.alpha=o,this.beta=s,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${e})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${e} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${o}) * norm + float(${n});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${o})
                * float(${s})
                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${s});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}};var Hrt=r=>{let{inputs:t,backend:e,attrs:n}=r,{x:o,y:s,dy:i}=t,{depthRadius:a,bias:u,alpha:l,beta:c}=n,p=new vv(o.shape,a,u,l,c);return e.runWebGLProgram(p,[o,s,i],o.dtype)},X3={kernelName:Up,backendName:"webgl",kernelFunc:Hrt};function Y3(r,t,e,n){let o=x.sizeFromShape(t),i=x.sizeFromShape(r.shape)/o,a=ut({inputs:{x:r},attrs:{shape:[i,o]},backend:n}),u=Hn(a,r.dtype,"max",n),l=ut({inputs:{x:u},attrs:{shape:e},backend:n});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(u),l}function TT(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{reductionIndices:s,keepDims:i}=n,a=o.shape.length,u=x.parseAxisParam(s,o.shape),l=u,c=S.getAxesPermutation(l,a),p=c!=null,m=e.shouldExecuteOnCPU([o]),f=o;if(p){if(m){let w=e.texData.get(f.dataId).values,v=new Array(a);for(let $=0;$<v.length;$++)v[$]=o.shape[c[$]];let k=Qc(w,o.shape,o.dtype,c,v);f=e.makeTensorInfo(v,o.dtype);let E=e.texData.get(f.dataId);E.values=k}else f=Cu(o,c,e);l=S.getInnerMostAxes(l.length,a)}S.assertAxesAreInnerMostDims("max",l,a);let[d,h]=S.computeOutAndReduceShapes(f.shape,l),g=d;i&&(g=S.expandShapeToKeepDim(d,u));let y;if(m){let w=e.texData.get(f.dataId).values,v=lP(w,x.sizeFromShape(h),g,o.dtype);y=e.makeTensorInfo(g,o.dtype);let k=e.texData.get(y.dataId);k.values=v}else y=Y3(f,h,g,e);return p&&e.disposeIntermediateTensorInfo(f),y}var Z3={kernelName:xs,backendName:"webgl",kernelFunc:TT};var qrt=Ew+`
  return max(a, b);
`,Krt=`
  vec4 result = vec4(max(a, b));
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  `+wu+`
  return result;
`,jrt=le({opSnippet:qrt,packedOpSnippet:Krt,cpuKernelImpl:uP}),J3={kernelName:ys,backendName:"webgl",kernelFunc:jrt};function Xrt(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t;fi(o,"maxPool");let{filterSize:s,strides:i,pad:a,dimRoundingMode:u}=n,l=1;x.assert(S.eitherStridesOrDilationsAreOne(i,l),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${l}'`);let c=S.computePool2DInfo(o.shape,s,i,l,a,u);if(c.filterWidth===1&&c.filterHeight===1&&x.arraysEqual(c.inShape,c.outShape))return Ke({inputs:{x:o},backend:e});let p=new hi(c,"max",!1);return e.runWebGLProgram(p,[o],o.dtype)}var Q3={kernelName:bs,backendName:"webgl",kernelFunc:Xrt};function Yrt(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{filterSize:s,strides:i,pad:a,dataFormat:u,dimRoundingMode:l}=n,c=[1,1,1],p=S.computePool3DInfo(o.shape,s,i,c,a,l,u),m=new Iu(p,"max",!1);return e.runWebGLProgram(m,[o],o.dtype)}var tz={kernelName:Pl,backendName:"webgl",kernelFunc:Yrt};var Cv=class{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;let e=t.strideHeight,n=t.strideWidth,o=t.dilationHeight,s=t.effectiveFilterHeight,i=t.effectiveFilterWidth,a=s-1-t.padInfo.top,u=i-1-t.padInfo.left,l=s*i-1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${u});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${s};
          wR += ${o}) {
          float dyR = float(dyRCorner + wR) / ${e}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${i}; wC++) {
            float dyC = float(dyCCorner + wC) / ${n}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${l} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${i} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}},Iv=class{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;let e=t.strideDepth,n=t.strideHeight,o=t.strideWidth,s=t.dilationDepth,i=t.dilationHeight,a=t.dilationWidth,u=t.effectiveFilterDepth,l=t.effectiveFilterHeight,c=t.effectiveFilterWidth,p=u-1-t.padInfo.front,m=l-1-t.padInfo.top,f=c-1-t.padInfo.left,d=u*l*c-1;this.userCode=`
      const ivec3 pads = ivec3(${p}, ${m}, ${f});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${u};
           wD += ${s}) {
          float dyD = float(dyDCorner + wD) / ${e}.0;

          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${l};
              wR += ${i}) {
            float dyR = float(dyRCorner + wR) / ${n}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${c};
                wC += ${a}) {
              float dyC = float(dyCCorner + wC) / ${o}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${d} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${l} * ${c} +
                  wR * ${c} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function Zrt(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,input:s}=t,i=s,{filterSize:a,strides:u,pad:l,dimRoundingMode:c}=n,p=[1,1,1],m=S.computePool3DInfo(i.shape,a,u,p,l,c),f=new Iu(m,"max",!0),d=e.runWebGLProgram(f,[i],i.dtype),h=new Iv(m),g=e.runWebGLProgram(h,[o,d],i.dtype);return e.disposeIntermediateTensorInfo(d),g}var ez={kernelName:qp,backendName:"webgl",kernelFunc:Zrt};function Jrt(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,input:s,output:i}=t,a=s;fi([s,i],"maxPoolGrad");let{filterSize:u,strides:l,pad:c,dimRoundingMode:p}=n,m=S.computePool2DInfo(a.shape,u,l,1,c,p),f=!0,d=new hi(m,"max",f),h=e.runWebGLProgram(d,[a],a.dtype),g=new Cv(m),y=e.runWebGLProgram(g,[o,h],a.dtype);return e.disposeIntermediateTensorInfo(h),y}var rz={kernelName:Hp,backendName:"webgl",kernelFunc:Jrt};function nz(r,t,e,n){let o=new hi(e,"max",!1),s=n.runWebGLProgram(o,[r],"float32");o=new hi(e,"max",!0,!0,t);let i=n.runWebGLProgram(o,[r],"float32");return[s,i]}var oz={kernelName:Kp,backendName:"webgl",kernelFunc:({inputs:r,attrs:t,backend:e})=>{let{x:n}=r,{filterSize:o,strides:s,pad:i,includeBatchInIndex:a}=t,u=e;x.assert(n.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${n.shape.length}.`);let l=[1,1];x.assert(S.eitherStridesOrDilationsAreOne(s,l),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${s} and dilations '${l}'`);let c=S.computePool2DInfo(n.shape,o,s,l,i),[p,m]=nz(n,a,c,u);return[p,m]}};function sz(r,t,e,n){let o=x.sizeFromShape(t),i=x.sizeFromShape(r.shape)/o,a=ut({inputs:{x:r},attrs:{shape:[i,o]},backend:n}),u=Hn(a,"float32","mean",n),l=ut({inputs:{x:u},attrs:{shape:e},backend:n});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(u),l}var iz={kernelName:ws,backendName:"webgl",kernelFunc:({inputs:r,attrs:t,backend:e})=>{let{x:n}=r,{keepDims:o,axis:s}=t,i=e,a=n.shape.length,u=x.parseAxisParam(s,n.shape),l=u,c=S.getAxesPermutation(l,a),p=c!=null,m=i.shouldExecuteOnCPU([n]),f=[],d=n;if(p){if(m){let v=i.texData.get(d.dataId).values,k=new Array(a);for(let D=0;D<k.length;D++)k[D]=n.shape[c[D]];let E=Qc(v,n.shape,n.dtype,c,k);d=i.makeTensorInfo(k,n.dtype);let $=i.texData.get(d.dataId);$.values=E}else d=Cu(n,c,i);f.push(d),l=S.getInnerMostAxes(l.length,a)}S.assertAxesAreInnerMostDims("sum",l,a);let[h,g]=S.computeOutAndReduceShapes(d.shape,l),y=h;o&&(y=S.expandShapeToKeepDim(h,u));let b=sz(d,g,y,i);for(let w of f)i.disposeIntermediateTensorInfo(w);return b}};function Qrt(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,keepDims:i}=n,a=o.shape.length,u=x.parseAxisParam(s,o.shape),l=u,c=S.getAxesPermutation(l,a),p=o;c!=null&&(p=Ae({inputs:{x:o},backend:e,attrs:{perm:c}}),l=S.getInnerMostAxes(l.length,o.shape.length)),S.assertAxesAreInnerMostDims("min",l,a);let[m,f]=S.computeOutAndReduceShapes(p.shape,l),d=x.sizeFromShape(f),h=ut({inputs:{x:p},backend:e,attrs:{shape:[-1,d]}}),g=Hn(h,h.dtype,"min",e),y;if(i){let b=S.expandShapeToKeepDim(m,u);y=ut({inputs:{x:g},backend:e,attrs:{shape:b}})}else y=ut({inputs:{x:g},backend:e,attrs:{shape:m}});return e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(g),c!=null&&e.disposeIntermediateTensorInfo(p),y}var az={kernelName:vs,backendName:"webgl",kernelFunc:Qrt};var tnt=Ew+`
  return min(a, b);
`,ent=`
  vec4 result = vec4(min(a, b));
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  `+wu+`
  return result;
`,rnt=le({opSnippet:tnt,packedOpSnippet:ent,cpuKernelImpl:cP}),lz={kernelName:Cs,backendName:"webgl",kernelFunc:rnt};var Sv=class{constructor(t,e,n){this.variableNames=["x"],this.outputShape=e.map((c,p)=>c[0]+t[p]+c[1]);let o=t.length,s=Vt(o),i=e.map(c=>c[0]).join(","),a=e.map((c,p)=>c[0]+t[p]).join(","),u=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,o),l=n==="reflect"?0:1;if(o===1){this.userCode=`
        int start = ${i};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${l};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${l};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${s} start = ${s}(${i});
      ${s} end = ${s}(${a});

      void main() {
        ${s} outC = getOutputCoords();
        for (int i = 0; i < ${o}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${l};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${l};
          }
        }
        ${s} coords = outC - start;
        setOutput(getX(${u}));
      }
    `}};var kv=class{constructor(t,e,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.map((d,h)=>d[0]+t[h]+d[1]);let o=t.length,s=Vt(o),i=e.map(d=>d[0]).join(","),a=e.map((d,h)=>d[0]+t[h]).join(","),u=nr("rc",o),l=nr("source",o),c=`${u[o-1]} < ${this.outputShape[o-1]}`,p=o===1?"source":`vec2(${l.slice(-2).join()})`,m=n==="reflect"?0:1,f="";if(o===1){let d=`
        ${s} source = rc;
        if (source < start) {
          source = start * 2 - source - ${m};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${m};
        }
        source -= start;
      `;f=`
        ${s} rc = outputLoc;
        ${d}
        result[0] = getChannel(getX(${l.join()}), ${p});
        ${u[o-1]} += 1;
        if(${c}) {
          ${d}
          result[1] = getChannel(getX(${l.join()}), ${p});
        }
      `}else{let d=`
        ${s} source = rc;
        ${s} lt = ${s}(lessThan(source, start));
        ${s} gte = ${s}(greaterThanEqual(source, end));
        ${s} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${m}) +
                gte * ((end - 1) * 2 - source + ${m});
        source -= start;
      `;f=`
        ${s} rc = outputLoc;
        ${d}
        result[0] = getChannel(getX(${l.join()}), ${p});
        ${u[o-1]} += 1;
        if(${c}) {
          ${d}
          result[1] = getChannel(getX(${l.join()}), ${p});
        }
        rc = outputLoc;
        ${u[o-2]} += 1;
        if(${u[o-2]} < ${this.outputShape[o-2]}) {
          ${d}
          result[2] = getChannel(getX(${l.join()}), ${p});
          ${u[o-1]} += 1;
          if(${c}) {
            ${d}
            result[3] = getChannel(getX(${l.join()}), ${p});
          }
        }
      `}this.userCode=`
      const ${s} start = ${s}(${i});
      const ${s} end = ${s}(${a});

      void main() {
        ${s} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${f}
        setOutput(result);
      }
    `}};var nnt=({inputs:r,backend:t,attrs:e})=>{let{x:n}=r,{paddings:o,mode:s}=e,i=V().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new kv(n.shape,o,s):new Sv(n.shape,o,s);return t.runWebGLProgram(i,[n],n.dtype)},uz={kernelName:Is,backendName:"webgl",kernelFunc:nnt};var ont=`if (b == 0.0) return NAN;
  return mod(a, b);`,snt=`
  vec4 result = mod(a, b);
  vec4 isNaN = vec4(equal(b, vec4(0.0)));
  `+wu+`
  return result;
`,int=le({opSnippet:ont,packedOpSnippet:snt}),cz={kernelName:ka,backendName:"webgl",kernelFunc:int};var Nv=class{constructor(t,e,n){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[t,n],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${e-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${e-1}));
      }
    `}};var ant=`
if (a == b) {
  return 1.0;
};
return a / b;`,lnt=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,_T=le({opSnippet:ant,packedOpSnippet:lnt,checkOutOfBounds:!0}),pz={kernelName:ls,backendName:"webgl",kernelFunc:_T};var mz="return a - b;",ET=le({opSnippet:mz,packedOpSnippet:mz,supportsComplex:!0,cpuKernelImpl:NP}),fz={kernelName:Vs,backendName:"webgl",kernelFunc:ET};function AT(r){let{inputs:t,backend:e,attrs:n}=r,{logits:o}=t,{dim:s}=n,i=x.parseAxisParam([s],o.shape),a=TT({inputs:{x:o},backend:e,attrs:{reductionIndices:i,keepDims:!1}}),u=S.expandShapeToKeepDim(a.shape,i),l=ut({inputs:{x:a},backend:e,attrs:{shape:u}}),c=ET({inputs:{a:o,b:l},backend:e}),p=kT({inputs:{x:c},backend:e}),m=ep({inputs:{x:p},backend:e,attrs:{axis:i,keepDims:!1}}),f=ut({inputs:{x:m},backend:e,attrs:{shape:u}}),d=_T({inputs:{a:p,b:f},backend:e});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(l),e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(f),d}var dz={kernelName:zs,backendName:"webgl",kernelFunc:AT};function unt(r){let{inputs:t,backend:e,attrs:n}=r,{logits:o}=t,{numSamples:s,seed:i,normalized:a}=n,u=a?o:AT({inputs:{logits:o},backend:e,attrs:{dim:o.shape.length-1}}),l=u.shape[0],c=u.shape[1],p=new Nv(l,c,s),m=[[i]],f=e.runWebGLProgram(p,[u],"int32",m);return a||e.disposeIntermediateTensorInfo(u),f}var hz={kernelName:jp,backendName:"webgl",kernelFunc:unt};var cnt=hr+`
  return -x;
`,pnt=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function mnt(r){let{inputs:t,backend:e}=r,{x:n}=t;if(e.shouldExecuteOnCPU([n])){let s=e.texData.get(n.dataId),[i,a]=mP(s.values,n.shape,n.dtype);return e.makeTensorInfo(a,n.dtype,i)}let o;return V().getBool("WEBGL_PACK_UNARY_OPERATIONS")?o=new eo(n.shape,pnt):o=new en(n.shape,cnt),e.runWebGLProgram(o,[n],n.dtype)}var gz={kernelName:Si,backendName:"webgl",kernelFunc:mnt};var fnt=Gr.nonMaxSuppressionV3Impl;function dnt(r){S.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:e,attrs:n}=r,{boxes:o,scores:s}=t,{maxOutputSize:i,iouThreshold:a,scoreThreshold:u}=n,l=e.readSync(o.dataId),c=e.readSync(s.dataId),{selectedIndices:p}=fnt(l,c,i,a,u);return e.makeTensorInfo([p.length],"int32",new Int32Array(p))}var xz={kernelName:Ta,backendName:"webgl",kernelFunc:dnt};var hnt=Gr.nonMaxSuppressionV4Impl;function gnt(r){S.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:e,attrs:n}=r,{boxes:o,scores:s}=t,{maxOutputSize:i,iouThreshold:a,scoreThreshold:u,padToMaxOutputSize:l}=n,c=e.readSync(o.dataId),p=e.readSync(s.dataId),{selectedIndices:m,validOutputs:f}=hnt(c,p,i,a,u,l);return[e.makeTensorInfo([m.length],"int32",new Int32Array(m)),e.makeTensorInfo([],"int32",new Int32Array([f]))]}var yz={kernelName:_a,backendName:"webgl",kernelFunc:gnt};var xnt=Gr.nonMaxSuppressionV5Impl;function ynt(r){S.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:e,attrs:n}=r,{boxes:o,scores:s}=t,{maxOutputSize:i,iouThreshold:a,scoreThreshold:u,softNmsSigma:l}=n,c=e.readSync(o.dataId),p=e.readSync(s.dataId),m=i,f=a,d=u,h=l,{selectedIndices:g,selectedScores:y}=xnt(c,p,m,f,d,h);return[e.makeTensorInfo([g.length],"int32",new Int32Array(g)),e.makeTensorInfo([y.length],"float32",new Float32Array(y))]}var bz={kernelName:Ea,backendName:"webgl",kernelFunc:ynt};var Tv=class{constructor(t,e,n,o){this.variableNames=["indices"],this.outputShape=[t,e],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${o}), float(${n}),
                      float(index == coords.y)));
      }
    `}};var bnt=r=>{let{inputs:t,backend:e,attrs:n}=r,{indices:o}=t,{depth:s,onValue:i,offValue:a}=n,u=x.sizeFromShape(o.shape),l=new Tv(u,s,i,a),c=ut({inputs:{x:o},backend:e,attrs:{shape:[u]}}),p=e.runWebGLProgram(l,[c],o.dtype);e.disposeIntermediateTensorInfo(c);let m=[...o.shape,s],f=ut({inputs:{x:p},backend:e,attrs:{shape:m}});return e.disposeIntermediateTensorInfo(p),f},wz={kernelName:ks,backendName:"webgl",kernelFunc:bnt};function Eg(r){let{inputs:t,backend:e}=r,{x:n}=t;if(n.dtype==="complex64"){let o=Il({inputs:{input:n},backend:e}),s=Eg({inputs:{x:o},backend:e}),i=np({inputs:{input:n},backend:e}),a=Eg({inputs:{x:i},backend:e}),u=Rn({inputs:{real:s,imag:a},backend:e});return e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(a),u}else return Sl({attrs:{shape:n.shape,dtype:n.dtype,value:n.dtype==="string"?"":0},backend:e})}var vz={kernelName:Ri,backendName:"webgl",kernelFunc:Eg};function Cz(r){let{inputs:t,backend:e}=r,{x:n}=t;if(n.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(n.dtype==="complex64"){let o=Il({inputs:{input:n},backend:e}),s=Cz({inputs:{x:o},backend:e}),i=np({inputs:{input:n},backend:e}),a=Eg({inputs:{x:i},backend:e}),u=Rn({inputs:{real:s,imag:a},backend:e});return e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(a),u}else return Sl({attrs:{shape:n.shape,dtype:n.dtype,value:1},backend:e})}var Iz={kernelName:ki,backendName:"webgl",kernelFunc:Cz};function wnt(r){let{inputs:t,backend:e,attrs:n}=r,{axis:o}=n;if(t.length===1)return pv({inputs:{input:t[0]},backend:e,attrs:{dim:o}});let s=t[0].shape,i=t[0].dtype;t.forEach(c=>{x.assertShapesMatch(s,c.shape,"All tensors passed to stack must have matching shapes"),x.assert(i===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});let a=[],u=t.map(c=>{let p=pv({inputs:{input:c},backend:e,attrs:{dim:o}});return a.push(p),p}),l=ST({inputs:u,backend:e,attrs:{axis:o}});return a.forEach(c=>e.disposeIntermediateTensorInfo(c)),l}var Sz={kernelName:Ni,backendName:"webgl",kernelFunc:wnt};var _v=class{constructor(t,e,n){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map((l,c)=>l[0]+t[c]+l[1]);let o=t.length,s=Vt(o),i=e.map(l=>l[0]).join(","),a=e.map((l,c)=>l[0]+t[c]).join(","),u=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,o);if(o===1){this.userCode=`
        int start = ${i};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${s} start = ${s}(${i});
      ${s} end = ${s}(${a});

      void main() {
        ${s} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${s} coords = outC - start;
          setOutput(getX(${u}));
        }
      }
    `}};var Ev=class{constructor(t,e,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map((h,g)=>h[0]+t[g]+h[1]);let o=t.length,s=Vt(o),i=e.map(h=>h[0]).join(","),a=e.map((h,g)=>h[0]+t[g]).join(","),u=nr("rc",o),l=nr("source",o),c=`${u[o-1]} < ${this.outputShape[o-1]}`,p=o===1?"source":`vec2(${l.slice(-2).join()})`,m=[`${s} rc = outputLoc;`,`${u[o-1]} += 1;
       if(${c}) {
      `,o===1?"":`}
       rc = outputLoc;
       ${u[o-2]} += 1;
       if(${u[o-2]} < ${this.outputShape[o-2]}) {`,o===1?"":`  ${u[o-1]} += 1;
         if(${c}) {`],f=o===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))",d="";for(let h=0,g=o===1?2:4;h<g;h++)d+=`
        ${m[h]}
        if (${f}) {
          result[${h}] = float(value);
        } else {
          ${s} source = rc - start;
          result[${h}] = getChannel(getX(${l.join()}), ${p});
        }
      `;d+=o===1?"} ":"}}",this.userCode=`
      const ${s} start = ${s}(${i});
      const ${s} end = ${s}(${a});

      void main() {
        ${s} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${d}
        setOutput(result);
      }
    `}};var $T=r=>{let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{paddings:s,constantValue:i}=n;if(x.sizeFromShape(o.shape)===0){let l=s.map((c,p)=>c[0]+o.shape[p]+c[1]);return Sl({backend:e,attrs:{shape:l,value:i,dtype:o.dtype}})}let a=V().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Ev(o.shape,s,i):new _v(o.shape,s,i),u=[[i]];return e.runWebGLProgram(a,[o],o.dtype,u)},kz={kernelName:Ns,backendName:"webgl",kernelFunc:$T};var vnt=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,Cnt=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));
  `+wu+`
  return result;
`,Int=le({opSnippet:vnt,packedOpSnippet:Cnt}),Nz={kernelName:Ts,backendName:"webgl",kernelFunc:Int};function Snt(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,keepDims:i}=n,a=o.shape.length,u=[],l=x.parseAxisParam(s,o.shape),c=l,p=S.getAxesPermutation(c,a),m=o;p!=null&&(m=Ae({inputs:{x:o},backend:e,attrs:{perm:p}}),c=S.getInnerMostAxes(c.length,a),u.push(m)),S.assertAxesAreInnerMostDims("prod",c,a);let f;if(e.shouldExecuteOnCPU([m])){let d=e.texData.get(m.dataId).values,{outVals:h,outShape:g,outDtype:y}=dP(m.shape,m.dtype,d,c);f=e.makeTensorInfo(g,y,h)}else{let[d,h]=S.computeOutAndReduceShapes(m.shape,c),g=x.sizeFromShape(h),y=ut({inputs:{x:m},backend:e,attrs:{shape:[-1,g]}}),b=Wu(o.dtype),w=Hn(y,b,"prod",e);f=ut({inputs:{x:w},backend:e,attrs:{shape:d}}),u.push(y),u.push(w)}if(i){u.push(f);let d=S.expandShapeToKeepDim(f.shape,l);f=ut({inputs:{x:f},backend:e,attrs:{shape:d}})}return u.forEach(d=>e.disposeIntermediateTensorInfo(d)),f}var Tz={kernelName:Aa,backendName:"webgl",kernelFunc:Snt};var DT=r=>{let{backend:t,attrs:e}=r,{start:n,stop:o,step:s,dtype:i}=e,a=hP(n,o,s,i);return t.makeTensorInfo([a.length],i,a)},_z={kernelName:Ll,backendName:"webgl",kernelFunc:DT};var knt="return 1.0 / x;",Nnt=Ct({opSnippet:knt}),Ez={kernelName:$a,backendName:"webgl",kernelFunc:Nnt};var Tnt=hr+`
  return (x < 0.0) ? 0.0 : x;
`,_nt=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Ent=Ct({opSnippet:Tnt,packedOpSnippet:_nt}),Az={kernelName:Es,backendName:"webgl",kernelFunc:Ent};var Ant=hr+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,$nt=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Dnt=Ct({opSnippet:Ant,packedOpSnippet:$nt}),$z={kernelName:$s,backendName:"webgl",kernelFunc:Dnt};var Av=class{constructor(t,e,n,o,s){this.variableNames=["A"],this.outputShape=[];let[i,a,u,l]=t;this.outputShape=[i,e,n,l];let c=[o&&e>1?a-1:a,o&&n>1?u-1:u],p=[o&&e>1?e-1:e,o&&n>1?n-1:n],m;s?m="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":m="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${c[0]/p[0]},
          ${c[1]/p[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${u}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${m};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}};var $v=class{constructor(t,e,n,o,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[i,a,u,l]=t;this.outputShape=[i,e,n,l];let c=[o&&e>1?a-1:a,o&&n>1?u-1:u],p=[o&&e>1?e-1:e,o&&n>1?n-1:n],m;s?m="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":m="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${c[0]/p[0]},
          ${c[1]/p[1]},
          ${c[1]/p[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${u}.0,
                                     ${u}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${m};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${l-1};
        bool hasNextRow = coords.z < ${n-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}};function Rnt(r){let{inputs:t,backend:e,attrs:n}=r,{images:o}=t,{alignCorners:s,halfPixelCenters:i,size:a}=n,[u,l]=a,c=V().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new $v(o.shape,u,l,s,i):new Av(o.shape,u,l,s,i);return e.runWebGLProgram(c,[o],"float32")}var Dz={kernelName:As,backendName:"webgl",kernelFunc:Rnt};var Dv=class{constructor(t,e,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;let[,o,s]=e,[,i,a]=t,u=[n&&i>1?o-1:o,n&&a>1?s-1:s],l=[n&&i>1?i-1:i,n&&a>1?a-1:a],c=u[0]/l[0],p=u[1]/l[1],m=1/c,f=1/p,d=Math.ceil(m)*2+2,h=Math.ceil(f)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${c});
        const float widthScale = float(${p});

        const float invHeightScale = float(${m});
        const float invWidthScale = float(${f});

        const int winHeight = int(${d});
        const int winWidth = int(${h});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${i}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${o-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${s-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};function Fnt(r){let{inputs:t,backend:e,attrs:n}=r,{images:o,dy:s}=t,{alignCorners:i}=n,a=new Dv(s.shape,o.shape,i);return e.runWebGLProgram(a,[s],s.dtype)}var Rz={kernelName:Zp,backendName:"webgl",kernelFunc:Fnt};var Rv=class{constructor(t,e,n,o,s){this.variableNames=["A"],this.outputShape=[];let[i,a,u,l]=t;this.outputShape=[i,e,n,l];let c=[o&&e>1?a-1:a,o&&n>1?u-1:u],p=[o&&e>1?e-1:e,o&&n>1?n-1:n],m=o?"0.5":"0.0",f;s?f="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":f="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${c[0]/p[0]},
          ${c[1]/p[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${u}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${f};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${m})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}};var Fv=class{constructor(t,e,n,o,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[i,a,u,l]=t;this.outputShape=[i,e,n,l];let c=[o&&e>1?a-1:a,o&&n>1?u-1:u],p=[o&&e>1?e-1:e,o&&n>1?n-1:n],m=o?"0.5":"0.0",f;s?f="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":f="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${c[0]/p[0]},
          ${c[1]/p[1]},
          ${c[1]/p[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${u}.0,
                                     ${u}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${f};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${m})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${l-1};
        bool hasNextRow = coords.z < ${n-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}};function Ont(r){let{inputs:t,backend:e,attrs:n}=r,{images:o}=t,{alignCorners:s,halfPixelCenters:i,size:a}=n,[u,l]=a,c=V().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new Fv(o.shape,u,l,s,i):new Rv(o.shape,u,l,s,i);return e.runWebGLProgram(c,[o],o.dtype)}var Fz={kernelName:zl,backendName:"webgl",kernelFunc:Ont};var Ov=class{constructor(t,e,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;let[,o,s]=e,[,i,a]=t,u=[n&&i>1?o-1:o,n&&a>1?s-1:s],l=[n&&i>1?i-1:i,n&&a>1?a-1:a],c=u[0]/l[0],p=u[1]/l[1],m=1/c,f=1/p,d=Math.ceil(m)*2+2,h=Math.ceil(f)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${c});
        const float widthScale = float(${p});

        const float invHeightScale = float(${m});
        const float invWidthScale = float(${f});

        const int winHeight = int(${d});
        const int winWidth = int(${h});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${i}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float sourceFracRow =
              float(${u[0]}) *
                (float(dyR) / float(${l[0]}));

            float sourceFracCol =
                float(${u[1]}) *
                  (float(dyC) / float(${l[1]}));

            int sourceNearestRow = int(min(
                float(int(${o}) - 1),
                ${n} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${s}) - 1),
                ${n} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};function Mnt(r){let{inputs:t,backend:e,attrs:n}=r,{images:o,dy:s}=t,{alignCorners:i}=n,a=new Ov(s.shape,o.shape,i);return e.runWebGLProgram(a,[s],s.dtype)}var Oz={kernelName:Yp,backendName:"webgl",kernelFunc:Mnt};var Mv=class{constructor(t,e){this.variableNames=["x"];let n=t.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=t,n===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${t[0]} - coord - 1));
        }
      `;return}let o=a=>e.indexOf(a)!==-1&&t[a]!==1?`${t[a]} - coords[${a}] - 1`:`coords[${a}]`,s=t.map((a,u)=>o(u)).join(","),i=Vt(n);this.userCode=`
      void main() {
        ${i} coords = getOutputCoords();
        setOutput(getX(${s}));
      }
    `}};var Pv=class{constructor(t,e){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;let n=t.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=t;let o=nr("rc",n),s=`${o[n-1]} + 1 < ${this.outputShape[n-1]}`,i=`${o[n-2]} + 1 < ${this.outputShape[n-2]}`,a=Vt(n);n===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${t[0]} - rc - 1),
            ${t[0]} - rc - 1);
          if(${s}){
              result.g = getChannel(getX(${t[0]} - (rc  + 1) - 1),
                ${t[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${a} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${u(o.slice())};
          if(${s}){
            result.g = ${l(o.slice())};
          }
          if(${i}) {
            result.b = ${c(o.slice())};
            if(${s}) {
              result.a = ${p(o.slice())};
            }
          }
          setOutput(result);
        }
    `;function u(d){return m(d)}function l(d){return d[n-1]="("+d[n-1]+" + 1)",m(d)}function c(d){return d[n-2]="("+d[n-2]+" + 1)",m(d)}function p(d){return d[n-1]="("+d[n-1]+" + 1)",d[n-2]="("+d[n-2]+" + 1)",m(d)}function m(d){let h=t.map((b,w)=>f(w,d)),g=h.join(","),y=h.slice(-2).join(",");return`getChannel(getX(${g}), vec2(${y}))`}function f(d,h){return e.indexOf(d)!==-1&&t[d]!==1?`${t[d]} - ${h[d]} - 1`:`${h[d]}`}}};function Pnt(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{dims:s}=n,i=o.shape.length,a=x.parseAxisParam(s,o.shape);if(i===0)return Ke({inputs:{x:o},backend:e});let u=V().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Pv(o.shape,a):new Mv(o.shape,a);return e.runWebGLProgram(u,[o],o.dtype)}var Mz={kernelName:Ds,backendName:"webgl",kernelFunc:Pnt};var Lv=class{constructor(t,e){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];let n=t[1],o=t[2];this.outputShape=t;let s="";typeof e=="number"?s=`float outputValue = ${e.toFixed(2)};`:s=`
        vec3 fill = vec3(${e.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${s}
          if(coordX >= 0 && coordX < ${o} && coordY >= 0 && coordY < ${n}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}};var Pz={kernelName:Va,backendName:"webgl",kernelFunc:({inputs:r,attrs:t,backend:e})=>{let{image:n}=r,{radians:o,fillValue:s,center:i}=t,a=e,u=new Lv(n.shape,s),[l,c]=S.getImageCenter(i,n.shape[1],n.shape[2]),p=[[l,c,Math.sin(o),Math.cos(o)]];return a.runWebGLProgram(u,[n],n.dtype,p)}};var Lnt=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,znt=Ct({opSnippet:Lnt}),Lz={kernelName:Rs,backendName:"webgl",kernelFunc:znt};var Bnt="return inversesqrt(x);",Vnt=Ct({opSnippet:Bnt,cpuKernelImpl:gP}),zz={kernelName:Fs,backendName:"webgl",kernelFunc:Vnt};var Sd=class{constructor(t,e,n,o,s,i,a=!0){this.variableNames=["updates","indices","defaultValue"],this.outputShape=i;let u=Vt(s.length),l=Vt(i.length),c="";n===1?c="i":n===2&&(c="i, j");let p=`getIndices(${c})`,m="";o===1?m="i":o===2&&(m="i, coords[1]");let f=`getUpdates(${m})`,d=e>1?"strides[j]":"strides";this.userCode=`
        ${u} strides = ${u}(${s});

        void main() {
          ${l} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${t}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${e}; j++) {
              int index = round(${p});
              flattenedIndex += index * ${d};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${f};
              found = true;
            }
          }
          setOutput(mix(getDefaultValue(), sum, float(found)));
        }
      `}};function Gnt(r){let{inputs:t,backend:e,attrs:n}=r,{indices:o,updates:s}=t,{shape:i}=n,{sliceRank:a,numUpdates:u,sliceSize:l,strides:c,outputSize:p}=S.calculateShapes(s,o,i),m=[p/l,l];if(p===0)return e.makeTensorInfo(i,o.dtype);let f=ut({inputs:{x:o},backend:e,attrs:{shape:[u,a]}}),d=ut({inputs:{x:s},backend:e,attrs:{shape:[u,l]}}),h=e.makeTensorInfo([],"float32",new Float32Array([0])),g=new Sd(u,a,f.shape.length,d.shape.length,c,m),y=e.runWebGLProgram(g,[d,f,h],d.dtype),b=ut({inputs:{x:y},backend:e,attrs:{shape:i}});return e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(h),b}var Bz={kernelName:Da,backendName:"webgl",kernelFunc:Gnt};var zv=class{constructor(t,e,n){this.variableNames=["c","a","b"],this.outputShape=e;let o,s;if(n>4)throw Error(`Where for rank ${n} is not yet supported`);if(n===1)s="resRC",o="resRC";else{let a=["resRC.x","resRC.y","resRC.z","resRC.w"],u=[],l=[];for(let c=0;c<e.length;c++)l.push(`${a[c]}`),c<t&&u.push(`${a[c]}`);o=u.join(),s=l.join()}let i=Vt(n);this.userCode=`
      void main() {
        ${i} resRC = getOutputCoords();
        float cVal = getC(${o});
        if (cVal >= 1.0) {
          setOutput(getA(${s}));
        } else {
          setOutput(getB(${s}));
        }
      }
    `}};function Wnt(r){let{inputs:t,backend:e}=r,{condition:n,t:o,e:s}=t,i=new zv(n.shape.length,o.shape,o.shape.length);return e.runWebGLProgram(i,[n,o,s],ar(o.dtype,s.dtype))}var Vz={kernelName:_i,backendName:"webgl",kernelFunc:Wnt};var Unt=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${S.SELU_SCALEALPHA};
  float scale = ${S.SELU_SCALE};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,Hnt=Ct({opSnippet:Unt}),Gz={kernelName:Ra,backendName:"webgl",kernelFunc:Hnt};var qnt=Lo+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,Knt=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,jnt=Ct({opSnippet:qnt,packedOpSnippet:Knt,cpuKernelImpl:xP}),Wz={kernelName:Ms,backendName:"webgl",kernelFunc:jnt};var Xnt=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,Ynt=Ct({opSnippet:Xnt}),Uz={kernelName:Oa,backendName:"webgl",kernelFunc:Ynt};var Znt=Lo+`
  return sin(x);
`,Jnt=Ct({opSnippet:Znt}),Hz={kernelName:Os,backendName:"webgl",kernelFunc:Jnt};var Qnt=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,tot=Ct({opSnippet:Qnt}),qz={kernelName:Fa,backendName:"webgl",kernelFunc:tot};var eot=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,rot=Ct({opSnippet:eot}),Kz={kernelName:Ma,backendName:"webgl",kernelFunc:rot};var not=r=>{let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{blockShape:s,paddings:i}=n;x.assert(o.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");let a=s.reduce((y,b)=>y*b),u=[[0,0]];u.push(...i);for(let y=1+s.length;y<o.shape.length;++y)u.push([0,0]);let l=[],c=$T({inputs:{x:o},backend:e,attrs:{paddings:u,constantValue:0}}),p=S.getReshaped(c.shape,s,a,!1),m=S.getPermuted(p.length,s.length,!1),f=S.getReshapedPermuted(c.shape,s,a,!1),d=ut({inputs:{x:c},backend:e,attrs:{shape:p}}),h=Ae({inputs:{x:d},backend:e,attrs:{perm:m}}),g=ut({inputs:{x:h},backend:e,attrs:{shape:f}});return l.push(c),l.push(d),l.push(h),l.forEach(y=>e.disposeIntermediateTensorInfo(y)),g},jz={kernelName:Ai,backendName:"webgl",kernelFunc:not};function oot(r){let{inputs:t,backend:e}=r,{indices:n,values:o,denseShape:s,defaultValue:i}=t;if(s.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${s.shape}`);if(n.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${n.shape}`);if(o.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${o.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);let a=e.readSync(n.dataId),u=e.readSync(o.dataId),l=e.readSync(s.dataId),c=e.readSync(i.dataId)[0],[p,m,f,d,h]=bP(a,n.shape,n.dtype,u,o.dtype,l,c);return[e.makeTensorInfo(m,n.dtype,p),e.makeTensorInfo([m[0]],o.dtype,f),e.makeTensorInfo([d.length],"bool",new Uint8Array(d.map(g=>Number(g)))),e.makeTensorInfo([h.length],n.dtype,new Int32Array(h))]}var Xz={kernelName:Bl,backendName:"webgl",kernelFunc:oot};function sot(r){let{inputs:t,backend:e}=r,{inputIndices:n,inputShape:o,newShape:s}=t;if(n.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${n.shape}`);if(o.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${o.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let i=Array.from(e.readSync(o.dataId)),a=e.readSync(n.dataId),u=Array.from(e.readSync(s.dataId)),[l,c,p]=wP(a,n.shape,n.dtype,i,u);return[e.makeTensorInfo(c,n.dtype,l),e.makeTensorInfo([p.length],s.dtype,new Int32Array(p))]}var Yz={kernelName:Pa,backendName:"webgl",kernelFunc:sot};function iot(r){let{inputs:t,backend:e}=r,{data:n,indices:o,segmentIds:s}=t;if(n.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${o.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${s.shape}`);let i=e.readSync(n.dataId),a=e.readSync(o.dataId),u=e.readSync(s.dataId),[l,c]=Sw(i,n.shape,n.dtype,a,u,!0);return e.makeTensorInfo(c,n.dtype,l)}var Zz={kernelName:Vl,backendName:"webgl",kernelFunc:iot};function aot(r){let{inputs:t,backend:e}=r,{data:n,indices:o,segmentIds:s}=t;if(n.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${o.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${s.shape}`);let i=e.readSync(n.dataId),a=e.readSync(o.dataId),u=e.readSync(s.dataId),[l,c]=Sw(i,n.shape,n.dtype,a,u);return e.makeTensorInfo(c,n.dtype,l)}var Jz={kernelName:Gl,backendName:"webgl",kernelFunc:aot};function lot(r){let{inputs:t,backend:e,attrs:n}=r,{sparseIndices:o,sparseValues:s,defaultValue:i}=t,{outputShape:a}=n,{sliceRank:u,numUpdates:l,strides:c,outputSize:p}=S.calculateShapes(s,o,a),m=!1,f=new Sd(l,u,o.shape.length,s.shape.length,c,[p,1],m),d=e.runWebGLProgram(f,[s,o,i],s.dtype),h=ut({inputs:{x:d},backend:e,attrs:{shape:a}});return e.disposeIntermediateTensorInfo(d),h}var Qz={kernelName:Jp,backendName:"webgl",kernelFunc:lot};function uot(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{numOrSizeSplits:s,axis:i}=n,a=x.parseAxisParam(i,o.shape)[0],u=S.prepareSplitSize(o,s,a),l=o.shape.length,c=new Array(l).fill(0),p=o.shape.slice();return u.map(m=>{let f=[...p];f[a]=m;let d=gi({inputs:{x:o},backend:e,attrs:{begin:c,size:f}});return c[a]+=m,d})}var tB={kernelName:$i,backendName:"webgl",kernelFunc:uot};var eB="return sqrt(x);",cot=Ct({opSnippet:eB,packedOpSnippet:eB,cpuKernelImpl:vP}),rB={kernelName:Ps,backendName:"webgl",kernelFunc:cot};var pot="return x * x;",mot=Ct({opSnippet:pot}),nB={kernelName:Wl,backendName:"webgl",kernelFunc:mot};var oB="return (a - b) * (a - b);",fot=le({opSnippet:oB,packedOpSnippet:oB}),sB={kernelName:Bs,backendName:"webgl",kernelFunc:fot};function dot({inputs:r,attrs:t,backend:e}){let{x:n}=r,o=hr+`
    return x > 0.0 ? 1.0 : float(${t.alpha});
  `,s=new en(n.shape,o);return e.runWebGLProgram(s,[n],n.dtype)}var iB={kernelName:uo,backendName:"webgl",kernelFunc:dot};var Bv=class{constructor(t,e,n){this.variableNames=["x"],this.outputShape=n;let o=n.length,s=Vt(n.length),i=Vt(n.length),a="";if(o===1)a="coords * strides + begin";else{let u=0;a=n.map((l,c)=>(u++,n.length===1?`coords * strides[${c}] + begin[${c}]`:`coords[${u-1}] * strides[${c}] + begin[${c}]`)).join(",")}this.userCode=`
      ${s} begin = ${s}(${t});
      ${s} strides = ${s}(${e});

      void main() {
        ${i} coords = getOutputCoords();
        setOutput(getX(${a}));
      }
    `}};function hot(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{begin:s,end:i,strides:a,beginMask:u,endMask:l,ellipsisMask:c,newAxisMask:p,shrinkAxisMask:m}=n,{finalShapeSparse:f,finalShape:d,isIdentity:h,sliceDim0:g,isSimpleSlice:y,begin:b,end:w,strides:v}=Ve.sliceInfo(o.shape,s,i,a,u,l,c,p,m),k;if(h)k=ut({inputs:{x:o},backend:e,attrs:{shape:d}});else if(g||y){x.assert(o.shape.length>=1,()=>`Input must have rank at least 1, got: ${o.shape.length}`);let $=Ve.computeOutShape(b,w,v),D=gi({inputs:{x:o},backend:e,attrs:{begin:b,size:$}});k=ut({inputs:{x:D},backend:e,attrs:{shape:d}}),e.disposeIntermediateTensorInfo(D)}else if(e.shouldExecuteOnCPU([o])){let D=e.readSync(o.dataId),R=It(o.shape,o.dtype,D),P=CP(f,R,v,b);k=e.makeTensorInfo(d,o.dtype,P.values)}else{let D=new Bv(b,v,f);k=e.runWebGLProgram(D,[o],o.dtype)}let E=ut({inputs:{x:k},backend:e,attrs:{shape:d}});return e.disposeIntermediateTensorInfo(k),E}var aB={kernelName:La,backendName:"webgl",kernelFunc:hot};function got(r){let{inputs:t,backend:e,attrs:n}=r,{separator:o,nGramWidths:s,leftPad:i,rightPad:a,padWidth:u,preserveShortSequences:l}=n,{data:c,dataSplits:p}=t,m=e.readSync(c.dataId),f=e.readSync(p.dataId),[d,h]=IP(m,f,o,s,i,a,u,l);return[e.makeTensorInfo([d.length],"string",d),e.makeTensorInfo(p.shape,"int32",h)]}var lB={kernelName:Qp,backendName:"webgl",kernelFunc:got};function xot(r){let{inputs:t,backend:e,attrs:n}=r,{skipEmpty:o}=n,{input:s,delimiter:i}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(s.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);let a=e.readSync(s.dataId),u=e.readSync(i.dataId)[0],[l,c,p]=SP(a,u,o),m=c.length;return[e.makeTensorInfo([m,2],"int32",l),e.makeTensorInfo([m],"string",c),e.makeTensorInfo([2],"int32",new Int32Array(p))]}var uB={kernelName:tm,backendName:"webgl",kernelFunc:xot};function yot(r){let{inputs:t,backend:e,attrs:n}=r,{numBuckets:o}=n,{input:s}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(o<=0)throw new Error("Number of buckets must be at least 1");let i=e.readSync(s.dataId),a=kP(i,o);return e.makeTensorInfo(s.shape,"int32",a)}var cB={kernelName:em,backendName:"webgl",kernelFunc:yot};var bot="return tan(x);",wot=Ct({opSnippet:bot}),pB={kernelName:Gs,backendName:"webgl",kernelFunc:wot};var vot=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,Cot=Ct({opSnippet:vot}),mB={kernelName:Ws,backendName:"webgl",kernelFunc:Cot};var Vv=class{constructor(t,e){this.variableNames=["A"];let n=new Array(t.length);for(let i=0;i<n.length;i++)n[i]=t[i]*e[i];this.outputShape=n,this.rank=n.length;let o=Vt(this.rank),s=Iot(t);this.userCode=`
      void main() {
        ${o} resRC = getOutputCoords();
        setOutput(getA(${s}));
      }
    `}};function Iot(r){let t=r.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(t===1)return`imod(resRC, ${r[0]})`;let e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],n=[];for(let o=0;o<r.length;o++)n.push(`imod(${e[o]}, ${r[o]})`);return n.join()}function RT(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{reps:s}=n;if(o.dtype==="string"||o.shape.length>5){let u=e.readSync(o.dataId),l=o.dtype==="string"?u.map(m=>x.decodeString(m)):u,c=It(o.shape,o.dtype,l),p=TP(c,s);return e.makeTensorInfo(p.shape,p.dtype,p.values)}let i=new Vv(o.shape,s);return e.runWebGLProgram(i,[o],o.dtype)}var fB={kernelName:Yn,backendName:"webgl",kernelFunc:RT};var Gv=class{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=t,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}},Wv=class{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=t,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}};function sp(r,t){t!==null&&r.disposeIntermediateTensorInfo(t)}function dB(r){let t=1;for(;t<r;)t*=2;return t}function Sot(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{k:s,sorted:i}=n,a=V().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),u=V().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),l=o.shape,c=l[l.length-1];if(e.shouldExecuteOnCPU([o])||c<a||s>u){let P=e.readSync(o.dataId),[W,U]=_P(P,l,o.dtype,s,i);return[e.makeTensorInfo(W.shape,W.dtype,W.values),e.makeTensorInfo(U.shape,U.dtype,U.values)]}if(s===0)return l[l.length-1]=0,[e.makeTensorInfo(l,o.dtype,[]),e.makeTensorInfo(l,"int32",[])];if(c===1)return[o,Sl({attrs:{shape:l,dtype:"int32",value:0},backend:e})];let p=e.texData.get(o.dataId),m=p!==null&&p.isPacked,f=m?e.unpackTensor(o):o,h=x.sizeFromShape(l)/c,g=ut({inputs:{x:f},attrs:{shape:[h,c]},backend:e});m&&sp(e,f);let y=dB(s),b=dB(c),w=null,v=()=>w===null?[g,g]:[g,w],k=(P,W,U)=>{let q=v(),K=new Gv(U),Q=[[c],[w===null?1:0],[Number.NEGATIVE_INFINITY],[P],[W]],rt=w;w=e.runWebGLProgram(K,q,"int32",Q),sp(e,rt)};for(let P=1;P<y;P*=2){let W=P*2;for(let U=P;U>=1;U/=2)k(W,U,[h,b])}for(let P=b;P>y;P/=2){let W=v(),U=new Wv([h,P/2]),K=[[c],[w===null?1:0],[y]],j=w;w=e.runWebGLProgram(U,W,"int32",K),sp(e,j);let Q=y/2,rt=Q*2;for(let X=Q;X>=1;X/=2)k(rt,X,w.shape)}let E=w;w=gi({inputs:{x:w},backend:e,attrs:{begin:0,size:[h,s]}}),sp(e,E);let $=NT({inputs:{x:g,indices:w},backend:e,attrs:{axis:1,batchDims:1}});sp(e,g);let D=l.slice(0,-1);D.push(s),E=w,w=ut({inputs:{x:w},attrs:{shape:D},backend:e}),sp(e,E);let R=$;return $=ut({inputs:{x:$},attrs:{shape:D},backend:e}),sp(e,R),[$,w]}var hB={kernelName:za,backendName:"webgl",kernelFunc:Sot};var Uv=class{constructor(t,e,n,o,s,i){this.variableNames=["Image","Transforms"],this.outputShape=i;let a=n==="nearest"?1:2,u;switch(o){case"constant":u=1;break;case"reflect":u=2;break;case"wrap":u=3;break;case"nearest":u=4;break;default:u=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${u} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${u} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${u} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${t} && 0 <= coordX && coordX < ${e}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${s});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${s});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${e}));
                float mapY = mapCoord(inY, float(${t}));

                if (${a} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}};function kot(r){let{inputs:t,backend:e,attrs:n}=r,{image:o,transforms:s}=t,{interpolation:i,fillMode:a,fillValue:u,outputShape:l}=n,[c,p,m,f]=o.shape,[d,h]=l!=null?l:[p,m],g=[c,d,h,f],y=new Uv(p,m,i,a,u,g);return e.runWebGLProgram(y,[o,s],"float32")}var gB={kernelName:Ba,backendName:"webgl",kernelFunc:kot};function Not(r){let{inputs:t,attrs:e,backend:n}=r,{axis:o}=e,{x:s}=t;fi(s,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");let i=n.readSync(s.dataId),{outputValues:a,outputShape:u,indices:l}=EP(i,o,s.shape,s.dtype);return[n.makeTensorInfo(u,s.dtype,a),n.makeTensorInfo([l.length],"int32",l)]}var xB={kernelName:rm,backendName:"webgl",kernelFunc:Not};function Tot(r){let{inputs:t,backend:e,attrs:n}=r,{value:o}=t,{axis:s}=n;s<0&&(s+=o.shape.length);let i=o,a=i.shape.length,u=o.shape[s],l=new Array(a-1),c=0;for(let h=0;h<a;h++)h!==s&&(l[c++]=i.shape[h]);let p=[],m=new Array(a).fill(0),f=i.shape.slice();f[s]=1;let d=new Array(u);for(let h=0;h<d.length;h++){m[s]=h;let g=gi({inputs:{x:i},backend:e,attrs:{begin:m,size:f}}),y=ut({inputs:{x:g},backend:e,attrs:{shape:l}});d[h]=y,p.push(g)}return p.forEach(h=>e.disposeIntermediateTensorInfo(h)),d}var yB={kernelName:Di,backendName:"webgl",kernelFunc:Tot};var Hv=class{constructor(t,e){this.variableNames=["x","segmentIds"];let n=t.windowSize,o=t.batchSize,s=t.inSize,i=t.numSegments,a=i*Math.ceil(s/n);this.outputShape=[o,a];let u="0.0",l="sumValue",c=Math.floor(n/4)*4,p=n%4,m=`
        sumValue += dot(values, segFilter);
    `,f="";s%n>0&&(f=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return initializationValue;
        }
      `);let d="";s%n>0&&(d=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${u};

      float getValue(int batch, int inIdx) {
        ${f}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${d}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${i})) * float(${n}));
        int currentSeg = int(mod(float(outIdx), float(${i})));

        float sumValue = 0.0;

        for (int i = 0; i < ${c}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${m}
        }

        int inIdx = inOffset + ${c};
        if (${p===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${m}
        } else if (${p===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${m}
        } else if (${p===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${m}
        }
        setOutput(${l});
      }
    `}};function _ot(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,segmentIds:s}=t,{numSegments:i}=n,a=o.shape.length,u=[],l=0,c=S.getAxesPermutation([l],a),p=o;c!=null&&(p=Ae({inputs:{x:o},backend:e,attrs:{perm:c}}),u.push(p),l=S.getInnerMostAxes(1,a)[0]);let m=S.segment_util.computeOutShape(p.shape,l,i),f=x.sizeFromShape([p.shape[l]]),d=ut({inputs:{x:p},backend:e,attrs:{shape:[-1,f]}});u.push(d);let h=Wu(o.dtype),g=(v,k,E,$,D)=>{let R=v.shape[0],P=v.shape[1],W=S.segment_util.segOpComputeOptimalWindowSize(P,D),U={windowSize:W,inSize:P,batchSize:R,numSegments:D},q=new Hv(U,k),K=e.compileAndRun(q,[v,E],$);if(u.push(K),K.shape[1]===D)return K;let j=DT({backend:e,attrs:{start:0,stop:D,step:1,dtype:"float32"}}),Q=RT({inputs:{x:j},backend:e,attrs:{reps:[P/W]}});return u.push(j),u.push(Q),g(K,k,Q,$,D)},y=g(d,"unsortedSegmentSum",s,h,i),b=ut({inputs:{x:y},backend:e,attrs:{shape:m}}),w=b;if(c!=null){u.push(b);let v=S.getUndoAxesPermutation(c);w=Ae({inputs:{x:w},backend:e,attrs:{perm:v}})}return u.forEach(v=>e.disposeIntermediateTensorInfo(v)),w}var bB={kernelName:Ul,backendName:"webgl",kernelFunc:_ot};var Eot=[iL,lL,uL,cL,mL,fL,dL,hL,yL,bL,wL,vL,CL,IL,SL,kL,NL,TL,_L,EL,AL,DL,RL,FL,LL,BL,VL,jP,WL,HL,qL,KL,jL,XL,YL,ZL,JL,QL,t3,n3,i3,a3,l3,u3,c3,p3,m3,f3,d3,h3,g3,x3,y3,b3,w3,C3,I3,S3,k3,T3,_3,E3,A3,$3,D3,R3,F3,O3,KP,M3,UL,P3,L3,z3,XP,B3,V3,G3,W3,U3,H3,q3,K3,j3,X3,Z3,J3,Q3,tz,ez,rz,oz,iz,az,lz,uz,cz,hz,tL,gz,xz,yz,bz,OL,wz,Iz,Sz,kz,Nz,YP,Tz,_z,ML,pz,Ez,Az,$z,rL,Dz,Rz,Fz,Oz,Mz,Pz,Lz,zz,Bz,Vz,Gz,Wz,Uz,Hz,qz,$L,dz,Kz,jz,Xz,Yz,Zz,Jz,Qz,tB,rB,nB,sB,iB,aB,lB,uB,cB,fz,oL,pB,mB,fB,hB,gB,sL,xB,yB,bB,vz];for(let r of Eot)Pu(r);var Xt;(function(r){r[r.float32=0]="float32",r[r.int32=1]="int32",r[r.bool=2]="bool",r[r.string=3]="string",r[r.complex64=4]="complex64"})(Xt||(Xt={}));var Su;(function(r){r[r.linear=0]="linear",r[r.relu=1]="relu",r[r.relu6=2]="relu6",r[r.prelu=3]="prelu",r[r.leakyrelu=4]="leakyrelu",r[r.sigmoid=5]="sigmoid",r[r.elu=6]="elu"})(Su||(Su={}));var wB;function Aot(r){wB=r.wasm.cwrap(Fi,null,["number","array","number","number","array","number","number","number","number","number","number","number","number"])}function $ot(r){let{inputs:t,backend:e,attrs:n}=r,{a:o,b:s,bias:i,preluActivationWeights:a}=t;if(o.dtype!=="float32"||s.dtype!=="float32")throw new Error("_FusedMatMul for non non-float32 tensors not yet supported.");let{transposeA:u,transposeB:l,activation:c,leakyreluAlpha:p}=n,m=e.dataIdMap.get(o.dataId).id,f=e.dataIdMap.get(s.dataId).id,d=0;if(i!=null){let D=e.dataIdMap.get(i.dataId);if(D.shape.length!==1)throw new Error(`_FusedMatMul only supports rank-1 bias but got rank ${D.shape.length}.`);d=D.id}let h=a==null?0:e.dataIdMap.get(a.dataId).id,g=Su[c];if(g==null)throw new Error(`${c} activation not yet supported for FusedConv2D in the wasm backend.`);let y=u?o.shape[2]:o.shape[1],b=l?s.shape[1]:s.shape[2],w=Pr.assertAndGetBroadcastShape(o.shape.slice(0,-2),s.shape.slice(0,-2)),v=e.makeOutput([...w,y,b],o.dtype),k=e.dataIdMap.get(v.dataId).id,E=new Uint8Array(new Int32Array(o.shape).buffer),$=new Uint8Array(new Int32Array(s.shape).buffer);return wB(m,E,o.shape.length,f,$,s.shape.length,u,l,g,d,h,p||0,k),v}var vB={kernelName:Fi,backendName:"wasm",setupFunc:Aot,kernelFunc:$ot};function ue(r,t){let e;function n(s){e=s.wasm.cwrap(r,null,["number","number","number"])}function o(s){let{backend:i,inputs:{x:a}}=s,u=i.dataIdMap.get(a.dataId).id,l=i.makeOutput(a.shape,t||a.dtype),c=i.dataIdMap.get(l.dataId).id;return x.sizeFromShape(l.shape)===0||e(u,Xt[a.dtype],c),l}return{kernelName:r,backendName:"wasm",setupFunc:n,kernelFunc:o}}var CB=ue(bi);function Ie(r,t,e){let n;function o(i){n=i.wasm.cwrap(r,null,["number","array","number","number","array","number","number","number"])}function s(i){let{backend:a,inputs:u}=i,{a:l,b:c}=u,p=a.dataIdMap.get(l.dataId).id,m=a.dataIdMap.get(c.dataId).id,f=e!=null?e:l.dtype,d=S.assertAndGetBroadcastShape(l.shape,c.shape),h=a.makeOutput(d,f);if(x.sizeFromShape(d)===0)return h;let g=new Uint8Array(new Int32Array(l.shape).buffer),y=new Uint8Array(new Int32Array(c.shape).buffer),b=a.dataIdMap.get(h.dataId).id;return(()=>n(p,g,l.shape.length,m,y,c.shape.length,Xt[l.dtype],b))(),h}return{kernelName:r,backendName:"wasm",setupFunc:o,kernelFunc:s}}var Dot=!0,IB=Ie(Xn,Dot);var SB;function Rot(r){SB=r.wasm.cwrap(Zo,null,["array","number","number","number"])}function Fot(r){let{inputs:t,backend:e}=r,n=e.makeOutput(t[0].shape,t[0].dtype);if(x.sizeFromShape(n.shape)===0)return n;let o=t.map(a=>e.dataIdMap.get(a.dataId).id),s=new Uint8Array(new Int32Array(o).buffer),i=e.dataIdMap.get(n.dataId).id;return SB(s,o.length,Xt[n.dtype],i),n}var kB={kernelName:Zo,backendName:"wasm",setupFunc:Rot,kernelFunc:Fot};function ip(r){let{inputs:{x:t},backend:e}=r,n=e.makeOutput(t.shape,t.dtype),o=e.typedArrayFromHeap(t);return e.typedArrayFromHeap(n).set(o),n}var NB={kernelName:lo,backendName:"wasm",kernelFunc:ip};var TB;function Oot(r){TB=r.wasm.cwrap(Us,null,["number","array","number","number","number","array","number"])}function no(r){let{inputs:t,backend:e,attrs:n}=r,[o,s]=Pot(t.x.shape,n.perm),i=!0;for(let d=0;d<s.length;d++)s[d]!==d&&(i=!1);let a=Mot(t.x.shape,n.perm),u={dataId:t.x.dataId,shape:o,dtype:t.x.dtype};if(i){let d=ip({inputs:t,backend:e});return d.shape=a,d}let l=e.makeOutput(a,u.dtype),c=e.dataIdMap.get(u.dataId).id,p=e.dataIdMap.get(l.dataId).id,m=new Uint8Array(new Int32Array(s).buffer),f=new Uint8Array(new Int32Array(u.shape).buffer);return TB(c,f,u.shape.length,Xt[u.dtype],p,m,s.length),l}function Mot(r,t){let e=new Array(r.length);for(let n=0;n<e.length;n++)e[n]=r[t[n]];return e}function Pot(r,t){let e=[],n=[];for(let o=0;o<r.length;++o)r[o]!==1&&e.push(r[o]),r[t[o]]!==1&&n.push(t[o]);for(let o=0;o<n.length;++o){let s=-1;for(let i=0;i<n.length;++i)n[i]>=o&&(s===-1||n[s]>n[i])&&(s=i);n[s]=o}return[e,n]}var _B={kernelName:Us,backendName:"wasm",kernelFunc:no,setupFunc:Oot};function Sn(r,t,e){let n=r.shape,o=r.shape.length,s=x.parseAxisParam(t,n),i=s,a=S.getAxesPermutation(i,o),u=null,l=!1;if(a!=null){let c=new Array(o);for(let f=0;f<c.length;f++)c[f]=n[a[f]];i=S.getInnerMostAxes(i.length,o),u=no({inputs:{x:r},attrs:{perm:a},backend:e});let p=e.dataIdMap.get(r.dataId).id;e.dataIdMap.get(u.dataId).id!==p&&(l=!0)}return{transposed:u,originalAxes:s,axes:i,inputWasTransposed:l}}var EB;function Lot(r){EB=r.wasm.cwrap(ra,null,["number, number, number"])}function zot(r){let{backend:t,inputs:e,attrs:n}=r,{axis:o,keepDims:s}=n,{x:i}=e,u=t.dataIdMap.get(i.dataId).id,l=i,{transposed:c,axes:p,originalAxes:m,inputWasTransposed:f}=Sn(i,o,t);if(f){let w=t.dataIdMap.get(c.dataId).id;l=c,u=w}let d=l.shape.length;S.assertAxesAreInnerMostDims("all",p,d);let[h,g]=S.computeOutAndReduceShapes(l.shape,p),y=x.sizeFromShape(g),b=t.makeOutput(h,i.dtype);if(x.sizeFromShape(l.shape)!==0){let w=t.dataIdMap.get(b.dataId).id;EB(u,y,w)}if(f&&t.disposeData(c.dataId),s){let w=S.expandShapeToKeepDim(b.shape,m);b.shape=w}return b}var AB={kernelName:ra,backendName:"wasm",setupFunc:Lot,kernelFunc:zot};var $B;function Bot(r){$B=r.wasm.cwrap(na,null,["number, number, number"])}function Vot(r){let{backend:t,inputs:e,attrs:n}=r,{axis:o,keepDims:s}=n,{x:i}=e,u=t.dataIdMap.get(i.dataId).id,l=i,{transposed:c,axes:p,originalAxes:m,inputWasTransposed:f}=Sn(i,o,t);if(f){let w=t.dataIdMap.get(c.dataId).id;l=c,u=w}let d=l.shape.length;S.assertAxesAreInnerMostDims("any",p,d);let[h,g]=S.computeOutAndReduceShapes(l.shape,p),y=x.sizeFromShape(g),b=t.makeOutput(h,i.dtype);if(x.sizeFromShape(l.shape)!==0){let w=t.dataIdMap.get(b.dataId).id;$B(u,y,w)}if(f&&t.disposeData(c.dataId),s){let w=S.expandShapeToKeepDim(b.shape,m);b.shape=w}return b}var DB={kernelName:na,backendName:"wasm",setupFunc:Bot,kernelFunc:Vot};var RB;function Got(r){RB=r.wasm.cwrap(Jo,null,["number","number","number","number","number"])}function Wot(r){let{backend:t,inputs:e,attrs:n}=r,{axis:o}=n,{x:s}=e,i=t.dataIdMap.get(s.dataId).id,a=i,u=s,{transposed:l,axes:c,inputWasTransposed:p}=Sn(s,o,t);if(p){let y=t.dataIdMap.get(l.dataId).id;y!==i&&(u=l,a=y)}let m=u.shape.slice(0,-1),f=t.makeOutput(m,"int32"),d=t.dataIdMap.get(f.dataId).id,h=x.sizeFromShape(f.shape),g=u.shape[c[0]];return RB(a,Xt[u.dtype],h,g,d),p&&t.disposeData(l.dataId),f}var FB={kernelName:Jo,backendName:"wasm",kernelFunc:Wot,setupFunc:Got};var OB;function Uot(r){OB=r.wasm.cwrap(Qo,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Hot(r){let{inputs:t,attrs:e,backend:n}=r,o=t.x,s=n.dataIdMap.get(o.dataId).id,{filterSize:i,strides:a,pad:u,dimRoundingMode:l}=e,c=S.computePool2DInfo(o.shape,i,a,1,u,l),p=c.filterHeight,m=c.filterWidth,f=c.padInfo.top,d=c.padInfo.right,h=c.padInfo.bottom,g=c.padInfo.left,y=c.strideHeight,b=c.strideWidth,w=c.inChannels;if(c.dataFormat!=="channelsLast")throw new Error(`wasm backend does not support dataFormat:'${c.dataFormat}'. Please use 'channelsLast'.`);if(c.dilationWidth!==1||c.dilationHeight!==1)throw new Error(`was backend only supports average pooling with dilation = [1, 1], got [${c.dilationHeight}, ${c.dilationWidth}].`);let v=n.makeOutput(c.outShape,"float32"),k=n.dataIdMap.get(v.dataId).id;return OB(s,o.shape[0],o.shape[1],o.shape[2],p,m,f,d,h,g,y,b,w,k),v}var MB={kernelName:Qo,backendName:"wasm",setupFunc:Uot,kernelFunc:Hot};function pr(r){let{inputs:t,attrs:e}=r,{x:n}=t,{shape:o}=e,s=x.sizeFromShape(n.shape),i=x.inferFromImplicitShape(o,s);return x.assert(s===x.sizeFromShape(i),()=>`new shape: ${i}, old shape: ${n.shape}. New shape and old shape must have the same number of elements.`),r.backend.incRef(n.dataId),{dataId:n.dataId,shape:i,dtype:n.dtype}}var PB={kernelName:Ti,backendName:"wasm",kernelFunc:pr};var LB;function qot(r){LB=r.wasm.cwrap(ts,null,["number","array","number","number","array","number","number","number","number"])}function Kot(r){let{inputs:t,backend:e,attrs:n}=r,{a:o,b:s}=t,{transposeA:i,transposeB:a}=n;if(o.dtype!=="float32"||s.dtype!=="float32")throw new Error("BatchMatMul for non non-float32 tensors not yet supported.");let u=o.shape.length,l=s.shape.length,c=i?o.shape[u-2]:o.shape[u-1],p=a?s.shape[l-1]:s.shape[l-2],m=i?o.shape[u-1]:o.shape[u-2],f=a?s.shape[l-2]:s.shape[l-1],d=o.shape.slice(0,-2),h=s.shape.slice(0,-2),g=x.sizeFromShape(d),y=x.sizeFromShape(h),w=Pr.assertAndGetBroadcastShape(o.shape.slice(0,-2),s.shape.slice(0,-2)).concat([m,f]);x.assert(c===p,()=>`Error in matMul: inner shapes (${c}) and (${p}) of Tensors with shapes ${o.shape} and ${s.shape} and transposeA=${i} and transposeB=${a} must match.`);let v=i?[g,c,m]:[g,m,c],k=a?[y,f,p]:[y,p,f],E=pr({inputs:{x:o},backend:e,attrs:{shape:v}}),$=pr({inputs:{x:s},backend:e,attrs:{shape:k}}),D=e.dataIdMap.get(E.dataId).id,R=e.dataIdMap.get($.dataId).id,P=i?E.shape[2]:E.shape[1],W=a?$.shape[1]:$.shape[2],U=Math.max(g,y),q=e.makeOutput([U,P,W],E.dtype),K=e.dataIdMap.get(q.dataId).id,j=new Uint8Array(new Int32Array(E.shape).buffer),Q=new Uint8Array(new Int32Array($.shape).buffer);return LB(D,j,E.shape.length,R,Q,$.shape.length,i,a,K),e.disposeData(E.dataId),e.disposeData($.dataId),q.shape=w,q}var zB={kernelName:ts,backendName:"wasm",setupFunc:qot,kernelFunc:Kot};function zo(r){let{inputs:{x:t},attrs:{begin:e,size:n},backend:o}=r,[s,i]=Ve.parseSliceParams(t,e,n),a=Ve.isSliceContinous(t.shape,s,i),u=o.readSync(t.dataId),l=o.makeOutput(i,t.dtype),c=x.computeStrides(t.shape),p=o.dataIdMap.get(l.dataId);if(a){let d=Ve.computeFlatOffset(s,c);return t.dtype==="string"?p.stringBytes=u.slice(d,d+x.sizeFromShape(i)):o.typedArrayFromHeap(l).set(u.subarray(d,d+x.sizeFromShape(i))),l}if(t.dtype==="string"){let d=Kc(u,s,i,t.shape,t.dtype);return p.stringBytes=d,l}let m=o.typedArrayFromHeap(l),f=t.shape.length;if(f===2)jot(u,c[0],m,s,i);else if(f===3)Xot(u,c[0],c[1],m,s,i);else if(f===4)Yot(u,c[0],c[1],c[2],m,s,i);else{let d=Kc(u,s,i,t.shape,t.dtype);m.set(d)}return l}function jot(r,t,e,n,o){let s=0,i=n[0],a=n[1],u=i+o[0];for(let l=i;l<u;l++){let c=l*t+a;e.set(r.subarray(c,c+o[1]),s),s+=o[1]}}function Xot(r,t,e,n,o,s){let i=0,a=o[0],u=o[1],l=o[2],c=a+s[0],p=u+s[1];for(let m=a;m<c;m++)for(let f=u;f<p;f++){let d=m*t+f*e+l;n.set(r.subarray(d,d+s[2]),i),i+=s[2]}}function Yot(r,t,e,n,o,s,i){let a=0,u=s[0],l=s[1],c=s[2],p=u+i[0],m=l+i[1],f=c+i[2],d=s[3];for(let h=u;h<p;h++)for(let g=l;g<m;g++)for(let y=c;y<f;y++){let b=h*t+g*e+y*n+d;o.set(r.subarray(b,b+i[3]),a),a+=i[3]}}var BB={kernelName:Ei,backendName:"wasm",kernelFunc:zo};function Zot(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{blockShape:s,crops:i}=n,a=s.reduce((y,b)=>y*b),u=S.getReshaped(o.shape,s,a),l=S.getPermuted(u.length,s.length),c=S.getReshapedPermuted(o.shape,s,a),p=S.getSliceBeginCoords(i,s.length),m=S.getSliceSize(c,i,s.length),f=pr({inputs:{x:o},backend:e,attrs:{shape:u}}),d=no({inputs:{x:f},backend:e,attrs:{perm:l}}),h=pr({inputs:{x:d},backend:e,attrs:{shape:c}}),g=zo({inputs:{x:h},backend:e,attrs:{begin:p,size:m}});return e.disposeData(f.dataId),e.disposeData(d.dataId),e.disposeData(f.dataId),g}var VB={kernelName:wi,backendName:"wasm",kernelFunc:Zot};function kl(r){let{inputs:{x:t},attrs:{dtype:e},backend:n}=r,o=n.makeOutput(t.shape,e),s=n.typedArrayFromHeap(t);return n.typedArrayFromHeap(o).set(s),o}var GB={kernelName:io,backendName:"wasm",kernelFunc:kl};var WB=ue(es);var UB;function Jot(r){UB=r.wasm.cwrap(ao,null,["number","number","number","number"])}function Qot(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{clipValueMin:s,clipValueMax:i}=n,a=e.dataIdMap.get(o.dataId).id,u=e.makeOutput(o.shape,o.dtype),l=e.dataIdMap.get(u.dataId).id;return UB(a,s,i,l),u}var HB={kernelName:ao,backendName:"wasm",setupFunc:Jot,kernelFunc:Qot};function FT(r){let{inputs:t,backend:e}=r,n=x.parseAxisParam(r.attrs.axis,t[0].shape)[0],o=S.computeOutShape(t.map(f=>f.shape),n),s=t.filter(f=>x.sizeFromShape(f.shape)>0);if(s.length===1)return ip({inputs:{x:s[0]},backend:e});let i=e.makeOutput(o,t[0].dtype);if(x.sizeFromShape(o)===0)return i;let a=s.map(f=>f.shape);if(S.assertParamsConsistent(a,n),s[0].dtype==="string"){let f=s.map(w=>{let v=x.sizeFromShape(w.shape.slice(n));return pr({inputs:{x:w},backend:e,attrs:{shape:[-1,v]}})}),d=f.map(w=>({vals:e.readSync(w.dataId),shape:w.shape}));o=S.computeOutShape(f.map(w=>w.shape),1);let h=f[0].shape[0]===1,g=Uc(d,o,t[0].dtype,h),y=S.computeOutShape(s.map(w=>w.shape),n);i.shape=y;let b=e.dataIdMap.get(i.dataId);return b.stringBytes=S.fromStringArrayToUint8(g),f.forEach(w=>e.disposeData(w.dataId)),i}let u=x.sizeFromShape(s[0].shape.slice(0,n)),l=0,c=s.map(f=>{let d=x.sizeFromShape(f.shape.slice(n));return l+=d,d}),p=s.map(f=>e.typedArrayFromHeap(f)),m=e.typedArrayFromHeap(i);for(let f=0;f<u;f++){let d=f*l;for(let h=0;h<p.length;h++){let g=c[h],y=f*g,b=p[h].subarray(y,y+g);m.set(b,d),d+=g}}return i}var qB={kernelName:vi,backendName:"wasm",kernelFunc:FT};var KB;function tst(r){KB=r.wasm.cwrap(rs,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function est(r){let{inputs:t,attrs:e,backend:n}=r,{x:o,filter:s}=t,i=n.dataIdMap.get(o.dataId).id,a=n.dataIdMap.get(s.dataId).id,{strides:u,dilations:l,pad:c,dimRoundingMode:p,dataFormat:m}=e,f=S.convertConv2DDataFormat(m),d=S.computeConv2DInfo(o.shape,s.shape,u,l,c,p,!1,f),h=d.filterHeight,g=d.filterWidth,y=d.padInfo.top,b=d.padInfo.right,w=d.padInfo.bottom,v=d.padInfo.left,k=d.dilationHeight,E=d.dilationWidth,$=d.strideHeight,D=d.strideWidth,R=d.inChannels,P=d.outChannels,W=d.padInfo.type==="SAME"?1:0;if(d.dataFormat!=="channelsLast")throw new Error(`wasm backend Conv2D does not support dataFormat:'${d.dataFormat}'. Please use 'channelsLast'.`);let U=n.makeOutput(d.outShape,"float32"),q=n.dataIdMap.get(U.dataId).id;return KB(i,o.shape[0],o.shape[1],o.shape[2],a,h,g,y,b,w,v,W,k,E,$,D,R,P,q),U}var jB={kernelName:rs,backendName:"wasm",setupFunc:tst,kernelFunc:est};var XB;function rst(r){XB=r.wasm.cwrap(ns,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function nst(r){let{backend:t,inputs:e,attrs:n}=r,{dy:o,filter:s}=e,{strides:i,pad:a,dataFormat:u,dimRoundingMode:l,inputShape:c}=n,p=1,m=S.convertConv2DDataFormat(u),f=S.computeConv2DInfo(c,s.shape,i,p,a,l,!1,m),{batchSize:d,filterHeight:h,filterWidth:g,inChannels:y,inHeight:b,inWidth:w,outChannels:v,outHeight:k,outWidth:E,strideHeight:$,strideWidth:D}=f,R=h-1-f.padInfo.top,P=g-1-f.padInfo.left,W=f.dataFormat==="channelsLast",U=x.computeStrides(f.inShape),q=x.computeStrides(o.shape),[K,j,Q]=x.computeStrides(s.shape),rt=U[0],X=W?U[1]:U[2],ot=W?U[2]:1,st=W?1:U[1],it=q[0],ft=W?q[1]:q[2],at=W?q[2]:1,xt=W?1:q[1],dt=t.makeOutput(f.inShape,"float32"),bt=t.dataIdMap.get(dt.dataId).id,kt=t.dataIdMap.get(o.dataId).id,At=t.dataIdMap.get(s.dataId).id;return XB(kt,At,d,h,g,b,w,y,k,E,v,$,D,R,P,K,j,Q,rt,X,ot,st,it,ft,at,xt,bt),dt}var YB={kernelName:ns,backendName:"wasm",setupFunc:rst,kernelFunc:nst};var ZB=ue(os);var JB=ue(ss);var OT;(function(r){r[r.bilinear=0]="bilinear",r[r.nearest=1]="nearest"})(OT||(OT={}));var QB;function ost(r){QB=r.wasm.cwrap(ca,null,["number","number","number","number","array","number","number","number","number","number"])}function sst(r){let{backend:t,inputs:e,attrs:n}=r,{method:o,extrapolationValue:s,cropSize:i}=n,{image:a,boxes:u,boxInd:l}=e,c=u.shape[0],[p,m]=i,f=[c,p,m,a.shape[3]],d=t.dataIdMap.get(a.dataId),h;a.dtype!=="float32"&&(h=kl({backend:t,inputs:{x:a},attrs:{dtype:"float32"}}),d=t.dataIdMap.get(h.dataId));let g=d.id,y=t.dataIdMap.get(u.dataId).id,b=t.dataIdMap.get(l.dataId).id,w=t.makeOutput(f,"float32"),v=t.dataIdMap.get(w.dataId).id,k=new Uint8Array(new Int32Array(a.shape).buffer);return QB(g,y,b,c,k,p,m,OT[o],s,v),h!=null&&t.disposeData(h.dataId),w}var tV={kernelName:ca,backendName:"wasm",setupFunc:ost,kernelFunc:sst};var eV;function ist(r){eV=r.wasm.cwrap(ua,null,["number","number","number","number","number","number"])}function ast(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,exclusive:i,reverse:a}=n,u=o.shape.length;x.assert(o.dtype==="float32"||o.dtype==="int32",()=>`cumprod does not support ${o.dtype} tensors in the WASM backend`);let l=S.getAxesPermutation([s],u),c=o;l!==null&&(c=no({inputs:{x:o},attrs:{perm:l},backend:e}));let p=S.getInnerMostAxes(1,u)[0];S.assertAxesAreInnerMostDims("cumprod",[p],u);let m=e.makeOutput(c.shape,c.dtype),f=c.shape[p],d=e.dataIdMap.get(c.dataId).id,h=e.dataIdMap.get(m.dataId).id;eV(d,i?1:0,a?1:0,f,h,Xt[o.dtype]);let g=m;if(l!==null){let y=S.getUndoAxesPermutation(l);g=no({inputs:{x:m},attrs:{perm:y},backend:e}),e.disposeData(c.dataId),e.disposeData(m.dataId)}return g}var rV={kernelName:ua,backendName:"wasm",setupFunc:ist,kernelFunc:ast};var nV;function lst(r){nV=r.wasm.cwrap(is,null,["number","number","number","number","number","number"])}function ust(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,exclusive:i,reverse:a}=n,u=o.shape.length;x.assert(o.dtype==="float32"||o.dtype==="int32",()=>`cumsum does not support ${o.dtype} tensors in the WASM backend`);let l=S.getAxesPermutation([s],u),c=o;l!==null&&(c=no({inputs:{x:o},attrs:{perm:l},backend:e}));let p=S.getInnerMostAxes(1,u)[0];S.assertAxesAreInnerMostDims("cumsum",[p],u);let m=e.makeOutput(c.shape,c.dtype),f=c.shape[p],d=e.dataIdMap.get(c.dataId).id,h=e.dataIdMap.get(m.dataId).id;nV(d,i?1:0,a?1:0,f,h,Xt[o.dtype]);let g=m;if(l!==null){let y=S.getUndoAxesPermutation(l);g=no({inputs:{x:m},attrs:{perm:y},backend:e}),e.disposeData(c.dataId),e.disposeData(m.dataId)}return g}var oV={kernelName:is,backendName:"wasm",setupFunc:lst,kernelFunc:ust};var sV;function cst(r){sV=r.wasm.cwrap(pa,null,["number","number","number","array","number","array","array","number","number"])}function pst(r){let{backend:t,inputs:e,attrs:n}=r,{x:o}=e,{blockSize:s,dataFormat:i}=n,a=o.shape[0],u=i==="NHWC"?o.shape[1]:o.shape[2],l=i==="NHWC"?o.shape[2]:o.shape[3],c=i==="NHWC"?o.shape[3]:o.shape[1],p=u*s,m=l*s,f=c/(s*s),d=i==="NHWC"?[a,p,m,f]:[a,f,p,m],h=t.makeOutput(d,"float32"),y=t.dataIdMap.get(o.dataId).id,b=new Uint8Array(new Int32Array(x.computeStrides(o.shape)).buffer),w=new Uint8Array(new Int32Array(d).buffer),v=new Uint8Array(new Int32Array(x.computeStrides(d)).buffer),k=t.dataIdMap.get(h.dataId).id;return sV(y,s,i==="NHWC"?1:0,b,o.shape.length-1,w,v,d.length,k),h}var iV={kernelName:pa,backendName:"wasm",setupFunc:cst,kernelFunc:pst};var aV;function mst(r){aV=r.wasm.cwrap(as,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function fst(r){let{inputs:t,attrs:e,backend:n}=r,{x:o,filter:s}=t,i=n.dataIdMap.get(o.dataId).id,a=n.dataIdMap.get(s.dataId).id,{strides:u,dilations:l,pad:c,dimRoundingMode:p}=e,m=l==null?[1,1]:l,f=S.computeConv2DInfo(o.shape,s.shape,u,m,c,p,!0),d=f.filterHeight,h=f.filterWidth,g=f.padInfo.top,y=f.padInfo.right,b=f.padInfo.bottom,w=f.padInfo.left,v=f.dilationHeight,k=f.dilationWidth,E=f.strideHeight,$=f.strideWidth,D=f.inChannels,R=f.outChannels,P=f.padInfo.type==="SAME"?1:0;if(f.dataFormat!=="channelsLast")throw new Error(`wasm backend DepthwiseConv2dNative does not support dataFormat:'${f.dataFormat}'. Please use 'channelsLast'.`);let W=n.makeOutput(f.outShape,"float32"),U=n.dataIdMap.get(W.dataId).id;return aV(i,o.shape[0],o.shape[1],o.shape[2],a,d,h,g,y,b,w,P,v,k,E,$,D,R,U),W}var lV={kernelName:as,backendName:"wasm",setupFunc:mst,kernelFunc:fst};var uV=ue(us);var dst=!1,cV=Ie(fa,dst,"bool");var pV=ue(cs,"float32");function qv(r){let{inputs:t,attrs:e,backend:n}=r,{input:o}=t,{dim:s}=e,i=o.shape.length,a=o.shape.slice(),u=s;return s<0&&(x.assert(-(i+1)<=s,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),u=i+s+1),a.splice(u,0,1),pr({inputs:{x:o},backend:n,attrs:{shape:a}})}var mV={kernelName:Ci,backendName:"wasm",kernelFunc:qv};function MT(r){let{attrs:{shape:t,value:e,dtype:n},backend:o}=r,s=o.makeOutput(t,n);return o.typedArrayFromHeap(s).fill(e),s}var fV={kernelName:Ol,backendName:"wasm",kernelFunc:MT};var dV;function hst(r){dV=r.wasm.cwrap(ha,null,["number","number","number","number","number","number"])}function gst(r){let{inputs:t,backend:e}=r,{image:n}=t,o=e.makeOutput(n.shape,n.dtype),s=e.dataIdMap.get(n.dataId).id,i=e.dataIdMap.get(o.dataId).id,[a,u,l,c]=n.shape;return dV(s,a,u,l,c,i),o}var hV={kernelName:ha,backendName:"wasm",kernelFunc:gst,setupFunc:hst};var gV=ue(ps);var xst=!1,xV=Ie(ms,xst);var yV;function yst(r){yV=r.wasm.cwrap(fs,null,["number","number","number","number","number","number","number"])}function bst(r){let{backend:t,inputs:e,attrs:n}=r,{varianceEpsilon:o}=n,{x:s,mean:i,variance:a,offset:u,scale:l}=e,c=t.dataIdMap.get(s.dataId).id,p=t.dataIdMap.get(i.dataId).id,m=t.dataIdMap.get(a.dataId).id,f=u!=null?t.dataIdMap.get(u.dataId).id:0,d=l!=null?t.dataIdMap.get(l.dataId).id:0,h=t.makeOutput(s.shape,s.dtype);if(x.sizeFromShape(s.shape)===0)return h;let g=t.dataIdMap.get(h.dataId).id;return yV(c,p,m,f,d,o,g),h}var bV={kernelName:fs,backendName:"wasm",setupFunc:yst,kernelFunc:bst};var wV;function wst(r){wV=r.wasm.cwrap(Oi,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function vst(r){let{inputs:t,attrs:e,backend:n}=r,{x:o,filter:s,bias:i,preluActivationWeights:a}=t,{strides:u,pad:l,dilations:c,dataFormat:p,dimRoundingMode:m,activation:f,leakyreluAlpha:d}=e,h=S.computeConv2DInfo(o.shape,s.shape,u,c,l,m),g=Su[f];if(g==null)throw new Error(`${f} activation not yet supported for FusedConv2D in the wasm backend.`);let y=n.dataIdMap.get(o.dataId).id,b=n.dataIdMap.get(s.dataId).id,w=h.outChannels,v=0;if(i!=null){let at=n.dataIdMap.get(i.dataId);if(at.shape.length!==1)throw new Error(`FusedConv2D only supports rank-1 bias but got rank ${at.shape.length}.`);if(at.shape[0]!==w)throw new Error(`FusedConv2D bias shape (${at.shape}) does not match the number of output channels (${w})`);v=at.id}let k=h.filterHeight,E=h.filterWidth,$=h.padInfo.top,D=h.padInfo.right,R=h.padInfo.bottom,P=h.padInfo.left,W=h.dilationHeight,U=h.dilationWidth,q=h.strideHeight,K=h.strideWidth,j=h.inChannels,Q=h.padInfo.type==="SAME"?1:0,rt=h.batchSize,X=h.inHeight,ot=h.inWidth;if(p!=="NHWC")throw new Error(`wasm backend FusedConv2D does not support dataFormat:'${p}'. Please use 'NHWC'.`);let st=n.makeOutput(h.outShape,"float32"),it=n.dataIdMap.get(st.dataId).id,ft=a==null?0:n.dataIdMap.get(a.dataId).id;return wV(y,rt,X,ot,b,k,E,v,$,D,R,P,Q,W,U,q,K,j,w,g,ft,d||0,it),st}var vV={kernelName:Oi,backendName:"wasm",setupFunc:wst,kernelFunc:vst};var CV;function Cst(r){CV=r.wasm.cwrap(Mi,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Ist(r){let{inputs:t,attrs:e,backend:n}=r,{x:o,filter:s,bias:i,preluActivationWeights:a}=t,{strides:u,pad:l,dilations:c,dataFormat:p,dimRoundingMode:m,activation:f,leakyreluAlpha:d}=e,h=S.computeConv2DInfo(o.shape,s.shape,u,c,l,m,!0),g=Su[f];if(g==null)throw new Error(`${f} activation not yet supported for FusedDepthwiseConv2D in the wasm backend.`);let y=n.dataIdMap.get(o.dataId).id,b=n.dataIdMap.get(s.dataId).id,w=h.outChannels,v=0;if(i!=null){let at=n.dataIdMap.get(i.dataId);if(at.shape.length!==1)throw new Error(`FusedDepthwiseConv2D only supports rank-1 bias but got rank ${at.shape.length}.`);if(at.shape[0]!==w)throw new Error(`FusedDepthwiseConv2D bias shape (${at.shape}) does not match the number of output channels (${w})`);v=at.id}let k=h.filterHeight,E=h.filterWidth,$=h.padInfo.top,D=h.padInfo.right,R=h.padInfo.bottom,P=h.padInfo.left,W=h.dilationHeight,U=h.dilationWidth,q=h.strideHeight,K=h.strideWidth,j=h.inChannels,Q=h.padInfo.type==="SAME"?1:0,rt=h.batchSize,X=h.inHeight,ot=h.inWidth;if(p!=="NHWC")throw new Error(`wasm backend FusedDepthwiseConv2D does not support dataFormat:'${p}'. Please use 'NHWC'.`);let st=n.makeOutput(h.outShape,"float32"),it=n.dataIdMap.get(st.dataId).id,ft=a==null?0:n.dataIdMap.get(a.dataId).id;return CV(y,rt,X,ot,b,k,E,v,$,D,R,P,Q,W,U,q,K,j,w,g,ft,d||0,it),st}var IV={kernelName:Mi,backendName:"wasm",setupFunc:Cst,kernelFunc:Ist};var SV;function Sst(r){SV=r.wasm.cwrap(ga,null,["number","number","number","number","number","number","array","number"])}function kst(r){let{backend:t,inputs:e}=r,{params:n,indices:o}=e,[s,i,a,u]=Ax.prepareAndValidate(n,o),l=t.makeOutput(s,n.dtype);if(i===0)return l;let c=o.shape,p=c[c.length-1],f=t.dataIdMap.get(n.dataId).id,h=t.dataIdMap.get(o.dataId).id,g=new Uint8Array(new Int32Array(u).buffer),y=t.dataIdMap.get(l.dataId).id;return SV(f,Xt[n.dtype],h,i,p,a,g,y),l}var kV={kernelName:ga,backendName:"wasm",setupFunc:Sst,kernelFunc:kst};var NV;function Nst(r){NV=r.wasm.cwrap("Gather",null,["number","number","array","number","number","number","array","number"])}function Tst(r){let{backend:t,inputs:e,attrs:n}=r,{x:o,indices:s}=e,{axis:i,batchDims:a}=n,u=x.parseAxisParam(i,o.shape)[0],l=t.readSync(s.dataId),c=o.shape[u];for(let R=0;R<l.length;++R){let P=l[R];x.assert(P<=c-1&&P>=0,()=>`GatherV2: the index value ${P} is not in [0, ${c-1}]`)}let p=S.segment_util.collectGatherOpShapeInfo(o,s,u,a),m=pr({inputs:{x:o},attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]},backend:t}),f=x.sizeFromShape(s.shape),d=pr({inputs:{x:s},attrs:{shape:[p.batchSize,f/p.batchSize]},backend:t}),h=[p.batchSize,p.outerSize,f/p.batchSize,p.sliceSize],g=t.makeOutput(h,o.dtype);if(x.sizeFromShape(o.shape)===0)return g;let y=m.shape.length-1,w=t.dataIdMap.get(m.dataId).id,k=t.dataIdMap.get(d.dataId).id,E=t.dataIdMap.get(g.dataId).id,$=new Uint8Array(new Int32Array(x.computeStrides(m.shape)).buffer),D=new Uint8Array(new Int32Array(x.computeStrides(h)).buffer);return NV(w,Xt[o.dtype],$,y,k,p.batchSize,D,E),t.disposeData(m.dataId),t.disposeData(d.dataId),g.shape=p.outputShape,g}var TV={kernelName:Ii,backendName:"wasm",setupFunc:Nst,kernelFunc:Tst};var _st=!1,_V=Ie(xa,_st,"bool");var Est=!1,EV=Ie(ds,Est,"bool");var AV;function Ast(r){AV=r.wasm.cwrap(hs,null,["number","number","number","number"])}function $st(r){let{inputs:{x:t},attrs:{alpha:e},backend:n}=r,o=n.dataIdMap.get(t.dataId).id,s=n.makeOutput(t.shape,"float32");if(x.sizeFromShape(t.shape)!==0){let i=n.dataIdMap.get(s.dataId).id;AV(o,Xt[t.dtype],e,i)}return s}var $V={kernelName:hs,backendName:"wasm",setupFunc:Ast,kernelFunc:$st};var Dst=!1,DV=Ie(va,Dst,"bool");var Rst=!1,RV=Ie(Ca,Rst,"bool");var FV=ue(gs);var Fst=!1,OV=Ie(Sa,Fst,"bool");var MV;function Ost(r){MV=r.wasm.cwrap(xs,null,["number","number","number","number"])}function Mst(r){let{backend:t,inputs:e,attrs:n}=r,{reductionIndices:o,keepDims:s}=n,{x:i}=e,u=t.dataIdMap.get(i.dataId).id,l=i,{transposed:c,axes:p,originalAxes:m,inputWasTransposed:f}=Sn(i,o,t);if(f){let w=t.dataIdMap.get(c.dataId).id;l=c,u=w}let d=l.shape.length;S.assertAxesAreInnerMostDims("max",p,d);let[h,g]=S.computeOutAndReduceShapes(l.shape,p),y=x.sizeFromShape(g),b=t.makeOutput(h,i.dtype);if(x.sizeFromShape(l.shape)!==0){let w=t.dataIdMap.get(b.dataId).id;MV(u,Xt[i.dtype],y,w)}if(f&&t.disposeData(c.dataId),s){let w=S.expandShapeToKeepDim(b.shape,m);b.shape=w}return b}var PV={kernelName:xs,backendName:"wasm",setupFunc:Ost,kernelFunc:Mst};var Pst=!1,LV=Ie(ys,Pst);var zV;function Lst(r){zV=r.wasm.cwrap(bs,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function zst(r){let{inputs:t,attrs:e,backend:n}=r,o=t.x,s=n.dataIdMap.get(o.dataId).id;x.assert(o.dtype==="float32",()=>`Error in MaxPool: only float32 input is supported. Got ${o.dtype}.`);let{filterSize:i,strides:a,pad:u,dimRoundingMode:l}=e,c=S.computePool2DInfo(o.shape,i,a,1,u,l),p=c.filterHeight,m=c.filterWidth,f=c.padInfo.top,d=c.padInfo.right,h=c.padInfo.bottom,g=c.padInfo.left,y=c.dilationHeight,b=c.dilationWidth,w=c.strideHeight,v=c.strideWidth,k=c.inChannels,E=c.outChannels;if(c.dataFormat!=="channelsLast")throw new Error(`wasm backend does not support dataFormat:'${c.dataFormat}'. Please use 'channelsLast'.`);let $=n.makeOutput(c.outShape,"float32"),D=n.dataIdMap.get($.dataId).id;return zV(s,o.shape[0],o.shape[1],o.shape[2],p,m,f,d,h,g,y,b,w,v,k,E,D),$}var BV={kernelName:bs,backendName:"wasm",setupFunc:Lst,kernelFunc:zst};var VV;function Bst(r){VV=r.wasm.cwrap(ws,null,["number, number, number"])}function Vst(r){let{backend:t,inputs:e,attrs:n}=r,{axis:o,keepDims:s}=n,{x:i}=e,a=t.dataIdMap.get(i.dataId).id,u=a,l=i,{transposed:c,axes:p,originalAxes:m,inputWasTransposed:f}=Sn(i,o,t),d=p;if(f){let v=t.dataIdMap.get(c.dataId).id;v!==a&&(l=c,u=v,d=S.getInnerMostAxes(d.length,l.shape.length))}S.assertAxesAreInnerMostDims("mean",d,l.shape.length);let[h,g]=S.computeOutAndReduceShapes(l.shape,d),y=x.sizeFromShape(g),b=l;l.dtype!=="float32"&&(b=kl({backend:t,inputs:{x:l},attrs:{dtype:"float32"}}),u=t.dataIdMap.get(b.dataId).id);let w=t.makeOutput(h,"float32");if(x.sizeFromShape(l.shape)!==0){let v=t.dataIdMap.get(w.dataId).id;VV(u,y,v)}if(f&&t.disposeData(c.dataId),s){let v=S.expandShapeToKeepDim(w.shape,m);w.shape=v}return l.dtype!=="float32"&&t.disposeData(b.dataId),w}var GV={kernelName:ws,backendName:"wasm",setupFunc:Bst,kernelFunc:Vst};var WV;function Gst(r){WV=r.wasm.cwrap(vs,null,["number","number","number","number"])}function Wst(r){let{backend:t,inputs:e,attrs:n}=r,{axis:o,keepDims:s}=n,{x:i}=e,a=t.dataIdMap.get(i.dataId).id,u=a,l=i,{transposed:c,axes:p,originalAxes:m,inputWasTransposed:f}=Sn(i,o,t);if(f){let w=t.dataIdMap.get(c.dataId).id;w!==a&&(l=c,u=w)}let d=l.shape.length;S.assertAxesAreInnerMostDims("min",p,d);let[h,g]=S.computeOutAndReduceShapes(l.shape,p),y=x.sizeFromShape(g),b=t.makeOutput(h,l.dtype);if(x.sizeFromShape(l.shape)!==0){let w=t.dataIdMap.get(b.dataId).id;WV(u,Xt[i.dtype],y,w)}if(f&&t.disposeData(c.dataId),s){let w=S.expandShapeToKeepDim(b.shape,m);b.shape=w}return b}var UV={kernelName:vs,backendName:"wasm",setupFunc:Gst,kernelFunc:Wst};var Ust=!1,HV=Ie(Cs,Ust);var PT;(function(r){r[r.reflect=0]="reflect",r[r.symmetric=1]="symmetric"})(PT||(PT={}));var qV;function Hst(r){qV=r.wasm.cwrap(Is,null,["number","array","number","number","array","array","number","number"])}function qst(r){let{inputs:{x:t},backend:e,attrs:{paddings:n,mode:o}}=r,s=n.map((d,h)=>d[0]+t.shape[h]+d[1]),i=e.dataIdMap.get(t.dataId).id,a=e.makeOutput(s,t.dtype),u=e.dataIdMap.get(a.dataId).id,l=new Uint8Array(new Int32Array(t.shape).buffer),c=n.map(d=>d[0]),p=n.map(d=>d[1]),m=new Uint8Array(new Int32Array(c).buffer),f=new Uint8Array(new Int32Array(p).buffer);return qV(i,l,t.shape.length,Xt[t.dtype],m,f,PT[o],u),a}var KV={kernelName:Is,backendName:"wasm",kernelFunc:qst,setupFunc:Hst};var Kst=!0,jV=Ie(Ss,Kst);var XV=ue(Si);function kd(r,t){let e=new Int32Array(r.wasm.HEAPU8.buffer,t,4),n=e[0],o=e[1],s=e[2],i=e[3];return r.wasm._free(t),{pSelectedIndices:n,selectedSize:o,pSelectedScores:s,pValidOutputs:i}}var YV;function jst(r){YV=r.wasm.cwrap(Ta,"number",["number","number","number","number","number"])}function Xst(r){let{backend:t,inputs:e,attrs:n}=r,{iouThreshold:o,maxOutputSize:s,scoreThreshold:i}=n,{boxes:a,scores:u}=e,l=t.dataIdMap.get(a.dataId).id,c=t.dataIdMap.get(u.dataId).id,p=YV(l,c,s,o,i),{pSelectedIndices:m,selectedSize:f,pSelectedScores:d,pValidOutputs:h}=kd(t,p);return t.wasm._free(d),t.wasm._free(h),t.makeOutput([f],"int32",m)}var ZV={kernelName:Ta,backendName:"wasm",setupFunc:jst,kernelFunc:Xst};var JV;function Yst(r){JV=r.wasm.cwrap(_a,"number",["number","number","number","number","number","bool"])}function Zst(r){let{backend:t,inputs:e,attrs:n}=r,{iouThreshold:o,maxOutputSize:s,scoreThreshold:i,padToMaxOutputSize:a}=n,{boxes:u,scores:l}=e,c=t.dataIdMap.get(u.dataId).id,p=t.dataIdMap.get(l.dataId).id,m=JV(c,p,s,o,i,a),{pSelectedIndices:f,selectedSize:d,pSelectedScores:h,pValidOutputs:g}=kd(t,m);t.wasm._free(h);let y=t.makeOutput([d],"int32",f),b=t.makeOutput([],"int32",g);return[y,b]}var QV={kernelName:_a,backendName:"wasm",setupFunc:Yst,kernelFunc:Zst};var tG;function Jst(r){tG=r.wasm.cwrap(Ea,"number",["number","number","number","number","number","number"])}function Qst(r){let{backend:t,inputs:e,attrs:n}=r,{iouThreshold:o,maxOutputSize:s,scoreThreshold:i,softNmsSigma:a}=n,{boxes:u,scores:l}=e,c=t.dataIdMap.get(u.dataId).id,p=t.dataIdMap.get(l.dataId).id,m=tG(c,p,s,o,i,a),{pSelectedIndices:f,selectedSize:d,pSelectedScores:h,pValidOutputs:g}=kd(t,m);t.wasm._free(g);let y=t.makeOutput([d],"int32",f),b=t.makeOutput([d],"float32",h);return[y,b]}var eG={kernelName:Ea,backendName:"wasm",setupFunc:Jst,kernelFunc:Qst};var tit=!1,rG=Ie(Na,tit,"bool");var nG;function eit(r){nG=r.wasm.cwrap(ks,null,["number","number","number","number","number"])}function rit(r){let{inputs:t,backend:e,attrs:n}=r,{indices:o}=t,{depth:s,onValue:i,offValue:a}=n,u=e.makeOutput([...o.shape,s],"int32"),l=e.dataIdMap.get(u.dataId).id,p=e.dataIdMap.get(o.dataId).id;return nG(p,s,i,a,l),u}var oG={kernelName:ks,backendName:"wasm",setupFunc:eit,kernelFunc:rit};function nit(r){let{inputs:{x:t},backend:e}=r,n=e.makeOutput(t.shape,t.dtype);return e.typedArrayFromHeap(n).fill(1),n}var sG={kernelName:ki,backendName:"wasm",kernelFunc:nit};function oit(r){let{inputs:t,backend:e,attrs:n}=r,{axis:o}=n;if(t.length===1)return qv({inputs:{input:t[0]},backend:e,attrs:{dim:o}});let s=t[0].shape,i=t[0].dtype;t.forEach(c=>{x.assertShapesMatch(s,c.shape,"All tensors passed to stack must have matching shapes"),x.assert(i===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});let a=[],u=t.map(c=>{let p=qv({inputs:{input:c},backend:e,attrs:{dim:o}});return a.push(p),p}),l=FT({inputs:u,backend:e,attrs:{axis:o}});return a.forEach(c=>e.disposeData(c.dataId)),l}var iG={kernelName:Ni,backendName:"wasm",kernelFunc:oit};var aG;function sit(r){aG=r.wasm.cwrap(Ns,null,["number","array","number","number","array","array","number","number"])}function iit(r){let{inputs:{x:t},backend:e,attrs:{paddings:n,constantValue:o}}=r,s=n.map((h,g)=>h[0]+t.shape[g]+h[1]);if(x.sizeFromShape(t.shape)===0)return MT({backend:e,attrs:{shape:s,value:o,dtype:t.dtype}});let i=e.dataIdMap.get(t.dataId).id,a=e.makeOutput(s,t.dtype),l=e.dataIdMap.get(a.dataId).id,c=new Uint8Array(new Int32Array(t.shape).buffer),p=n.map(h=>h[0]),m=n.map(h=>h[1]),f=new Uint8Array(new Int32Array(p).buffer),d=new Uint8Array(new Int32Array(m).buffer);return aG(i,c,t.shape.length,Xt[t.dtype],f,d,o,l),a}var Kv={kernelName:Ns,backendName:"wasm",kernelFunc:iit,setupFunc:sit};var ait=!1,lG=Ie(Ts,ait);var uG;function lit(r){uG=r.wasm.cwrap(_s,null,["number","number","number"])}function uit(r){let{inputs:t,backend:e}=r,{x:n,alpha:o}=t,s=e.dataIdMap.get(n.dataId).id,i=e.dataIdMap.get(o.dataId).id,a=s,u=n,l=u;u.dtype!=="float32"&&(l=kl({backend:e,inputs:{x:n},attrs:{dtype:"float32"}}),a=e.dataIdMap.get(l.dataId).id);let c=e.makeOutput(n.shape,"float32"),p=e.dataIdMap.get(c.dataId).id;return uG(a,i,p),u.dtype!=="float32"&&e.disposeData(l.dataId),c}var cG={kernelName:_s,backendName:"wasm",setupFunc:lit,kernelFunc:uit};var pG;function cit(r){pG=r.wasm.cwrap(Aa,null,["number","number","number","number"])}function pit(r){let{backend:t,inputs:e,attrs:n}=r,{axis:o,keepDims:s}=n,{x:i}=e,a=t.dataIdMap.get(i.dataId).id,u=a,l=i,{transposed:c,axes:p,originalAxes:m,inputWasTransposed:f}=Sn(i,o,t),d=p;if(f){let w=t.dataIdMap.get(c.dataId).id;w!==a&&(l=c,u=w,d=S.getInnerMostAxes(d.length,l.shape.length))}S.assertAxesAreInnerMostDims("prod",d,l.shape.length);let[h,g]=S.computeOutAndReduceShapes(l.shape,d),y=x.sizeFromShape(g),b=t.makeOutput(h,l.dtype);if(x.sizeFromShape(l.shape)!==0){let w=t.dataIdMap.get(b.dataId).id;pG(u,y,Xt[b.dtype],w)}if(f&&t.disposeData(c.dataId),s){let w=S.expandShapeToKeepDim(b.shape,m);b.shape=w}return b}var mG={kernelName:Aa,backendName:"wasm",setupFunc:cit,kernelFunc:pit};var mit=r=>{let{backend:t,attrs:e}=r,{start:n,stop:o,step:s,dtype:i}=e,a=qc(n,o,s,i),u=t.makeOutput([a.length],i);return t.typedArrayFromHeap(u).set(a),u},fG={kernelName:Ll,backendName:"wasm",kernelFunc:mit};var fit=!0,dG=Ie(ls,fit);var hG=ue(Es);var gG=ue($s);var xG;function dit(r){xG=r.wasm.cwrap(As,null,["number","number","number","number","number","number","number","number","number","number"])}function hit(r){let{backend:t,inputs:e,attrs:n}=r,{images:o}=e,{alignCorners:s,halfPixelCenters:i,size:a}=n,[u,l]=a,[c,p,m,f]=o.shape,d=[c,u,l,f],h=t.dataIdMap.get(o.dataId),g;h.dtype!=="float32"&&(g=kl({backend:t,inputs:{x:o},attrs:{dtype:"float32"}}),h=t.dataIdMap.get(g.dataId));let y=h.id,b=t.makeOutput(d,"float32");if(x.sizeFromShape(o.shape)===0)return b;let w=t.dataIdMap.get(b.dataId).id;return xG(y,c,p,m,f,u,l,s?1:0,i?1:0,w),g!=null&&t.disposeData(g.dataId),b}var yG={kernelName:As,backendName:"wasm",setupFunc:dit,kernelFunc:hit};var bG;function git(r){bG=r.wasm.cwrap(Ds,null,["number","array","number","array","number","number"])}function xit(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{dims:s}=n,i=x.parseAxisParam(s,o.shape);if(o.shape.length===0)return ip({inputs:{x:o},backend:e});let a=e.makeOutput(o.shape,o.dtype),u=e.dataIdMap.get(o.dataId).id,l=e.dataIdMap.get(a.dataId).id,c=new Uint8Array(new Int32Array(i).buffer),p=new Uint8Array(new Int32Array(o.shape).buffer);bG(u,c,i.length,p,o.shape.length,l);let m=pr({inputs:{x:a},attrs:{shape:o.shape},backend:e});return e.disposeData(a.dataId),m}var wG={kernelName:Ds,backendName:"wasm",kernelFunc:xit,setupFunc:git};var vG;function yit(r){vG=r.wasm.cwrap(Va,null,["number","number","number","number","number","number","number","number","array","number","number"])}function bit(r){let{inputs:t,backend:e,attrs:n}=r,{image:o}=t,{radians:s,fillValue:i,center:a}=n,u=e.makeOutput(o.shape,o.dtype),l=e.dataIdMap.get(o.dataId).id,c=e.dataIdMap.get(u.dataId).id,[p,m,f,d]=o.shape,[h,g]=S.getImageCenter(a,m,f),y=i===0,b=255,w=typeof i=="number"?[i,i,i,y?0:b]:[...i,b],v=new Uint8Array(new Int32Array(w).buffer);return vG(l,p,m,f,d,s,h,g,v,w.length,c),u}var CG={kernelName:Va,backendName:"wasm",kernelFunc:bit,setupFunc:yit};var IG=ue(Rs);var SG=ue(Fs);var kG;function wit(r){kG=r.wasm.cwrap(Da,null,["number","number","number","number","number","number","array","number","number"])}function vit(r){let{backend:t,inputs:e,attrs:n}=r,{indices:o,updates:s}=e,{shape:i}=n,a=t.makeOutput(i,s.dtype);if(x.sizeFromShape(i)===0)return a;let{sliceRank:u,numUpdates:l,sliceSize:c,strides:p,outputSize:m}=rh.calculateShapes(s,o,i),d=t.dataIdMap.get(o.dataId).id,g=t.dataIdMap.get(s.dataId).id,y=new Uint8Array(new Int32Array(p).buffer),b=t.dataIdMap.get(a.dataId).id;return kG(d,g,Xt[s.dtype],u,l,c,y,m,b),a}var NG={kernelName:Da,backendName:"wasm",setupFunc:wit,kernelFunc:vit};var TG;function Cit(r){TG=r.wasm.cwrap("SelectV2",null,["number","number","number","number","number"])}function Iit(r){let{inputs:t,backend:e}=r,{condition:n,t:o,e:s}=t,i=e.dataIdMap.get(n.dataId).id,a=e.dataIdMap.get(o.dataId).id,u=e.dataIdMap.get(s.dataId).id,l=e.makeOutput(o.shape,o.dtype),c=e.dataIdMap.get(l.dataId).id,p=n.shape.length,m=o.shape.length,f=p===0||p>1||m===1?1:x.sizeFromShape(o.shape.slice(1));return TG(i,a,u,f,c),l}var _G={kernelName:_i,backendName:"wasm",kernelFunc:Iit,setupFunc:Cit};var EG;function Sit(r){EG=r.wasm.cwrap(Ms,null,["number","number"])}function kit(r){let{backend:t,inputs:{x:e}}=r,n=t.dataIdMap.get(e.dataId).id,o=t.makeOutput(e.shape,e.dtype),s=t.dataIdMap.get(o.dataId).id;return x.sizeFromShape(o.shape)===0||EG(n,s),o}var AG={kernelName:"Sigmoid",backendName:"wasm",setupFunc:Sit,kernelFunc:kit};var $G=ue(Os);var DG;function Nit(r){DG=r.wasm.cwrap(zs,null,["number","number","number","number"])}function Tit(r){let{backend:t,inputs:{logits:e},attrs:{dim:n}}=r,o=t.dataIdMap.get(e.dataId).id,s=t.makeOutput(e.shape,e.dtype),i=t.dataIdMap.get(s.dataId).id,a=e.shape[n],u=x.sizeFromShape(e.shape)/a;return x.sizeFromShape(s.shape)===0||DG(o,i,a,u),s}var RG={kernelName:zs,backendName:"wasm",setupFunc:Nit,kernelFunc:Tit};function _it(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{blockShape:s,paddings:i}=n,a=x.sizeFromShape(s),u=[[0,0]];u.push(...i);for(let E=1+s.length;E<o.shape.length;++E)u.push([0,0]);let l=Kv.kernelFunc({inputs:{x:o},backend:e,attrs:{paddings:u,constantValue:0}}),c=S.getReshaped(l.shape,s,a,!1),p=S.getPermuted(c.length,s.length,!1),m=S.getReshapedPermuted(l.shape,s,a,!1),h=pr({inputs:{x:l},backend:e,attrs:{shape:c}}),b=no({inputs:{x:h},backend:e,attrs:{perm:p}}),k=pr({inputs:{x:b},backend:e,attrs:{shape:m}});return e.disposeData(l.dataId),e.disposeData(h.dataId),e.disposeData(b.dataId),k}var FG={kernelName:Ai,backendName:"wasm",kernelFunc:_it};var OG;function Eit(r){OG=r.wasm.cwrap("SparseFillEmptyRows","number",["number","number","number","number","number","number","number","number","number","number","number","number"])}function Ait(r){let{backend:t,inputs:e}=r,{indices:n,values:o,denseShape:s,defaultValue:i}=e,a=n.shape[0],u=n.shape[1],l=t.readSync(s.dataId)[0],c=[a+l,u],p=t.dataIdMap.get(n.dataId).id,m=t.dataIdMap.get(o.dataId).id,f=t.dataIdMap.get(i.dataId).id,d=t.makeOutput(c,n.dtype),h=t.dataIdMap.get(d.dataId).id,g=t.makeOutput(c.slice(0,1),o.dtype),y=t.dataIdMap.get(g.dataId).id,b=t.makeOutput([l],"bool"),w=t.dataIdMap.get(b.dataId).id,v=t.makeOutput([a],n.dtype),k=t.dataIdMap.get(v.dataId).id,E=t.makeOutput([4],"int32"),$=t.dataIdMap.get(E.dataId).id,D=OG(p,m,Xt[o.dtype],a,l,u,f,h,y,w,k,$),R=t.readSync(E.dataId),P;switch(R[0]){case 1:{P=S.getSparseFillEmptyRowsIndicesDenseShapeMismatch(R[1]);break}case 2:{P=S.getSparseFillEmptyRowsNegativeIndexErrorMessage(R[1],R[2]);break}case 3:P=S.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(R[1],R[2],R[3]);break;default:P=""}if(t.disposeData(E.dataId),P)throw t.disposeData(d.dataId),t.disposeData(g.dataId),t.disposeData(b.dataId),t.disposeData(v.dataId),new Error(P);let W=d,U=g;return D!==c[0]&&(W=zo({inputs:{x:d},attrs:{begin:0,size:[D,u]},backend:t}),U=zo({inputs:{x:g},attrs:{begin:0,size:D},backend:t}),t.disposeData(d.dataId),t.disposeData(g.dataId)),[W,U,b,v]}var MG={kernelName:Bl,backendName:"wasm",setupFunc:Eit,kernelFunc:Ait};var PG;function $it(r){PG=r.wasm.cwrap(Pa,null,["number","number","number","number","number","number","number"])}function Dit(r){let{backend:t,inputs:e}=r,{inputIndices:n,inputShape:o,newShape:s}=e;if(n.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${n.shape}`);if(o.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${o.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let i=t.dataIdMap.get(n.dataId).id,a=t.dataIdMap.get(o.dataId).id,u=t.dataIdMap.get(s.dataId).id,l=n.shape[0],c=x.sizeFromShape(s.shape),p=t.makeOutput([l,c],n.dtype),m=t.dataIdMap.get(p.dataId).id,f=t.makeOutput([c],s.dtype),d=t.dataIdMap.get(f.dataId).id,h=t.makeOutput([3],"int32"),g=t.dataIdMap.get(h.dataId).id;PG(i,a,u,l,m,d,g);let y=t.readSync(h.dataId),b;switch(y[0]){case 0:{b=S.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(y[1],y[2]);break}case 1:{b=S.getSparseReshapeNegativeOutputDimErrorMessage(y[1],y[2]);break}case 2:b=S.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage();break;case 3:{let w=Array.from(t.readSync(o.dataId)),v=Array.from(t.readSync(f.dataId));b=S.getSparseReshapeInputOutputMultipleErrorMessage(w,v);break}case 4:{let w=Array.from(t.readSync(o.dataId)),v=Array.from(t.readSync(f.dataId));b=S.getSparseReshapeInputOutputMismatchErrorMessage(w,v);break}default:b=""}if(t.disposeData(h.dataId),b)throw t.disposeData(p.dataId),t.disposeData(f.dataId),new Error(b);return[p,f]}var LG={kernelName:Pa,backendName:"wasm",setupFunc:$it,kernelFunc:Dit};var zG;function jv(r){zG=r.wasm.cwrap("SparseSegmentReduction",null,["number","number","number","number","number","number","number","number","number"])}function Xv(r,t){let{backend:e,inputs:n}=r,{data:o,indices:s,segmentIds:i}=n,a=s.shape[0],u=e.readSync(i.dataId,a-1,a)[0],c=a>0?u+1:0;if(c<0)throw new Error(S.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let p=o.shape.slice();p[0]=c;let m=e.dataIdMap.get(o.dataId).id,f=e.dataIdMap.get(s.dataId).id,d=e.dataIdMap.get(i.dataId).id,h=e.makeOutput(p,o.dtype),g=e.dataIdMap.get(h.dataId).id,y=e.makeOutput([4],"int32"),b=e.dataIdMap.get(y.dataId).id;zG(m,Xt[o.dtype],o.shape[0],f,d,g,b,t,0);let w=e.readSync(y.dataId),v;switch(w[0]){case 0:{v=S.getSparseSegmentReductionNegativeSegmentIdsErrorMessage();break}case 1:{v=S.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage();break}case 2:v=S.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(w[1],w[2]);break;case 3:v=S.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(w[1],w[2],w[3]);break;default:v=""}if(e.disposeData(y.dataId),v)throw e.disposeData(h.dataId),new Error(v);return h}function Rit(r){return Xv(r,!0)}var BG={kernelName:Vl,backendName:"wasm",setupFunc:jv,kernelFunc:Rit};function Fit(r){return Xv(r,!1)}var VG={kernelName:Gl,backendName:"wasm",setupFunc:jv,kernelFunc:Fit};function Oit(r){let{inputs:t,attrs:e,backend:n}=r,{x:o}=t,{numOrSizeSplits:s,axis:i}=e,a=x.parseAxisParam(i,o.shape)[0],u=S.prepareSplitSize(o,s,a),l=new Array(o.shape.length).fill(0),c=o.shape.slice();return u.map(p=>{let m=[...c];m[a]=p;let f=zo({inputs:{x:o},attrs:{begin:l,size:m},backend:n});return l[a]+=p,f})}var GG={kernelName:$i,backendName:"wasm",kernelFunc:Oit};var WG=ue(Ps);var UG=ue(Wl);var Mit=!0,HG=Ie(Bs,Mit);var qG;function Pit(r){qG=r.wasm.cwrap(uo,null,["number","number","number","number"])}function Lit(r){let{backend:t,inputs:e,attrs:n}=r,{alpha:o}=n,{x:s}=e,i=t.dataIdMap.get(s.dataId).id,a=t.makeOutput(s.shape,s.dtype),u=t.dataIdMap.get(a.dataId).id;return qG(i,o,Xt[s.dtype],u),a}var KG={kernelName:uo,backendName:"wasm",setupFunc:Pit,kernelFunc:Lit};var jG;function zit(r){jG=r.wasm.cwrap(La,null,["number","array","number","array","array","array","array","array","number","number"])}function Bit(r){let{backend:t,inputs:e,attrs:n}=r,{x:o}=e,{begin:s,end:i,strides:a,beginMask:u,endMask:l,ellipsisMask:c,newAxisMask:p,shrinkAxisMask:m}=n,{finalShapeSparse:f,finalShape:d,isIdentity:h,sliceDim0:g,isSimpleSlice:y,begin:b,end:w,strides:v}=Ve.sliceInfo(o.shape,s,i,a,u,l,c,p,m),k;if(h)k=pr({inputs:{x:o},backend:t,attrs:{shape:d}});else if(g||y){x.assert(o.shape.length>=1,()=>`Input must have rank at least 1, got: ${o.shape.length}`);let E=Ve.computeOutShape(b,w,v),$=zo({inputs:{x:o},backend:t,attrs:{begin:b,size:E}});k=pr({inputs:{x:$},backend:t,attrs:{shape:d}}),t.disposeData($.dataId)}else{let E=t.makeOutput(f,"float32"),$=t.dataIdMap.get(o.dataId).id,D=new Uint8Array(new Int32Array(x.computeStrides(o.shape)).buffer),R=new Uint8Array(new Int32Array(b).buffer),P=new Uint8Array(new Int32Array(w).buffer),W=new Uint8Array(new Int32Array(v).buffer),U=new Uint8Array(new Int32Array(f).buffer),q=new Uint8Array(new Int32Array(x.computeStrides(f)).buffer),K=t.dataIdMap.get(E.dataId).id;jG($,D,o.shape.length,R,P,W,U,q,f.length,K),k=pr({inputs:{x:E},backend:t,attrs:{shape:d}}),t.disposeData(E.dataId)}return k}var XG={kernelName:La,backendName:"wasm",setupFunc:zit,kernelFunc:Bit};var Vit=!0,YG=Ie(Vs,Vit);var ZG;function Git(r){ZG=r.wasm.cwrap(Ls,null,["number","number","number","number"])}function Wit(r){let{backend:t,inputs:e,attrs:n}=r,{axis:o,keepDims:s}=n,{x:i}=e,a=t.dataIdMap.get(i.dataId).id,u=a,l=i,{transposed:c,axes:p,originalAxes:m,inputWasTransposed:f}=Sn(i,o,t),d=p;if(f){let w=t.dataIdMap.get(c.dataId).id;w!==a&&(l=c,u=w,d=S.getInnerMostAxes(d.length,l.shape.length))}S.assertAxesAreInnerMostDims("sum",d,l.shape.length);let[h,g]=S.computeOutAndReduceShapes(l.shape,d),y=x.sizeFromShape(g),b=t.makeOutput(h,l.dtype);if(x.sizeFromShape(l.shape)!==0){let w=t.dataIdMap.get(b.dataId).id;ZG(u,y,Xt[b.dtype],w)}if(f&&t.disposeData(c.dataId),s){let w=S.expandShapeToKeepDim(b.shape,m);b.shape=w}return b}var JG={kernelName:Ls,backendName:"wasm",setupFunc:Git,kernelFunc:Wit};var QG=ue(Gs);var tW=ue(Ws);var eW;function Uit(r){eW=r.wasm.cwrap(Yn,null,["number","array","number","array","number","number"])}function Hit(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,s=e.dataIdMap.get(o.dataId).id,{reps:i}=n,a=new Array(o.shape.length);for(let m=0;m<a.length;m++)a[m]=o.shape[m]*i[m];let u=new Uint8Array(new Int32Array(o.shape).buffer),l=new Uint8Array(new Int32Array(a).buffer),c=e.makeOutput(a,o.dtype),p=e.dataIdMap.get(c.dataId).id;return eW(s,u,o.shape.length,l,a.length,Xt[c.dtype],p),c}var rW={kernelName:Yn,backendName:"wasm",setupFunc:Uit,kernelFunc:Hit};var nW;function qit(r){nW=r.wasm.cwrap(za,null,["number","array","number","number","number","bool","number","number"])}var Kit=({inputs:r,backend:t,attrs:e})=>{let{x:n}=r,{k:o,sorted:s}=e,i=t.dataIdMap.get(n.dataId).id,a=new Uint8Array(new Int32Array(n.shape).buffer),u=n.shape.slice();u[u.length-1]=o;let l=t.makeOutput(u,n.dtype),c=t.dataIdMap.get(l.dataId).id,p=t.makeOutput(u,"int32"),m=t.dataIdMap.get(p.dataId).id;return nW(i,a,n.shape.length,Xt[n.dtype],o,s,c,m),[l,p]},oW={kernelName:za,backendName:"wasm",setupFunc:qit,kernelFunc:Kit};var sW;function jit(r){sW=r.wasm.cwrap(Ba,null,["number","number","bool","number","number","number","number","number","number","array","number","number","number","number","number"])}function Xit(r){let{backend:t,inputs:e,attrs:n}=r,{image:o,transforms:s}=e,{interpolation:i,fillMode:a,fillValue:u,outputShape:l}=n,[c,p,m,f]=o.shape,[d,h]=l!=null?l:[p,m],g=[c,d,h,f],y=new Uint8Array(new Int32Array(x.computeStrides(o.shape)).buffer),b=t.makeOutput(g,o.dtype),w=t.dataIdMap.get(b.dataId).id,k=t.dataIdMap.get(o.dataId).id,$=t.dataIdMap.get(s.dataId).id,D=i==="nearest"?1:2,R;switch(a){case"constant":R=1;break;case"reflect":R=2;break;case"wrap":R=3;break;case"nearest":R=4;break;default:R=1;break}return sW(k,$,s.shape[0]>1,c,d,h,f,m,p,y,o.shape.length-1,D,R,u,w),b}var iW={kernelName:Ba,backendName:"wasm",setupFunc:jit,kernelFunc:Xit};function Yit(r){let{inputs:t,backend:e,attrs:n}=r,{value:o}=t,{axis:s}=n;s<0&&(s+=o.shape.length);let i=o.shape[s],a=o.shape.length,u=new Array(a-1),l=0;for(let f=0;f<a;f++)f!==s&&(u[l++]=o.shape[f]);let c=new Array(i),p=new Array(a).fill(0),m=o.shape.slice();m[s]=1;for(let f=0;f<c.length;f++)p[s]=f,c[f]=zo({inputs:{x:o},attrs:{begin:p,size:m},backend:e});return c.map(({dataId:f,dtype:d})=>({dataId:f,dtype:d,shape:u}))}var aW={kernelName:Di,backendName:"wasm",kernelFunc:Yit};function Zit(r){let{inputs:{x:t},backend:e}=r,n=e.makeOutput(t.shape,t.dtype);return e.typedArrayFromHeap(n).fill(0),n}var lW={kernelName:Ri,backendName:"wasm",kernelFunc:Zit};var Jit=[vB,CB,IB,kB,AB,DB,FB,MB,zB,VB,GB,WB,HB,qB,jB,YB,ZB,JB,tV,rV,oV,iV,lV,uV,cV,pV,mV,fV,hV,gV,xV,bV,vV,IV,kV,TV,_V,EV,NB,$V,DV,RV,FV,OV,PV,LV,BV,GV,UV,HV,KV,jV,XV,ZV,QV,eG,rG,oG,sG,iG,Kv,lG,cG,mG,fG,dG,hG,gG,PB,yG,wG,CG,IG,SG,NG,_G,AG,$G,BB,RG,FG,MG,LG,BG,VG,GG,WG,UG,HG,KG,XG,YG,JG,QG,tW,rW,oW,iW,_B,aW,lW];for(let r of Jit)Pu(r);var LT=V();LT.registerFlag("WASM_HAS_SIMD_SUPPORT",async()=>WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11])));LT.registerFlag("WASM_HAS_MULTITHREAD_SUPPORT",async()=>{if(LT.get("IS_NODE"))return!1;try{return new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch(r){return!1}});var WT=Du(mW());var fW=`"use strict";var Module={};var ENVIRONMENT_IS_NODE=typeof process==="object"&&typeof process.versions==="object"&&typeof process.versions.node==="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads");var parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",function(data){onmessage({data:data})});var fs=require("fs");Object.assign(global,{self:global,require:require,Module:Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:function(f){(0,eval)(fs.readFileSync(f,"utf8"))},postMessage:function(msg){parentPort.postMessage(msg)},performance:global.performance||{now:function(){return Date.now()}}})}function threadPrintErr(){var text=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,text+"
");return}console.error(text)}function threadAlert(){var text=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:text,threadId:Module["_pthread_self"]()})}var err=threadPrintErr;self.alert=threadAlert;Module["instantiateWasm"]=((info,receiveInstance)=>{var instance=new WebAssembly.Instance(Module["wasmModule"],info);receiveInstance(instance);Module["wasmModule"]=null;return instance.exports});self.onmessage=(e=>{try{if(e.data.cmd==="load"){Module["wasmModule"]=e.data.wasmModule;Module["wasmMemory"]=e.data.wasmMemory;Module["buffer"]=Module["wasmMemory"].buffer;Module["ENVIRONMENT_IS_PTHREAD"]=true;if(typeof e.data.urlOrBlob==="string"){importScripts(e.data.urlOrBlob)}else{var objectUrl=URL.createObjectURL(e.data.urlOrBlob);importScripts(objectUrl);URL.revokeObjectURL(objectUrl)}WasmBackendModuleThreadedSimd(Module).then(function(instance){Module=instance})}else if(e.data.cmd==="run"){Module["__performance_now_clock_drift"]=performance.now()-e.data.time;Module["__emscripten_thread_init"](e.data.threadInfoStruct,0,0,1);Module["establishStackSpace"]();Module["PThread"].receiveObjectTransfer(e.data);Module["PThread"].threadInit();try{var result=Module["invokeEntryPoint"](e.data.start_routine,e.data.arg);if(Module["keepRuntimeAlive"]()){Module["PThread"].setExitStatus(result)}else{Module["__emscripten_thread_exit"](result)}}catch(ex){if(ex!="unwind"){if(ex instanceof Module["ExitStatus"]){if(Module["keepRuntimeAlive"]()){}else{Module["__emscripten_thread_exit"](ex.status)}}else{throw ex}}}}else if(e.data.cmd==="cancel"){if(Module["_pthread_self"]()){Module["__emscripten_thread_exit"](-1)}}else if(e.data.target==="setimmediate"){}else if(e.data.cmd==="processThreadQueue"){if(Module["_pthread_self"]()){Module["_emscripten_current_thread_process_queued_calls"]()}}else if(e.data.cmd==="processProxyingQueue"){if(Module["_pthread_self"]()){Module["_emscripten_proxy_execute_queue"](e.data.queue)}}else{err("worker.js received unknown command "+e.data.cmd);err(e.data)}}catch(ex){err("worker.js onmessage() captured an uncaught exception: "+ex);if(ex&&ex.stack)err(ex.stack);if(Module["__emscripten_thread_crashed"]){Module["__emscripten_thread_crashed"]()}throw ex}});`;var gW=Du(dW());var Fg=class extends jo{constructor(t){super(),this.wasm=t,this.dataIdNextNumber=1,this.wasm.tfjs.initWithThreadsCount(yW),UT=this.wasm.tfjs.getThreadsCount(),this.dataIdMap=new Ji(this,go())}write(t,e,n){let o={id:this.dataIdNextNumber++};return this.move(o,t,e,n,1),o}numDataIds(){return this.dataIdMap.numDataIds()}async time(t){let e=x.now();return t(),{kernelMs:x.now()-e}}move(t,e,n,o,s){let i=this.dataIdNextNumber++;if(o==="string"){let c=e;this.dataIdMap.set(t,{id:i,stringBytes:c,shape:n,dtype:o,memoryOffset:null,refCount:s});return}let a=x.sizeFromShape(n),u=a*x.bytesPerElement(o),l=this.wasm._malloc(u);this.dataIdMap.set(t,{id:i,memoryOffset:l,shape:n,dtype:o,refCount:s}),this.wasm.tfjs.registerTensor(i,a,l),e!=null&&this.wasm.HEAPU8.set(new Uint8Array(e.buffer,e.byteOffset,u),l)}async read(t){return this.readSync(t)}readSync(t,e,n){let{memoryOffset:o,dtype:s,shape:i,stringBytes:a}=this.dataIdMap.get(t);if(s==="string")return(e==null||e===0)&&(n==null||n>=a.length)?a:a.slice(e,n);e=e||0,n=n||x.sizeFromShape(i);let u=x.bytesPerElement(s),l=this.wasm.HEAPU8.slice(o+e*u,o+n*u);return tat(l.buffer,s)}disposeData(t,e=!1){if(this.dataIdMap.has(t)){let n=this.dataIdMap.get(t);if(n.refCount--,!e&&n.refCount>0)return!1;this.wasm._free(n.memoryOffset),this.wasm.tfjs.disposeData(n.id),this.dataIdMap.delete(t)}return!0}refCount(t){return this.dataIdMap.has(t)?this.dataIdMap.get(t).refCount:0}incRef(t){let e=this.dataIdMap.get(t);e!=null&&e.refCount++}floatPrecision(){return 32}getMemoryOffset(t){return this.dataIdMap.get(t).memoryOffset}dispose(){this.wasm.tfjs.dispose(),"PThread"in this.wasm&&this.wasm.PThread.terminateAllThreads(),this.wasm=null}memory(){return{unreliable:!1}}makeOutput(t,e,n){let o;if(n==null)o=this.write(null,t,e);else{let s=this.dataIdNextNumber++;o={id:s},this.dataIdMap.set(o,{id:s,memoryOffset:n,shape:t,dtype:e,refCount:1});let i=x.sizeFromShape(t);this.wasm.tfjs.registerTensor(s,i,n)}return{dataId:o,shape:t,dtype:e}}typedArrayFromHeap({shape:t,dtype:e,dataId:n}){let o=this.wasm.HEAPU8.buffer,{memoryOffset:s}=this.dataIdMap.get(n),i=x.sizeFromShape(t);switch(e){case"float32":return new Float32Array(o,s,i);case"int32":return new Int32Array(o,s,i);case"bool":return new Uint8Array(o,s,i);default:throw new Error(`Unknown dtype ${e}`)}}};function Qit(r){return(t,e)=>(x.fetch(r,{credentials:"same-origin"}).then(n=>{n.ok||t.env.a(`failed to load wasm binary file at '${r}'`),n.arrayBuffer().then(o=>{WebAssembly.instantiate(o,t).then(s=>{e(s.instance,s.module)})})}),{})}function hW(r,t,e){if(Jv!=null)return Jv;let n="tfjs-backend-wasm.wasm";return r&&t?n="tfjs-backend-wasm-threaded-simd.wasm":r&&(n="tfjs-backend-wasm-simd.wasm"),Dg!=null&&Dg[n]!=null?Dg[n]:e+n}async function xW(){let[r,t]=await Promise.all([V().getAsync("WASM_HAS_SIMD_SUPPORT"),V().getAsync("WASM_HAS_MULTITHREAD_SUPPORT")]);return new Promise((e,n)=>{let o={};o.locateFile=(a,u)=>{if(a.endsWith(".worker.js")){let l=fW.replace(/\n/g,"\\n"),c=new Blob([l],{type:"application/javascript"});return URL.createObjectURL(c)}return a.endsWith(".wasm")?hW(r,t,$g!=null?$g:u):u+a},HT&&(o.instantiateWasm=Qit(hW(r,t,$g!=null?$g:"")));let s=!1;o.onAbort=()=>{if(s||Rg)return;Rg=!0,n({message:"Make sure the server can serve the `.wasm` file relative to the bundled js file. For more details see https://github.com/tensorflow/tfjs/blob/master/tfjs-backend-wasm/README.md#using-bundlers"})};let i;t&&r&&Jv==null?(o.mainScriptUrlOrBlob=new Blob(["var WasmBackendModuleThreadedSimd = "+WT.default.toString()],{type:"text/javascript"}),i=(0,WT.default)(o)):i=(0,gW.default)(o),i.then(a=>{s=!0,Rg=!1;let u=null;a.tfjs={init:a.cwrap("init",null,[]),initWithThreadsCount:a.cwrap("init_with_threads_count",null,["number"]),getThreadsCount:a.cwrap("get_threads_count","number",[]),registerTensor:a.cwrap("register_tensor",null,["number","number","number"]),disposeData:a.cwrap("dispose_data",u,["number"]),dispose:a.cwrap("dispose",u,[])},e({wasm:a})})})}function tat(r,t){switch(t){case"float32":return new Float32Array(r);case"int32":return new Int32Array(r);case"bool":return new Uint8Array(r);default:throw new Error(`Unknown dtype ${t}`)}}var eat=["tfjs-backend-wasm.wasm","tfjs-backend-wasm-simd.wasm","tfjs-backend-wasm-threaded-simd.wasm"],Jv=null,$g=null,Dg={},Rg=!1,HT=!1;function rat(r,t=!1){if(SI("setWasmPath has been deprecated in favor of setWasmPaths and will be removed in a future release."),Rg)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPath()` before you call `tf.setBackend()` or `tf.ready()`");Jv=r,HT=t}function nat(r,t=!1){if(Rg)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPaths()` before you call `tf.setBackend()` or `tf.ready()`");if(typeof r=="string")$g=r;else{Dg=r;let e=eat.filter(n=>Dg[n]==null);if(e.length>0)throw new Error(`There were no entries found for the following binaries: ${e.join(",")}. Please either call setWasmPaths with a map providing a path for each binary, or with a string indicating the directory where all the binaries can be found.`)}HT=t}var yW=-1,UT=-1;function oat(r){yW=r}function sat(){if(UT===-1)throw new Error("WASM backend not initialized.");return UT}var iat="3.15.0";var aat=2;fm("wasm",async()=>{let{wasm:r}=await xW();return new Fg(r)},aat);var lat="3.15.0",uat="3.15.0",cat="3.15.0",pat="3.15.0",mat="3.15.0",fat="3.15.0",dat="3.15.0",hat="3.15.0",gat={tfjs:lat,"tfjs-core":uat,"tfjs-data":cat,"tfjs-layers":pat,"tfjs-converter":mat,"tfjs-backend-cpu":fat,"tfjs-backend-webgl":dat,"tfjs-backend-wasm":hat};export{bi as Abs,ta as Acos,ea as Acosh,Ql as AdadeltaOptimizer,tu as AdagradOptimizer,eu as AdamOptimizer,ru as AdamaxOptimizer,Xn as Add,Zo as AddN,ra as All,na as Any,Jo as ArgMax,Al as ArgMin,oa as Asin,sa as Asinh,ia as Atan,la as Atan2,aa as Atanh,Qo as AvgPool,$l as AvgPool3D,Tp as AvgPool3DGrad,Np as AvgPoolGrad,Fg as BackendWasm,ts as BatchMatMul,wi as BatchToSpaceND,_p as Bincount,Ep as BroadcastArgs,b1 as BroadcastTo,sb as Callback,yy as CallbackList,io as Cast,es as Ceil,ao as ClipByValue,Ap as Complex,Dl as ComplexAbs,vi as Concat,rs as Conv2D,$p as Conv2DBackpropFilter,ns as Conv2DBackpropInput,Rl as Conv3D,Dp as Conv3DBackpropFilterV2,Rp as Conv3DBackpropInputV2,os as Cos,ss as Cosh,ca as CropAndResize,ua as Cumprod,is as Cumsum,wy as CustomCallback,Ji as DataStorage,Fp as DenseBincount,pa as DepthToSpace,as as DepthwiseConv2dNative,Op as DepthwiseConv2dNativeBackpropFilter,Mp as DepthwiseConv2dNativeBackpropInput,Pp as Diag,Fl as Dilation2D,Ud as Dilation2DBackpropFilter,Wd as Dilation2DBackpropInput,PC as ENV,ib as EarlyStopping,Lp as Einsum,us as Elu,zp as EluGrad,Vd as Environment,fa as Equal,ma as Erf,cs as Exp,Ci as ExpandDims,da as Expm1,Bp as FFT,Ol as Fill,ha as FlipLeftRight,ps as Floor,ms as FloorDiv,Hd as FromPixels,fs as FusedBatchNorm,Oi as FusedConv2D,Mi as FusedDepthwiseConv2D,Jc as GPGPUContext,ga as GatherNd,Ii as GatherV2,Sb as GraphModel,xa as Greater,ds as GreaterEqual,by as History,Vp as IFFT,lo as Identity,Gp as Imag,ve as InputSpec,ya as IsFinite,ba as IsInf,wa as IsNan,jo as KernelBackend,Ml as LRN,Up as LRNGrad,Hh as LayerVariable,Vn as LayersModel,hs as LeakyRelu,va as Less,Ca as LessEqual,Wp as LinSpace,gs as Log,Ia as Log1p,w1 as LogSoftmax,Sa as LogicalAnd,Ou as LogicalNot,Mu as LogicalOr,bu as MathBackendWebGL,xs as Max,bs as MaxPool,Pl as MaxPool3D,qp as MaxPool3DGrad,Hp as MaxPoolGrad,Kp as MaxPoolWithArgmax,ys as Maximum,ws as Mean,vs as Min,Cs as Minimum,Is as MirrorPad,ka as Mod,nu as MomentumOptimizer,jp as Multinomial,Ss as Multiply,Si as Neg,Ta as NonMaxSuppressionV3,_a as NonMaxSuppressionV4,Ea as NonMaxSuppressionV5,Na as NotEqual,j1 as OP_SCOPE_SUFFIX,ks as OneHot,ki as OnesLike,Vr as Optimizer,ni as OptimizerConstructors,Ni as Pack,Ns as PadV2,Cat as Pool,Ts as Pow,_s as Prelu,Aa as Prod,ou as RMSPropOptimizer,$n as RNN,Ll as Range,jC as Rank,Xp as Real,ls as RealDiv,$a as Reciprocal,Qe as Reduction,Es as Relu,$s as Relu6,Ti as Reshape,As as ResizeBilinear,Zp as ResizeBilinearGrad,zl as ResizeNearestNeighbor,Yp as ResizeNearestNeighborGrad,Ds as Reverse,Va as RotateWithOffset,Rs as Round,Fs as Rsqrt,Ui as SGDOptimizer,Da as ScatterNd,_i as Select,Ra as Selu,Xi as Sequential,Ms as Sigmoid,Oa as Sign,Os as Sin,Fa as Sinh,Ei as Slice,zs as Softmax,Ma as Softplus,Ai as SpaceToBatchND,Bl as SparseFillEmptyRows,Pa as SparseReshape,Vl as SparseSegmentMean,Gl as SparseSegmentSum,Jp as SparseToDense,$i as SplitV,Ps as Sqrt,Wl as Square,Bs as SquaredDifference,uo as Step,La as StridedSlice,Qp as StringNGrams,tm as StringSplit,em as StringToHashBucketFast,Vs as Sub,Ls as Sum,Qr as SymbolicTensor,Gs as Tan,Ws as Tanh,Pt as Tensor,pe as TensorBuffer,Yn as Tile,za as TopK,Ba as Transform,Us as Transpose,rm as Unique,Di as Unpack,Ul as UnsortedSegmentSum,Ga as Variable,Ri as ZerosLike,Fi as _FusedMatMul,Ne as abs,sh as acos,ih as acosh,J as add,kI as addN,Ku as all,Yl as any,js as argMax,ah as argMin,lh as asin,uh as asinh,ch as atan,ph as atan2,mh as atanh,qa as avgPool,fh as avgPool3d,W_ as backend,S as backend_util,MH as basicLSTMCell,xo as batchNorm,EI as batchNorm2d,AI as batchNorm3d,$I as batchNorm4d,Ka as batchToSpaceND,dh as bincount,QTt as booleanMaskAsync,DI as broadcastArgs,ja as broadcastTo,Pr as broadcast_util,Ex as browser,It as buffer,u7 as callbacks,Z as cast,hh as ceil,br as clipByValue,kn as clone,zn as complex,se as concat,RI as concat1d,FI as concat2d,OI as concat3d,MI as concat4d,r$ as constraints,Yu as conv1d,pn as conv2d,Zu as conv2dTranspose,gh as conv3d,PI as conv3dTranspose,Eat as copyRegisteredKernels,Xa as cos,Ju as cosh,Hx as cosineWindow,xh as cumprod,Qu as cumsum,mn as customGrad,vR as data,LI as denseBincount,SI as deprecationWarn,yh as depthToSpace,Ys as depthwiseConv2d,f7 as deregisterOp,jl as device_util,mq as diag,bh as dilation2d,Jct as disableDeprecationWarnings,_t as dispose,Qct as disposeVariables,ct as div,wh as divNoNan,zI as dot,fE as dropout,BI as einsum,Zs as elu,Zct as enableDebugMode,Yct as enableProdMode,dE as enclosingPowerOfTwo,go as engine,V as env,Sr as equal,vh as erf,Ze as exp,fr as expandDims,Ch as expm1,gm as eye,ol as fft,Js as fill,spt as findBackend,ipt as findBackendFactory,Qs as floor,qu as floorDiv,qP as forceHalfFloat,Co as fused,yo as gather,pE as gatherND,Ax as gather_util,npt as getBackend,BC as getGradient,Kd as getKernel,hx as getKernelsForBackend,sat as getThreadsCount,mT as gpgpu_util,Vq as grad,Gq as grads,Ge as greater,Tn as greaterEqual,Gi as ifft,tc as imag,dn as image,r_t as inTopKAsync,C$ as initializers,OS as input,Mr as io,fc as irfft,VI as isFinite,GI as isInf,Ih as isNaN,Pe as keep,Gr as kernel_impls,oD as layers,Ya as leakyRelu,ec as less,_n as lessEqual,QE as linalg,WI as linspace,iZ as loadGraphModel,w8 as loadLayersModel,Sh as localResponseNormalization,wr as log,Za as log1p,UI as logSigmoid,rc as logSoftmax,Nh as logSumExp,Nr as logicalAnd,Ja as logicalNot,nc as logicalOr,XI as logicalXor,RFt as losses,Lt as matMul,S_ as math,Dr as max,Qa as maxPool,Th as maxPool3d,YI as maxPoolWithArgmax,fn as maximum,xe as mean,oh as memory,cK as meshgrid,sD as metrics,Zl as min,ti as minimum,_h as mirrorPad,Eh as mod,y8 as model,iD as models,xm as moments,I1t as movingAverage,M as mul,yK as multiRNNCell,ZI as multinomial,Zt as neg,Vh as nextFrame,wm as norm,vo as notEqual,Ks as oneHot,lr as ones,dr as onesLike,N as op,IK as outerProduct,Yr as pad,NK as pad1d,_K as pad2d,AK as pad3d,DK as pad4d,JI as pool,Zr as pow,el as prelu,mI as print,oc as prod,tpt as profile,VK as rand,XK as randomGamma,Vx as randomNormal,ei as randomUniform,rl as range,rpt as ready,Jl as real,Ah as reciprocal,fm as registerBackend,v8 as registerCallbackConstructor,C1 as registerGradient,Pu as registerKernel,m7 as registerOp,aD as regularizers,Tr as relu,ac as relu6,opt as removeBackend,O as reshape,ir as reverse,oj as reverse1d,ij as reverse2d,lj as reverse3d,cj as reverse4d,sl as rfft,lc as round,uc as rsqrt,pt as scalar,uE as scatterND,rh as scatter_util,cc as selu,$h as separableConv2d,b8 as sequential,et as serialization,oH as setBackend,apt as setPlatform,oat as setThreadsCount,rat as setWasmPath,nat as setWasmPaths,NN as setWebGLContext,aS as setdiff1dAsync,Lr as sigmoid,Dh as sign,iFt as signal,pc as sin,mc as sinh,Rt as slice,Rh as slice1d,Gx as slice2d,Fh as slice3d,ym as slice4d,Ve as slice_util,nl as softmax,bo as softplus,tl as spaceToBatchND,Bh as sparse,Ux as sparseToDense,eFt as spectral,ur as split,be as sqrt,Ut as square,dc as squaredDifference,zr as squeeze,Je as stack,ri as step,Oh as stridedSlice,ey as string,lt as sub,mt as sum,Wu as sumOutType,Mh as tan,Xs as tanh,Ar as tensor,Re as tensor1d,Wi as tensor2d,yI as tensor3d,Mj as tensor4d,Pj as tensor5d,Lj as tensor6d,fo as tensor_util,V_ as test_util,B as tidy,kr as tile,ept as time,Ph as topk,wc as train,Wt as transpose,hc as truncatedNormal,bm as unique,_at as unregisterGradient,Tat as unregisterKernel,Lh as unsortedSegmentSum,vr as unstack,ar as upcastType,x as util,Wq as valueAndGrad,Uq as valueAndGrads,lS as variable,Ox as variableGrads,gat as version,BD as version_converter,G_ as version_core,Um as version_layers,iat as version_wasm,HP as version_webgl,YSe as webgl,cd as webgl_util,_e as where,zh as whereAsync,ye as zeros,St as zerosLike};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/
/** @license See the LICENSE file. */
